

--- CONFIGURATION FILES ---


### FILE: package.json ###
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.2.2",
    "@reduxjs/toolkit": "^2.11.2",
    "@tailwindcss/vite": "^4.1.18",
    "axios": "^1.13.2",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hook-form": "^7.68.0",
    "react-icons": "^5.5.0",
    "react-redux": "^9.2.0",
    "react-router-dom": "^7.10.1",
    "tailwindcss": "^4.1.18",
    "zod": "^4.2.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}

---

### FILE: tsconfig.json ###
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

---

### FILE: src/features/reactions/services/reactionApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type {
  PostReaction,
  CommentReaction,
  CreateReactionDto,
  UpdateReactionDto,
  ReactionQueryDto,
  PaginatedResponse,
  ResponseDto
} from '../types/types';

export const reactionApi = apiSlice.injectEndpoints({
  overrideExisting: false, // Ensure this is not overriding existing endpoints
  endpoints: (builder) => ({
    getPostReactions: builder.query<PaginatedResponse<PostReaction>, { postId: number } & ReactionQueryDto>({
      query: ({ postId, ...params }) => ({ url: `/posts/${postId}/reactions`, params }),
      providesTags: (_result, _error, { postId }) => [{ type: 'PostReaction', id: postId }],
    }),

    getCommentReactions: builder.query<PaginatedResponse<CommentReaction>, { commentId: number } & ReactionQueryDto>({
      query: ({ commentId, ...params }) => ({ url: `/comments/${commentId}/reactions`, params }),
      providesTags: (_result, _error, { commentId }) => [{ type: 'CommentReaction', id: commentId }],
    }),

    createPostReaction: builder.mutation<ResponseDto<PostReaction>, { postId: number; data: CreateReactionDto }>({
      query: ({ postId, data }) => ({ url: `/posts/${postId}/reactions`, method: 'POST', body: data }),
      invalidatesTags: ['Posts']
    }),

    updatePostReaction: builder.mutation<ResponseDto<PostReaction>, { postId: number; reactionId: number; data: UpdateReactionDto }>({
      query: ({ postId, reactionId, data }) => ({ url: `/posts/${postId}/reactions/${reactionId}`, method: 'PATCH', body: data }),
            invalidatesTags: ['Posts']

    }),

    deletePostReaction: builder.mutation<ResponseDto<boolean>, { postId: number; reactionId: number }>({
      query: ({ postId, reactionId }) => ({ url: `/posts/${postId}/reactions/${reactionId}`, method: 'DELETE' }),
          invalidatesTags: ['Posts']

    }),

    createCommentReaction: builder.mutation<ResponseDto<CommentReaction>, { commentId: number; data: CreateReactionDto }>({
      query: ({ commentId, data }) => ({ url: `/comments/${commentId}/reactions`, method: 'POST', body: data }),
      invalidatesTags: ['Comments'],
    }),

    updateCommentReaction: builder.mutation<ResponseDto<CommentReaction>, { commentId: number; reactionId: number; data: UpdateReactionDto }>({
      query: ({ commentId, reactionId, data }) => ({ url: `/comments/${commentId}/reactions/${reactionId}`, method: 'PATCH', body: data }),
      invalidatesTags: ['Comments'],
    }),

    deleteCommentReaction: builder.mutation<ResponseDto<boolean>, { commentId: number; reactionId: number }>({
      query: ({ commentId, reactionId }) => ({ url: `/comments/${commentId}/reactions/${reactionId}`, method: 'DELETE' }),
      invalidatesTags: ['Comments'],
    }),
  }),
});

export const {
  useGetPostReactionsQuery,
  useGetCommentReactionsQuery,
  useCreatePostReactionMutation,
  useUpdatePostReactionMutation,
  useCreateCommentReactionMutation,
  useUpdateCommentReactionMutation,
  useDeletePostReactionMutation,
  useDeleteCommentReactionMutation,
} = reactionApi;

---


### FILE: src/features/reactions/types/types.ts ###
export const ReactionType = {
  LIKE: 'like',
  DISLIKE: 'dislike',
} as const;

export type ReactionType = typeof ReactionType[keyof typeof ReactionType];

export interface Reaction {
    id: number;
    type: ReactionType;
    userId: number;
    createdAt: string;
    updatedAt: string;
}

export interface PostReaction extends Reaction {
    postId: number;
    user: {
        id: number;
        name: string;
    };
}

export interface CommentReaction extends Reaction {
    commentId: number;
    user: {
        id: number;
        name: string;
    };
}

export interface CreateReactionDto {
    type: ReactionType;
}

export interface UpdateReactionDto {
    type: ReactionType;
}


export interface ReactionQueryDto {
    page?: number;
    limit?: number;
    type?: ReactionType;
    userId?: number;
}

export interface PaginatedResponse<T> {
    data: T[];
    meta: {
        page: number;
        limit: number;
        totalItems: number;
        totalPages: number;
        itemCount: number;
    };
}

export interface ResponseDto<T> {
    data: T;
    message: string;
}

---


### FILE: src/features/posts/types.ts ###
import type { ReactionType } from "../reactions/types/types";

export interface Post {
  id: number;
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
  };
  community?: {
    id: number;
    name: string;
  };
  views: number;
  likesCount: number;
  dislikesCount: number;
  commentsCount: number; // Added commentsCount
  userReaction?: { id: number; type: ReactionType };
  createdAt: string;
  updatedAt: string;
}

export interface CreatePostDto {
  title: string;
  content: string;
  communityId?: number;
}

export interface UpdatePostDto {
  title?: string;
  content?: string;
}

export interface PostQueryDto {
  page?: number;
  limit?: number;
  search?: string;
  authorId?: number;
  sort?: string;
  startDate?: string;
  endDate?: string;
}

---


### FILE: src/features/posts/services/postsApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { Post, CreatePostDto, UpdatePostDto, PostQueryDto } from '../types';
import type { PaginatedResponse, ResponseDto } from '../../../shared/types';

export const postsApi = apiSlice.injectEndpoints({
    endpoints: (builder) => ({
        
      getPosts: builder.infiniteQuery<
  PaginatedResponse<Post>,
  PostQueryDto,
  number
>({
  infiniteQueryOptions: {
    initialPageParam: 1,
    getNextPageParam: (lastPage) => {
      const { page, totalPages } = lastPage.meta;
      return page < totalPages ? page + 1 : undefined;
    },
  },

  query: ({ queryArg, pageParam }) => ({
    url: '/posts',
    params: {
      ...(queryArg ?? {}),
      page: pageParam,
      limit: queryArg?.limit ?? 10,
    },
  }),

  keepUnusedDataFor: 60,
  providesTags: ['Posts'],
}),
        getPostById: builder.query<ResponseDto<Post>, number>({
            query: (id) => `/posts/${id}`,
            providesTags: (result, error, id) => [{ type: 'Posts', id }],
        }),
        createPost: builder.mutation<ResponseDto<Post>, CreatePostDto>({
            query: (newPost) => ({
                url: '/posts',
                method: 'POST',
                body: newPost,
            }),
            invalidatesTags: ['Posts'],
        }),
        updatePost: builder.mutation<ResponseDto<Post>, { id: number; data: UpdatePostDto }>({
            query: ({ id, data }) => ({
                url: `/posts/${id}`,
                method: 'PATCH',
                body: data,
            }),
            invalidatesTags: (result, error, { id }) => [{ type: 'Posts', id }],
        }),
        deletePost: builder.mutation<ResponseDto<boolean>, number>({
            query: (id) => ({
                url: `/posts/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: ['Posts'],
        }),
    }),
});

export const {
    
      useGetPostsInfiniteQuery,
    useGetPostByIdQuery,
    useCreatePostMutation,
    useUpdatePostMutation,
    useDeletePostMutation,
} = postsApi;

---


### FILE: src/features/auth/types.ts ###
export interface RegisterDto {
    name: string;
    email: string;
    password: string;
  }
  
  export interface LoginDto {
    email: string;
    password: string;
  }

  export interface UserResponseDto {
    id: string;
    name: string;
    email: string;
  }

  export interface ResponseDto<T> {
    data: T;
    message: string;
  }
  
---


### FILE: src/features/auth/stores/authSlice.ts ###
import { createSlice } from '@reduxjs/toolkit';
import type { UserResponseDto } from '../types';
import { authApi } from '../services/authApi';

interface AuthState {
  user: UserResponseDto | null;
  accessToken: string | null;
  refreshToken: string | null;
}

const initialState: AuthState = {
  user: null,
  accessToken: null,
  refreshToken: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null;
      state.accessToken = null;
      state.refreshToken = null;
    },
  },
  extraReducers: (builder) => {
    builder.addMatcher(
      authApi.endpoints.login.matchFulfilled,
      (state, action) => {
        state.user = action.payload.data.user;
        state.accessToken = action.payload.data.accessToken;
        state.refreshToken = action.payload.data.refreshToken;
      }
    );
  },
});

export const { logout } = authSlice.actions;

export default authSlice.reducer;

---


### FILE: src/features/auth/services/authApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { LoginDto, RegisterDto, UserResponseDto, ResponseDto } from '../types';

export const authApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    register: builder.mutation<ResponseDto<UserResponseDto>, RegisterDto>({
      query: (credentials) => ({
        url: 'auth/register',
        method: 'POST',
        body: credentials,
      }),
    }),
    login: builder.mutation<ResponseDto<{ user: UserResponseDto, accessToken: string, refreshToken: string }>, LoginDto>({
      query: (credentials) => ({
        url: 'auth/login',
        method: 'POST',
        body: credentials,
      }),
    }),
    refresh: builder.mutation<ResponseDto<{ user: UserResponseDto, accessToken: string, refreshToken: string }>, { refreshToken: string }>({
        query: ({refreshToken}) => ({
            url: 'auth/refresh',
            method: 'POST',
            body: {refreshToken}
        })
    }),
    resendEmailVerification: builder.mutation<ResponseDto<null>, { email: string }>({
      query: ({ email }) => ({
        url: 'email-verification/resend',
        method: 'POST',
        body: { email },
      }),
    }),
  }),
});
export const { useRegisterMutation, useLoginMutation, useRefreshMutation, useResendEmailVerificationMutation } = authApi;

---


### FILE: src/features/communities/types.ts ###
export interface Community {
  id: number;
  name: string;
  displayName: string;
  description: string;
  isPublic: boolean;
  subscribersCount: number;
  createdAt: string;
}

export interface CreateCommunityDto {
  name: string;
  displayName?: string;
  description?: string;
  isPublic?: boolean;
}

export interface UpdateCommunityDto extends Partial<CreateCommunityDto> {}

export interface CommunityQueryDto {
  name?: string;
  displayName?: string;
  isPublic?: boolean;
  page?: number;
  limit?: number;
}
---


### FILE: src/features/communities/services/communitiesApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { Community, CreateCommunityDto, UpdateCommunityDto, CommunityQueryDto } from '../types';
import type { PaginatedResponse, ResponseDto } from '../../../shared/types';

export const communitiesApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    getCommunities: builder.query<PaginatedResponse<Community>, CommunityQueryDto>({
      query: (params) => ({
        url: '/communities',
        params,
      }),
      providesTags: ['Communities'],
    }),
    getCommunityById: builder.query<ResponseDto<Community>, number>({
      query: (id) => `/communities/${id}`,
      providesTags: (result, error, id) => [{ type: 'Communities', id }],
    }),
    createCommunity: builder.mutation<ResponseDto<Community>, CreateCommunityDto>({
      query: (newCommunity) => ({
        url: '/communities',
        method: 'POST',
        body: newCommunity,
      }),
      invalidatesTags: ['Communities'],
    }),
    updateCommunity: builder.mutation<ResponseDto<Community>, { id: number; data: UpdateCommunityDto }>({
      query: ({ id, data }) => ({
        url: `/communities/${id}`,
        method: 'PATCH',
        body: data,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Communities', id }],
    }),
    deleteCommunity: builder.mutation<ResponseDto<boolean>, number>({
      query: (id) => ({
        url: `/communities/${id}`,
        method: 'DELETE',
      }),
      invalidatesTags: ['Communities'],
    }),
  }),
});

export const {
  useGetCommunitiesQuery,
  useGetCommunityByIdQuery,
  useCreateCommunityMutation,
  useUpdateCommunityMutation,
  useDeleteCommunityMutation,
} = communitiesApi;

---


### FILE: src/features/comments/types.ts ###
import type { ReactionType } from "../reactions/types/types";

export interface Comment {
    id: number;
    content: string;
    author: {
        id: number;
        name: string;
    };
    postId: number;
    parentId?: number; // For replies
    likesCount: number;
    dislikesCount: number;
    repliesCount: number;
    userReaction?: { id: number; type: ReactionType } | null;
    replies?: Comment[]; // Added for nested replies

    createdAt: string;
    updatedAt: string;
}

export interface CreateCommentDto {
    content: string;
    parentId?: number;
}

export interface UpdateCommentDto {
    content: string;
}

export interface CommentQueryDto {
    page?: number;
    limit?: number;
    postId?: number;
    authorId?: number;
    parentId?: number;
}

export interface PaginatedResponse<T> {
    data: T[];
    meta: {
        page: number;
        limit: number;
        totalItems: number;

        totalPages: number;

        itemCount: number;
    };
}

export interface ResponseDto<T> {
    data: T;
    message: string;
}

---


### FILE: src/features/comments/services/commentsApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { Comment, CreateCommentDto, UpdateCommentDto, CommentQueryDto, PaginatedResponse, ResponseDto } from '../types';

export const commentsApi = apiSlice.injectEndpoints({
    overrideExisting: false, // Ensure this is not overriding existing endpoints
    endpoints: (builder) => ({
        getCommentsByPostId: builder.infiniteQuery<
            PaginatedResponse<Comment>,
            CommentQueryDto, // Simplified type parameter
            number
        >({
            infiniteQueryOptions: {
                initialPageParam: 1,
                getNextPageParam: (lastPage) => {
                    const { page, totalPages } = lastPage.meta;
                    return page < totalPages ? page + 1 : undefined;
                },
            },
            query: ({ queryArg, pageParam }) => ({ // postId taken from queryArg
                url: `/posts/${queryArg.postId}/comments`, // Access postId from queryArg
                params: {
                    ...(queryArg ?? {}),
                    page: pageParam,
                    limit: queryArg?.limit ?? 10,
                },
            }),
           
            providesTags: ['Comments']
        }),
        createComment: builder.mutation<ResponseDto<Comment>, { postId: number; data: CreateCommentDto }>({
            query: ({ postId, data }) => ({
                url: `/posts/${postId}/comments`,
                method: 'POST',
                body: data,
            }),
            invalidatesTags: (result, error, { postId }) => [{ type: 'Comments', id: postId }],
        }),
        updateComment: builder.mutation<ResponseDto<Comment>, { id: number; data: UpdateCommentDto }>({
            query: ({ id, data }) => ({
                url: `/comments/${id}`,
                method: 'PATCH',
                body: data,
            }),
            invalidatesTags: (result, error, { id }) => [{ type: 'Comments', id }],
        }),
        deleteComment: builder.mutation<ResponseDto<boolean>, number>({
            query: (id) => ({
                url: `/comments/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: (result, error, id) => [{ type: 'Comments', id }],
        }),
    }),
});

export const {
    useGetCommentsByPostIdInfiniteQuery,
    useCreateCommentMutation,
    useUpdateCommentMutation,
    useDeleteCommentMutation,
} = commentsApi;

---


### FILE: src/shared/stores/hooks.ts ###
import { useDispatch, useSelector } from 'react-redux'
import type { RootState, AppDispatch } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
export const useAppSelector = useSelector.withTypes<RootState>()

---


### FILE: src/shared/stores/store.ts ###
import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import authReducer from '../../features/auth/stores/authSlice';
import { apiSlice } from '../services/apiSlice';

export const store = configureStore({
  reducer: {
    [apiSlice.reducerPath]: apiSlice.reducer, // Use the base apiSlice reducer
    auth: authReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(apiSlice.middleware), // Use the base apiSlice middleware
});

setupListeners(store.dispatch);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

---


### FILE: src/shared/services/apiSlice.ts ###
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

// Create a base query with authentication headers
const baseQuery = fetchBaseQuery({
  baseUrl: 'http://localhost:3000/api/',
  prepareHeaders: (headers, { getState }) => {
    // Assuming your auth slice is named 'auth' and has an 'accessToken' field
    const token = (getState() as any).auth?.accessToken;
    if (token) {
      headers.set('Authorization', `Bearer ${token}`);
    }
    return headers;
  },
});

// Create a base API slice that other API slices can extend
export const apiSlice = createApi({
  reducerPath: 'api',
  baseQuery,
  // Define common tag types here if any, otherwise leave empty
  tagTypes: ['Posts', 'Comments', 'Users', 'Reactions', 'Auth', 'Communities', 'CommunitySubscriptions', 'EmailVerification', 'Profile', 'ResetPassword', 'PostReaction', 'CommentReaction', 'PostStats', 'CommentStats'],
  endpoints: () => ({}), // Empty endpoints as this is a base slice
});

---


### FILE: src/shared/types/index.ts ###
export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    page: number;
    limit: number;
    totalItems: number;
    totalPages: number;
    itemCount: number;
  };
}

export interface ResponseDto<T> {
  data: T;
  message: string;
}

---


### FILE: src/shared/hooks/useToast.ts ###
import { useState, useCallback } from 'react';
import type { ToastType } from '../components/ui/Toast';

export interface ToastData {
  message: string;
  type: ToastType;
}

export const useToast = () => {
  const [toast, setToast] = useState<ToastData | null>(null);

  const showToast = useCallback((message: string, type: ToastType) => {
    setToast({ message, type });
  }, []);

  const hideToast = useCallback(() => {
    setToast(null);
  }, []);

  return {
    toast,
    showToast,
    hideToast,
  };
};

---

