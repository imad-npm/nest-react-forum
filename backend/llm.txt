

--- CONFIGURATION FILES ---


### FILE: package.json ###
{
  "name": "my-app",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "typeorm": "ts-node -r tsconfig-paths/register ./node_modules/typeorm/cli.js",
    "migration:run": "npm run typeorm -- migration:run -d ./src/data-source.ts",
    "migration:generate": "ts-node ./node_modules/typeorm/cli.js migration:generate -d ./src/data-source.ts",
    "mg": "ts-node ./node_modules/typeorm/cli.js migration:generate -d ./src/data-source.ts ./src/database/migrations/$npm_config_name",
    "migration:revert": "npm run typeorm -- migration:revert -d ./src/data-source.ts",
    "seed": "ts-node src/database/seeds/index.ts",
     "migration:refresh": "npm run db:drop && npm run migration:run && npm run seed",
    "db:drop": "npm run typeorm -- schema:drop -d ./src/data-source.ts"
  },
  "dependencies": {
    "@casl/ability": "^6.7.3",
    "@nestjs-modules/mailer": "^2.0.2",
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.1",
    "@nestjs/mapped-types": "^2.1.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.1.9",
    "@nestjs/typeorm": "^11.0.0",
    "bcrypt": "^6.0.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.3",
    "handlebars": "^4.7.8",
    "multer": "^2.0.2",
    "nodemailer": "^7.0.11",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "sqlite3": "^5.1.7",
    "typeorm": "^0.3.27"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@faker-js/faker": "^10.1.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@types/bcrypt": "^6.0.0",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/multer": "^2.0.0",
    "@types/node": "^22.10.7",
    "@types/passport": "^1.0.17",
    "@types/passport-jwt": "^4.0.1",
    "@types/passport-local": "^1.0.38",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

---

### FILE: nest-cli.json ###
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

---

### FILE: tsconfig.json ###
{
  "compilerOptions": {
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "resolvePackageJsonExports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}

---

### FILE: src/app.controller.ts ###
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

---


### FILE: src/database/seeds/community-membership.seed.ts ###
import { AppDataSource } from '../../data-source';
import { communityMembershipFactory } from '../factories/community-membership.factory';
import { CommunityMembership } from '../../community-memberships/entities/community-membership.entity';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';

export async function seedCommunityMemberships(
  users: User[],
  communities: Community[],
): Promise<CommunityMembership[]> {
  const membershipRepo = AppDataSource.getRepository(CommunityMembership);
  const communityRepo = AppDataSource.getRepository(Community);

  const memberships: CommunityMembership[] = [];

  for (const user of users) {
    const numMemberships = Math.floor(Math.random() * 3) + 1;
    const shuffled = [...communities].sort(() => 0.5 - Math.random());
    const toSubscribe = shuffled.slice(0, numMemberships);

    for (const community of toSubscribe) {
      const membership = communityMembershipFactory();
      membership.userId = user.id;
      membership.communityId = community.id;
      memberships.push(membership);
    }
  }

  await membershipRepo.save(memberships);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // UPDATE subscribers_count (CORRECT WAY)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  await communityRepo
    .createQueryBuilder()
    .update(Community)
    .set({
      subscribersCount: () => `
        (
          SELECT COUNT(*)
          FROM community_memberships cs
          WHERE cs.communityId = communities.id
        )
      `,
    })
    .execute();

  console.log(`Seeded ${memberships.length} community memberships ‚úÖ`);
  console.log(`Updated communities.subscribers_count ‚úÖ`);

  return memberships;
}

if (require.main === module) {
  AppDataSource.initialize().then(async () => {
    const userRepo = AppDataSource.getRepository(User);
    const communityRepo = AppDataSource.getRepository(Community);
    const users = await userRepo.find();
    const communities = await communityRepo.find();
    await seedCommunityMemberships(users, communities);
  }).catch(error => console.error('Seeding failed ‚ùå', error));
}

---


### FILE: src/database/seeds/post.seed.ts ###
import { postFactory } from '../factories/post.factory';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity'; // Import Community entity
import { AppDataSource } from '../../data-source';

export async function seedPosts(users: User[], communities: Community[]) {
  const postRepo = AppDataSource.getRepository(Post);

  const posts: Post[] = Array.from({ length: 30 }).map(() => {
    const author = users[Math.floor(Math.random() * users.length)];
    const community = communities[Math.floor(Math.random() * communities.length)]; // Select a random community
    return postFactory(author, community);
  });

  await postRepo.save(posts);
  console.log('Seeded 100 posts ‚úÖ');

  return posts;
}

if (require.main === module) seedPosts([], []);

---


### FILE: src/database/seeds/reaction.seed.ts ###
import { AppDataSource } from '../../data-source';
import { postReactionFactory } from '../factories/post-reaction.factory';
import { commentReactionFactory } from '../factories/comment-reaction.factory';

import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
export async function seedReactions(
  posts: Post[],
  comments: Comment[],
  users: User[],
): Promise<(PostReaction | CommentReaction)[]> {
  if (!users.length) {
    throw new Error('At least one user is required to seed reactions.');
  }

  const postReactionRepo = AppDataSource.getRepository(PostReaction);
  const commentReactionRepo = AppDataSource.getRepository(CommentReaction);
  const postRepo = AppDataSource.getRepository(Post);
  const commentRepo = AppDataSource.getRepository(Comment);

  const postReactionsToSave: PostReaction[] = [];
  const commentReactionsToSave: CommentReaction[] = [];

  const pickRandomUniqueUsers = (count: number): User[] => {
    const unique = new Set<number>();
    const picked: User[] = [];

    while (unique.size < count && unique.size < users.length) {
      const user = users[Math.floor(Math.random() * users.length)];
      if (!unique.has(user.id)) {
        unique.add(user.id);
        picked.push(user);
      }
    }
    return picked;
  };

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // POSTS
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (const post of posts) {
    const num = Math.floor(Math.random() * 3) + 1;
    for (const user of pickRandomUniqueUsers(num)) {
      postReactionsToSave.push(postReactionFactory(user, post));
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // COMMENTS
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (const comment of comments) {
    const num = Math.floor(Math.random() * 2) + 1;
    for (const user of pickRandomUniqueUsers(num)) {
      commentReactionsToSave.push(commentReactionFactory(user, comment));
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SAVE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const savedPostReactions = await postReactionRepo.save(postReactionsToSave);
  const savedCommentReactions = await commentReactionRepo.save(
    commentReactionsToSave,
  );

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üîÅ REBUILD COUNTERS (THE IMPORTANT PART)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // POSTS
  await postRepo
    .createQueryBuilder()
    .update(Post)
    .set({
      likesCount: () => `
        (
          SELECT COUNT(*)
          FROM post_reactions pr
          WHERE pr.postId = posts.id
            AND pr.type = 'like'
        )
      `,
      dislikesCount: () => `
        (
          SELECT COUNT(*)
          FROM post_reactions pr
          WHERE pr.postId = posts.id
            AND pr.type = 'dislike'
        )
      `,
    })
    .execute();

  // COMMENTS
  await commentRepo
    .createQueryBuilder()
    .update(Comment)
    .set({
      likesCount: () => `
        (
          SELECT COUNT(*)
          FROM comment_reactions cr
          WHERE cr.commentId = comments.id
            AND cr.type = 'like'
        )
      `,
      dislikesCount: () => `
        (
          SELECT COUNT(*)
          FROM comment_reactions cr
          WHERE cr.commentId = comments.id
            AND cr.type = 'dislike'
        )
      `,
    })
    .execute();

  const all = [...savedPostReactions, ...savedCommentReactions];
  console.log(`Seeded ${all.length} reactions ‚úÖ`);
  console.log(`Rebuilt like/dislike counters ‚úÖ`);

  return all;
}

---


### FILE: src/database/seeds/user.seed.ts ###
import { AppDataSource } from '../../data-source';
import { userFactory } from '../factories/user.factory';
import { User } from '../../users/entities/user.entity';
import * as bcrypt from 'bcrypt';
import { use } from 'passport';

export async function seedUsers() {
  const userRepo = AppDataSource.getRepository(User);

  const users: User[] = Array.from({ length: 30 }).map(() => userFactory());

  const user = new User();
  user.name = 'Test User';
  user.email = 'test@example.com';
  user.password = bcrypt.hashSync('password123', 10);
  user.emailVerifiedAt=new Date()

  users.push(user);

  await userRepo.save(users);
  console.log('Seeded 101 users ‚úÖ');

  return users;
}

if (require.main === module) seedUsers();

---


### FILE: src/database/seeds/comment.seed.ts ###
import { AppDataSource } from '../../data-source';
import { commentFactory } from '../factories/comment.factory';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';

export async function seedComments(users: User[], posts: Post[]) {
  const commentRepo = AppDataSource.getRepository(Comment);
  const postRepo = AppDataSource.getRepository(Post);

  // 1. Create initial top-level comments
  const topLevelComments: Comment[] = [];
  for (let i = 0; i < 300; i++) {
    const author = users[Math.floor(Math.random() * users.length)];
    const post = posts[Math.floor(Math.random() * posts.length)];
    topLevelComments.push(commentFactory(author, post));
  }
  await commentRepo.save(topLevelComments);
  console.log(`Seeded ${topLevelComments.length} top-level comments ‚úÖ`);

  // 2. Create replies to top-level comments
  const firstLevelReplies: Comment[] = [];
  for (let i = 0; i < topLevelComments.length / 2; i++) {
    const parentComment = topLevelComments[i];
    const numberOfReplies = Math.floor(Math.random() * 3) + 1; // 1 to 3 replies
    for (let j = 0; j < numberOfReplies; j++) {
      const author = users[Math.floor(Math.random() * users.length)];
      const post = parentComment.post;
      firstLevelReplies.push(commentFactory(author, post, parentComment.id));
    }
  }
  await commentRepo.save(firstLevelReplies);
  console.log(`Seeded ${firstLevelReplies.length} first-level replies ‚úÖ`);

  // 3. Create nested replies (replies to replies)
  const secondLevelReplies: Comment[] = [];
  for (let i = 0; i < firstLevelReplies.length / 3; i++) {
    const parentComment = firstLevelReplies[i];
    const numberOfReplies = Math.floor(Math.random() * 2) + 1; // 1 to 2 replies
    for (let j = 0; j < numberOfReplies; j++) {
      const author = users[Math.floor(Math.random() * users.length)];
      const post = parentComment.post;
      secondLevelReplies.push(commentFactory(author, post, parentComment.id));
    }
  }
  await commentRepo.save(secondLevelReplies);
  console.log(`Seeded ${secondLevelReplies.length} second-level replies ‚úÖ`);

  const allComments = [...topLevelComments, ...firstLevelReplies, ...secondLevelReplies];
  console.log(`Seeded total ${allComments.length} comments ‚úÖ`);

  // Efficiently update commentsCount for all posts using a single query
  await postRepo
    .createQueryBuilder()
    .update(Post)
    .set({
      commentsCount: () =>
        `(SELECT COUNT(*) FROM comments WHERE comments.postId = posts.id)`
    })
    .execute();

  console.log('Updated commentsCount for all posts efficiently ‚úÖ');

  await commentRepo
  .createQueryBuilder()
  .update(Comment)
  .set({
    repliesCount: () =>
      `(SELECT COUNT(*) FROM comments AS c2 WHERE c2.parentId = comments.id)`,
  })
  .execute();
  
  console.log('Updated repliesCount for all comments efficiently ‚úÖ');

  return allComments;
}

if (require.main === module) seedComments([], []);

---


### FILE: src/database/seeds/community.seed.ts ###
import { AppDataSource } from '../../data-source';
import { communityFactory } from '../factories/community.factory';
import { Community } from '../../communities/entities/community.entity';
import { User } from '../../users/entities/user.entity';

export async function seedCommunities(users: User[]): Promise<Community[]> {
  const communityRepo = AppDataSource.getRepository(Community);
  const communities: Community[] = Array.from({ length: 8 }).map(() => {
    const community = communityFactory();
    community.owner = users[Math.floor(Math.random() * users.length)];
    community.ownerId = community.owner.id;
    return community;
  });

  await communityRepo.save(communities);
  console.log(`Seeded ${communities.length} communities ‚úÖ`);
  return communities;
}

if (require.main === module) {
  AppDataSource.initialize().then(async () => {
    const userRepo = AppDataSource.getRepository(User);
    const users = await userRepo.find();
    await seedCommunities(users);
  }).catch(error => console.error('Seeding failed ‚ùå', error));
}

---


### FILE: src/database/seeds/index.ts ###
import { seedUsers } from './user.seed';
import { seedPosts } from './post.seed';
import { seedComments } from './comment.seed';
import { seedReactions } from './reaction.seed';
import { seedCommunities } from './community.seed';
import { seedCommunityMemberships } from './community-membership.seed';
import { AppDataSource } from '../../data-source';

async function main() {
  try {
    await AppDataSource.initialize();
    // Seed users
    const users = await seedUsers();

    // Seed communities
    const communities = await seedCommunities(users);

    // Seed posts
    const posts = await seedPosts(users, communities);

    // Seed comments
    const comments = await seedComments(users, posts);

    // Seed reactions (optional)
    await seedReactions(posts, comments, users);

    // Seed community memberships
    await seedCommunityMemberships(users, communities);

    console.log('Database seeding complete ‚úÖ');
  } catch (error) {
    console.error('Seeding failed ‚ùå', error);
  } finally {
    // Optional: ensure datasource is destroyed if needed
    // await AppDataSource.destroy();
  }
}

main();

---


### FILE: src/database/factories/community-membership.factory.ts ###
import { faker } from '@faker-js/faker';
import { CommunityMembership } from '../../community-memberships/entities/community-membership.entity';

export function communityMembershipFactory(): CommunityMembership {
  const membership = new CommunityMembership();
  // userId and communityId will be set when seeding, as they are foreign keys
  // For now, we can just return the basic membership object.
  return membership;
}

---


### FILE: src/database/factories/user.factory.ts ###
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';
import * as bcrypt from 'bcrypt';

export function userFactory(): User {
  const user = new User();

  user.name = faker.person.fullName();
  user.email = faker.internet.email();

  // --- Add bcrypt password ---
  const plainPassword = 'password1'; // or faker.internet.password();
  const saltRounds = 10;

  user.password = bcrypt.hashSync(plainPassword, saltRounds);

  return user;
}

---


### FILE: src/database/factories/comment-reaction.factory.ts ###
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';
import { ReactionType } from '../../reactions/reactions.types';

/**
 * Creates a CommentReaction object.
 */
export function commentReactionFactory(
  user: User,
  comment: Comment,
): CommentReaction {
  const reaction = new CommentReaction();

  reaction.user = user;
  reaction.comment = comment;

  const types = Object.values(ReactionType);
  reaction.type = faker.helpers.arrayElement(types);

  return reaction;
}

---


### FILE: src/database/factories/post.factory.ts ###
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity'; // Import Community entity
import { faker } from '@faker-js/faker';

export function postFactory(author: User, community: Community): Post {
  const post = new Post();
  post.title = faker.lorem.sentence();
  post.content = faker.lorem.paragraph();
  post.author = author;
  post.community = community; // Assign community
  return post;
}

---


### FILE: src/database/factories/comment.factory.ts ###
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';
import { faker } from '@faker-js/faker';

export function commentFactory(author: User, post: Post, parentId?: number): Comment {
  const comment = new Comment();
  comment.content = faker.lorem.sentence();
  comment.author = author;
  comment.post = post;
  comment.repliesCount = 0;
  if (parentId) {
    comment.parentId = parentId;
  }
  return comment;
}

---


### FILE: src/database/factories/post-reaction.factory.ts ###
import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';
import { ReactionType } from '../../reactions/reactions.types';

/**
 * Creates a PostReaction object.
 */
export function postReactionFactory(user: User, post: Post): PostReaction {
  const reaction = new PostReaction();

  reaction.user = user;
  reaction.post = post;

  const types = Object.values(ReactionType);
  reaction.type = faker.helpers.arrayElement(types);

  return reaction;
}

---


### FILE: src/database/factories/community.factory.ts ###
import { faker } from '@faker-js/faker';
import { Community } from '../../communities/entities/community.entity';
import { CommunityType } from '../../communities/types';

export function communityFactory(): Community {
  const community = new Community();
  community.name = faker.internet.username();
  community.displayName = faker.company.name();
  community.description = faker.lorem.paragraph();
  community.communityType = faker.helpers.arrayElement(Object.values(CommunityType));
  community.subscribersCount = faker.number.int({ min: 0, max: 1000 });
  return community;
}

---


### FILE: src/database/migrations/1765931083722-MakePostCommunityMandatory.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class MakePostCommunityMandatory1765931083722 implements MigrationInterface {
    name = 'MakePostCommunityMandatory1765931083722'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
    }

}

---


### FILE: src/database/migrations/1765627185088-AddPictureFieldToUser.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddPictureFieldToUser1765627185088 implements MigrationInterface {
    name = 'AddPictureFieldToUser1765627185088'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "picture" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
        await queryRunner.query(`CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`);
        await queryRunner.query(`DROP TABLE "temporary_users"`);
    }

}

---


### FILE: src/database/migrations/1766443444048-AddCommentsLockedToPost.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommentsLockedToPost1766443444048 implements MigrationInterface {
    name = 'AddCommentsLockedToPost1766443444048'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "commentsLocked" boolean NOT NULL DEFAULT (0), "isApproved" boolean NOT NULL DEFAULT (0), "approvedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, CONSTRAINT "FK_d6947c03c05fca0fa035b19e73d" FOREIGN KEY ("moderatorId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_4927687e8f8ed1b2e4c849ddc82" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_moderators"("moderatorId", "communityId") SELECT "moderatorId", "communityId" FROM "community_moderators"`);
        await queryRunner.query(`DROP TABLE "community_moderators"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_moderators" RENAME TO "community_moderators"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_2d9086cef1ffd5148f90a9fab5d" FOREIGN KEY ("ownerId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "community_moderators" RENAME TO "temporary_community_moderators"`);
        await queryRunner.query(`CREATE TABLE "community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_moderators"("moderatorId", "communityId") SELECT "moderatorId", "communityId" FROM "temporary_community_moderators"`);
        await queryRunner.query(`DROP TABLE "temporary_community_moderators"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "community_moderators"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
    }

}

---


### FILE: src/database/migrations/1765490375370-refactor-reactions.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class RefactorReactions1765490375370 implements MigrationInterface {
  name = 'RefactorReactions1765490375370';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `,
    );
    await queryRunner.query(
      `CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b8f6756d160de241ea96a768254" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "post_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "post_reactions"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_post_reactions" RENAME TO "post_reactions"`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_ab02238d3deb62cba37aa8047dd" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "comment_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "comment_reactions"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment_reactions" RENAME TO "comment_reactions"`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
    await queryRunner.query(
      `ALTER TABLE "comment_reactions" RENAME TO "temporary_comment_reactions"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `INSERT INTO "comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "temporary_comment_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment_reactions"`);
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
    await queryRunner.query(
      `ALTER TABLE "post_reactions" RENAME TO "temporary_post_reactions"`,
    );
    await queryRunner.query(
      `CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `INSERT INTO "post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "temporary_post_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post_reactions"`);
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
    await queryRunner.query(`DROP TABLE "comment_reactions"`);
    await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
    await queryRunner.query(`DROP TABLE "post_reactions"`);
  }
}

---


### FILE: src/database/migrations/1765821272324-AddLikesDislikesToPostsComments.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddLikesDislikesToPostsComments1765821272324 implements MigrationInterface {
    name = 'AddLikesDislikesToPostsComments1765821272324'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`);
        await queryRunner.query(`DROP TABLE "comment"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment" RENAME TO "comment"`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`ALTER TABLE "comment" RENAME TO "temporary_comment"`);
        await queryRunner.query(`CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`);
        await queryRunner.query(`DROP TABLE "temporary_comment"`);
    }

}

---


### FILE: src/database/migrations/1765628559552-RefactorProfileEntity.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class RefactorProfileEntity1765628559552 implements MigrationInterface {
    name = 'RefactorProfileEntity1765628559552'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"))`);
        await queryRunner.query(`CREATE TABLE "temporary_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_profiles" RENAME TO "profiles"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "profiles" RENAME TO "temporary_profiles"`);
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"))`);
        await queryRunner.query(`INSERT INTO "profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
    }

}

---


### FILE: src/database/migrations/1764720178421-inital.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class Inital1764720178421 implements MigrationInterface {
  name = 'Inital1764720178421';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "user" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar NOT NULL, "email" varchar NOT NULL, CONSTRAINT "UQ_e12875dfb3b1d92d7d7c5377e22" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(`DROP TABLE "user"`);
  }
}

---


### FILE: src/database/migrations/1766320141300-AddStatusToCommunityMembership.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddStatusToCommunityMembership1766320141300 implements MigrationInterface {
    name = 'AddStatusToCommunityMembership1766320141300'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "status" varchar CHECK( "status" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
    }

}

---


### FILE: src/database/migrations/1766412136598-AddApprovedAtToPosts.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddApprovedAtToPosts1766412136598 implements MigrationInterface {
    name = 'AddApprovedAtToPosts1766412136598'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "isApproved" boolean NOT NULL DEFAULT (0), "approvedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_2d9086cef1ffd5148f90a9fab5d" FOREIGN KEY ("ownerId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
    }

}

---


### FILE: src/database/migrations/1765671180328-AddCommunitiesAndMemberships.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommunitiesAndMemberships1765671180328 implements MigrationInterface {
    name = 'AddCommunitiesAndMemberships1765671180328'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
    }

}

---


### FILE: src/database/migrations/1765630608057-MakeUsernameNonNullable.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class MakeUsernameNonNullable1765630608057 implements MigrationInterface {
    name = 'MakeUsernameNonNullable1765630608057'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_profiles" RENAME TO "profiles"`);
        await queryRunner.query(`CREATE TABLE "temporary_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar NOT NULL, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_profiles" RENAME TO "profiles"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "profiles" RENAME TO "temporary_profiles"`);
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_profiles"`);
        await queryRunner.query(`ALTER TABLE "profiles" RENAME TO "temporary_profiles"`);
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_profiles"`);
    }

}

---


### FILE: src/database/migrations/1766168966958-MakeParentIdNullable.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class MakeParentIdNullable1766168966958 implements MigrationInterface {
    name = 'MakeParentIdNullable1766168966958'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
    }

}

---


### FILE: src/database/migrations/1764783033004-AddReactions.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddReactions1764783033004 implements MigrationInterface {
  name = 'AddReactions1764783033004';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_e58a09ab17e3ce4c47a1a330ae1" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "reaction"`,
    );
    await queryRunner.query(`DROP TABLE "reaction"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_reaction" RENAME TO "reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(
      `ALTER TABLE "reaction" RENAME TO "temporary_reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `INSERT INTO "reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "temporary_reaction"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_reaction"`);
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(`DROP TABLE "reaction"`);
  }
}

---


### FILE: src/database/migrations/1766168720979-AddRepliesCountToComment.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddRepliesCountToComment1766168720979 implements MigrationInterface {
    name = 'AddRepliesCountToComment1766168720979'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
    }

}

---


### FILE: src/database/migrations/1766319450404-AddCommunityTypeToCommunity.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommunityTypeToCommunity1766319450404 implements MigrationInterface {
    name = 'AddCommunityTypeToCommunity1766319450404'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" boolean NOT NULL DEFAULT (1), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" boolean NOT NULL DEFAULT (1), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
    }

}

---


### FILE: src/database/migrations/1765214825123-addVerifrokesTable.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddVerifrokesTable1765214825123 implements MigrationInterface {
  name = 'AddVerifrokesTable1765214825123';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "email_verification_tokens" ("id" varchar PRIMARY KEY NOT NULL, "token" varchar NOT NULL, "userId" integer NOT NULL, "expiresAt" datetime NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "UQ_3d1613f95c6a564a3b588d161ae" UNIQUE ("token"))`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE "email_verification_tokens"`);
  }
}

---


### FILE: src/database/migrations/1765927724937-AddCommentsCountToPost.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommentsCountToPost1765927724937 implements MigrationInterface {
    name = 'AddCommentsCountToPost1765927724937'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "commentsCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
    }

}

---


### FILE: src/database/migrations/1765377593735-AddOauthcols.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddOauthcols1765377593735 implements MigrationInterface {
  name = 'AddOauthcols1765377593735';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt") SELECT "id", "name", "email", "password", "emailVerifiedAt" FROM "users"`,
    );
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`,
    );
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_users"`);
    await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt") SELECT "id", "name", "email", "password", "emailVerifiedAt" FROM "temporary_users"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_users"`);
  }
}

---


### FILE: src/database/migrations/1765457240708-addResetPasswordTokenTable.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddResetPasswordTokenTable1765457240708 implements MigrationInterface {
  name = 'AddResetPasswordTokenTable1765457240708';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "password_reset_tokens" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "token" varchar NOT NULL, "expiresAt" datetime NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_d6a19d4b4f6c62dcd29daa497e" ON "password_reset_tokens" ("userId") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_ab673f0e63eac966762155508e" ON "password_reset_tokens" ("token") `,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP INDEX "IDX_ab673f0e63eac966762155508e"`);
    await queryRunner.query(`DROP INDEX "IDX_d6a19d4b4f6c62dcd29daa497e"`);
    await queryRunner.query(`DROP TABLE "password_reset_tokens"`);
  }
}

---


### FILE: src/database/migrations/1764871406438-addingColsToUser.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddingColsToUser1764871406438 implements MigrationInterface {
  name = 'AddingColsToUser1764871406438';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "temporary_reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "reaction"`,
    );
    await queryRunner.query(`DROP TABLE "reaction"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_reaction" RENAME TO "reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_e58a09ab17e3ce4c47a1a330ae1" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "reaction"`,
    );
    await queryRunner.query(`DROP TABLE "reaction"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_reaction" RENAME TO "reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(
      `ALTER TABLE "reaction" RENAME TO "temporary_reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "temporary_reaction"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_reaction"`);
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(
      `ALTER TABLE "reaction" RENAME TO "temporary_reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_e58a09ab17e3ce4c47a1a330ae1" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "temporary_reaction"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_reaction"`);
  }
}

---


### FILE: src/database/migrations/1765209236854-AddEmailVerifiedColumn.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddEmailVerifiedColumn1765209236854 implements MigrationInterface {
  name = 'AddEmailVerifiedColumn1765209236854';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_users"("id", "name", "email", "password") SELECT "id", "name", "email", "password" FROM "users"`,
    );
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "users"("id", "name", "email", "password") SELECT "id", "name", "email", "password" FROM "temporary_users"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_users"`);
  }
}

---


### FILE: src/database/migrations/1765929661449-RenameTablesToPlural.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class RenameTablesToPlural1765929661449 implements MigrationInterface {
    name = 'RenameTablesToPlural1765929661449'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`CREATE TABLE "temporary_post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "post_reactions"`);
        await queryRunner.query(`DROP TABLE "post_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_post_reactions" RENAME TO "post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`CREATE TABLE "temporary_comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "comment_reactions"`);
        await queryRunner.query(`DROP TABLE "comment_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment_reactions" RENAME TO "comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer)`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`);
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`CREATE TABLE "temporary_post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b8f6756d160de241ea96a768254" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "post_reactions"`);
        await queryRunner.query(`DROP TABLE "post_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_post_reactions" RENAME TO "post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`CREATE TABLE "temporary_comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_ab02238d3deb62cba37aa8047dd" FOREIGN KEY ("commentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "comment_reactions"`);
        await queryRunner.query(`DROP TABLE "comment_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment_reactions" RENAME TO "comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`ALTER TABLE "comment_reactions" RENAME TO "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "temporary_comment_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`ALTER TABLE "post_reactions" RENAME TO "temporary_post_reactions"`);
        await queryRunner.query(`CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "temporary_post_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`ALTER TABLE "comment_reactions" RENAME TO "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_ab02238d3deb62cba37aa8047dd" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "temporary_comment_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`ALTER TABLE "post_reactions" RENAME TO "temporary_post_reactions"`);
        await queryRunner.query(`CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b8f6756d160de241ea96a768254" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "temporary_post_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
    }

}

---


### FILE: src/database/migrations/1766448730463-AddReportEntities.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddReportEntities1766448730463 implements MigrationInterface {
    name = 'AddReportEntities1766448730463'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`CREATE TABLE "post_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer NOT NULL)`);
        await queryRunner.query(`CREATE TABLE "comment_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "commentId" integer NOT NULL)`);
        await queryRunner.query(`CREATE TABLE "user_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "reportedUserId" integer NOT NULL)`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "commentsLocked" boolean NOT NULL DEFAULT (0), "isApproved" boolean NOT NULL DEFAULT (0), "approvedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, CONSTRAINT "FK_d6947c03c05fca0fa035b19e73d" FOREIGN KEY ("moderatorId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_4927687e8f8ed1b2e4c849ddc82" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_moderators"("moderatorId", "communityId") SELECT "moderatorId", "communityId" FROM "community_moderators"`);
        await queryRunner.query(`DROP TABLE "community_moderators"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_moderators" RENAME TO "community_moderators"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_2d9086cef1ffd5148f90a9fab5d" FOREIGN KEY ("ownerId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_post_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer NOT NULL, CONSTRAINT "FK_4f4c3c25aa849390b9cb7fd6fa1" FOREIGN KEY ("reporterId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b9b9977c4da06492b2491cea20a" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post_reports"("id", "reporterId", "reason", "createdAt", "updatedAt", "postId") SELECT "id", "reporterId", "reason", "createdAt", "updatedAt", "postId" FROM "post_reports"`);
        await queryRunner.query(`DROP TABLE "post_reports"`);
        await queryRunner.query(`ALTER TABLE "temporary_post_reports" RENAME TO "post_reports"`);
        await queryRunner.query(`CREATE TABLE "temporary_comment_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "commentId" integer NOT NULL, CONSTRAINT "FK_36ab772754faebab9c812565988" FOREIGN KEY ("reporterId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_14ce729bcc2ec2f7c16b11b2d9e" FOREIGN KEY ("commentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment_reports"("id", "reporterId", "reason", "createdAt", "updatedAt", "commentId") SELECT "id", "reporterId", "reason", "createdAt", "updatedAt", "commentId" FROM "comment_reports"`);
        await queryRunner.query(`DROP TABLE "comment_reports"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment_reports" RENAME TO "comment_reports"`);
        await queryRunner.query(`CREATE TABLE "temporary_user_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "reportedUserId" integer NOT NULL, CONSTRAINT "FK_4c8ff913a6d53469649f6941ece" FOREIGN KEY ("reporterId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_85aa921a0dfd2b7d58cd4cd9450" FOREIGN KEY ("reportedUserId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_user_reports"("id", "reporterId", "reason", "createdAt", "updatedAt", "reportedUserId") SELECT "id", "reporterId", "reason", "createdAt", "updatedAt", "reportedUserId" FROM "user_reports"`);
        await queryRunner.query(`DROP TABLE "user_reports"`);
        await queryRunner.query(`ALTER TABLE "temporary_user_reports" RENAME TO "user_reports"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "user_reports" RENAME TO "temporary_user_reports"`);
        await queryRunner.query(`CREATE TABLE "user_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "reportedUserId" integer NOT NULL)`);
        await queryRunner.query(`INSERT INTO "user_reports"("id", "reporterId", "reason", "createdAt", "updatedAt", "reportedUserId") SELECT "id", "reporterId", "reason", "createdAt", "updatedAt", "reportedUserId" FROM "temporary_user_reports"`);
        await queryRunner.query(`DROP TABLE "temporary_user_reports"`);
        await queryRunner.query(`ALTER TABLE "comment_reports" RENAME TO "temporary_comment_reports"`);
        await queryRunner.query(`CREATE TABLE "comment_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "commentId" integer NOT NULL)`);
        await queryRunner.query(`INSERT INTO "comment_reports"("id", "reporterId", "reason", "createdAt", "updatedAt", "commentId") SELECT "id", "reporterId", "reason", "createdAt", "updatedAt", "commentId" FROM "temporary_comment_reports"`);
        await queryRunner.query(`DROP TABLE "temporary_comment_reports"`);
        await queryRunner.query(`ALTER TABLE "post_reports" RENAME TO "temporary_post_reports"`);
        await queryRunner.query(`CREATE TABLE "post_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer NOT NULL)`);
        await queryRunner.query(`INSERT INTO "post_reports"("id", "reporterId", "reason", "createdAt", "updatedAt", "postId") SELECT "id", "reporterId", "reason", "createdAt", "updatedAt", "postId" FROM "temporary_post_reports"`);
        await queryRunner.query(`DROP TABLE "temporary_post_reports"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "community_moderators" RENAME TO "temporary_community_moderators"`);
        await queryRunner.query(`CREATE TABLE "community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_moderators"("moderatorId", "communityId") SELECT "moderatorId", "communityId" FROM "temporary_community_moderators"`);
        await queryRunner.query(`DROP TABLE "temporary_community_moderators"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "user_reports"`);
        await queryRunner.query(`DROP TABLE "comment_reports"`);
        await queryRunner.query(`DROP TABLE "post_reports"`);
        await queryRunner.query(`DROP TABLE "community_moderators"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "subscribersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "subscribersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
    }

}

---


### FILE: src/database/migrations/1765628229160-CreateUserProfileAndLinkToUser.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateUserProfileAndLinkToUser1765628229160 implements MigrationInterface {
    name = 'CreateUserProfileAndLinkToUser1765628229160'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "user_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_7bdaa0714f4c1087a926a2d8369" UNIQUE ("username"), CONSTRAINT "REL_8481388d6325e752cd4d7e26c6" UNIQUE ("userId"))`);
        await queryRunner.query(`CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
        await queryRunner.query(`CREATE TABLE "temporary_user_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_7bdaa0714f4c1087a926a2d8369" UNIQUE ("username"), CONSTRAINT "REL_8481388d6325e752cd4d7e26c6" UNIQUE ("userId"), CONSTRAINT "FK_8481388d6325e752cd4d7e26c6d" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_user_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "user_profiles"`);
        await queryRunner.query(`DROP TABLE "user_profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_user_profiles" RENAME TO "user_profiles"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "user_profiles" RENAME TO "temporary_user_profiles"`);
        await queryRunner.query(`CREATE TABLE "user_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_7bdaa0714f4c1087a926a2d8369" UNIQUE ("username"), CONSTRAINT "REL_8481388d6325e752cd4d7e26c6" UNIQUE ("userId"))`);
        await queryRunner.query(`INSERT INTO "user_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_user_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_user_profiles"`);
        await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
        await queryRunner.query(`CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "picture" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`);
        await queryRunner.query(`DROP TABLE "temporary_users"`);
        await queryRunner.query(`DROP TABLE "user_profiles"`);
    }

}

---


### FILE: src/main.ts ###
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { useContainer } from 'class-validator';
import { NestExpressApplication } from '@nestjs/platform-express';
import { join } from 'path';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  // Use validation pipe globally
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true, // auto-convert types
      transformOptions: {
        enableImplicitConversion: true, // allows automatic type conversion
      },
    }),
  );
     app.setGlobalPrefix('api'); // all routes will now start with /api

app.enableCors({
  origin: '*', // allow any origin
});

  // Get ConfigService instance
  const configService = app.get(ConfigService);
  const port = configService.get<number>('PORT') ?? 3000;

  // Serve static files from the 'uploads' directory
  app.useStaticAssets(join(__dirname, '..', 'uploads'), {
    prefix: '/uploads/',
  });

  await app.listen(port);
  console.log(`Application is running on: http://localhost:${port}`);
}
bootstrap();

---


### FILE: src/users/pipes/user.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { UsersService } from '../users.service';
import { User } from '../entities/user.entity';

@Injectable()
export class UserPipe implements PipeTransform<string, Promise<User>> {
  constructor(private readonly usersService: UsersService) {}

  async transform(value: string): Promise<User> {
    return this.usersService.findOneById(+value);
  }
}

---


### FILE: src/users/users.service.ts ###
// src/users/users.service.ts
import { BadRequestException, ConflictException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Brackets, Not, Repository } from 'typeorm';
import * as bcrypt from 'bcrypt';
import { User } from './entities/user.entity';
import { ProfileService } from '../profile/profile.service'; // Import ProfileService

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private readonly repo: Repository<User>,
  ) {}

  async findAll(
    page = 1,
    limit = 10,
    search?: string,
    provider?: 'google' | 'github',
  ): Promise<{ data: User[]; count: number }> {
    const query = this.repo.createQueryBuilder('user').leftJoinAndSelect('user.profile', 'profile'); // Eagerly load profile

    if (search) {
      query.where(
        new Brackets((qb) => {
          qb.where('user.name LIKE :search', {
            search: `%${search}%`,
          }).orWhere('user.email LIKE :search', { search: `%${search}%` })
          .orWhere('profile.username LIKE :search', { search: `%${search}%` }); // Search in profile username
        }),
      );
    }

    if (provider) {
      query.andWhere('user.provider = :provider', { provider });
    }

    query.orderBy('user.createdAt', 'DESC');

    const [data, count] = await query
      .take(limit)
      .skip((page - 1) * limit)
      .getManyAndCount();

    return { data, count };
  }


  private async find(where: any, message: string): Promise<User> {
    const user = await this.repo.findOne({ where, relations: ['profile'] }); // Eagerly load profile
    if (!user) throw new NotFoundException(message);
    return user;
  }


  async findOneById(id: number): Promise<User> {
    return this.find({ id }, `User with ID ${id} not found.`);
  }

  async findByEmail(email: string): Promise<User> {
    return this.find({ email }, `User with email ${email} not found.`);
  }


async createUser({
  name,
  email,
  password,
  provider,
  providerId,
  emailVerifiedAt,
}: {
  name: string;
  email: string;
  password?: string | null;
  provider?: 'google' | 'github' | null;
  providerId?: string | null;
  emailVerifiedAt?: Date | null;
}): Promise<User> {

  const emailExists = await this.repo.exists({ where: { email } });
  if (emailExists) {
    throw new ConflictException('Email already in use');
  }

  if (provider && password) {
    throw new BadRequestException(
      'Password-based accounts cannot have a provider',
    );
  }

  if (provider && !providerId) {
    throw new BadRequestException('providerId is required when provider is set');
  }

  const user = this.repo.create({
    name,
    email,
    provider: provider ?? null,
    providerId: providerId ?? null,
    emailVerifiedAt:
      emailVerifiedAt ?? (password ? null : new Date()),
    password: password
      ? await bcrypt.hash(password, 10)
      : null,
  });

  return this.repo.save(user);
}
 async updateUser({
  user,
  name,
  email,
  password,
  provider,
  providerId,
  emailVerifiedAt,
}: {
  user: User;
  name?: string;
  email?: string;
  password?: string | null;
  provider?: 'google' | 'github' | null;
  providerId?: string | null;
  emailVerifiedAt?: Date | null;
}): Promise<User> {
  
  if (email !== undefined && email !== user.email) {
    const emailExists = await this.repo.exists({
      where: {
        email,
        id: Not(user.id),
      },
    });

    if (emailExists) {
      throw new ConflictException('Email already in use');
    }
  }

  if (provider !== undefined && password !== undefined) {
    throw new BadRequestException(
      'Cannot update provider and password together',
    );
  }

  if (provider !== undefined && provider && !providerId) {
    throw new BadRequestException(
      'providerId is required when provider is set',
    );
  }

  Object.assign(user, {
    ...(name !== undefined && { name }),
    ...(email !== undefined && { email }),
    ...(provider !== undefined && { provider }),
    ...(providerId !== undefined && { providerId }),
    ...(emailVerifiedAt !== undefined && { emailVerifiedAt }),
  });

  if (password !== undefined) {
    user.password = password
      ? await bcrypt.hash(password, 10)
      : null;
  }

  return this.repo.save(user);
}


  async markEmailAsVerified(id: number): Promise<void> {
    const user = await this.findOneById(id);

    if (!user.emailVerifiedAt) {
      user.emailVerifiedAt = new Date();
      await this.repo.save(user);
    }
  }
}
---


### FILE: src/users/dtos/user-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsString, IsEnum } from 'class-validator';

export class UserQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  search?: string; // Filter by name or email

  @IsOptional()
  @IsEnum(['google', 'github'])
  provider?: 'google' | 'github';
}

---


### FILE: src/users/dtos/user-response.dto.ts ###
import { Exclude, Expose, plainToInstance } from 'class-transformer';
import { User } from '../entities/user.entity';

@Exclude()
export class UserResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly name: string;
  @Expose() readonly email: string;
  @Expose() readonly emailVerifiedAt: Date | null;
  @Expose() readonly provider: string | null;

  static fromEntity(entity: User): UserResponseDto {
    return plainToInstance(UserResponseDto, entity, {
      excludeExtraneousValues: true,
    });
  }
}

---


### FILE: src/users/users.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  imports: [TypeOrmModule.forFeature([User])], // Add ProfileModule here
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService], // Export the service so it can be injected elsewhere
})
export class UsersModule {}

---


### FILE: src/users/entities/user.entity.ts ###
// src/users/entities/user.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToMany,
  OneToOne,
  JoinColumn,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { Profile } from '../../profile/entities/profile.entity'; // Import Profile
import { Community } from '../../communities/entities/community.entity';
import { CommunityMembership } from '../../community-memberships/entities/community-membership.entity';
import { CommunityModerator } from '../../community-moderators/entities/community-moderator.entity'; // Import CommunityModerator
import { PostReport } from '../../reports/entities/post-report.entity';
import { CommentReport } from '../../reports/entities/comment-report.entity'; // NEW IMPORT
import { UserReport } from '../../reports/entities/user-report.entity'; // NEW IMPORT


export enum UserRole {
  SUPER_ADMIN,
  ADMIN,
  USER
}

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 100 })
  name: string;

  @Column({ type: 'varchar', length: 100, unique: true })
  email: string;

  @Column({ type: 'varchar', nullable: true })
  password: string | null;

  @Column({ type: 'datetime', nullable: true, default: null })
  emailVerifiedAt: Date | null; // üëà NEW FIELD

  @Column({
    type: 'simple-enum',
    enum: ['google', 'github'],
    nullable: true,
    default: null,
  })
  provider: 'google' | 'github' | null;

  @Column({ type: 'varchar', nullable: true })
  providerId: string | null; // Google's profile.id

  // One-to-one relation with Profile
  @OneToOne(() => Profile, (profile) => profile.user)
  profile: Profile;

    @Column({
    type: 'simple-enum', // sqlite compatible
    enum: UserRole,
    default: UserRole.USER,
  })
  role: UserRole;

  // Relations
  @OneToMany(() => Post, (post) => post.author)
  posts: Post[];

  @OneToMany(() => Comment, (comment) => comment.author)
  comments: Comment[];

  @OneToMany(() => PostReaction, (reaction) => reaction.user)
  postReactions: PostReaction[];

  @OneToMany(() => CommentReaction, (reaction) => reaction.user)
  commentReactions: CommentReaction[];

  @OneToMany(() => Community, (community) => community.owner)
  createdCommunities: Community[];

  @OneToMany(
    () => CommunityMembership,
    (communityMembership) => communityMembership.user,
  )
  communityMemberships: CommunityMembership[];

  @OneToMany(() => CommunityModerator, (communityModerator) => communityModerator.moderator)
  moderatedCommunities: CommunityModerator[];

  @OneToMany(() => PostReport, (postReport) => postReport.reporter)
  postReports: PostReport[];

  @OneToMany(() => CommentReport, (commentReport) => commentReport.reporter) // NEW RELATION
  commentReports: CommentReport[];

  @OneToMany(() => UserReport, (userReport) => userReport.reporter)
  reportedUserReports: UserReport[];

  @OneToMany(() => UserReport, (userReport) => userReport.reportedUser)
  userReports: UserReport[];
}
---


### FILE: src/users/users.controller.ts ###
import { Controller, Get, Query } from '@nestjs/common';
import { UsersService } from './users.service';
import { UserQueryDto } from './dtos/user-query.dto';
import { UserResponseDto } from './dtos/user-response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  async findAll(@Query() query: UserQueryDto): Promise<PaginatedResponseDto<UserResponseDto>> {
    const { data, count } = await this.usersService.findAll(
      query.page,
      query.limit,
      query.search,
      query.provider,
    );

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(UserResponseDto.fromEntity), paginationMeta);
  }
}

---


### FILE: src/community-memberships/types.ts ###

export enum CommunityMembershipStatus {
  ACTIVE = 'active',
  PENDING = 'pending',
  BLOCKED = 'blocked',
}
---


### FILE: src/community-memberships/community-memberships.module.ts ###
import { Module } from '@nestjs/common';
import { CommunityMembershipsService } from './community-memberships.service';
import { CommunityMembershipsController } from './community-memberships.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CommunityMembership } from './entities/community-membership.entity';
import { CommunitiesModule } from '../communities/communities.module';
import { UsersModule } from 'src/users/users.module';
import { User } from 'src/users/entities/user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([CommunityMembership,User]), 
  CommunitiesModule],
  controllers: [CommunityMembershipsController],
  providers: [CommunityMembershipsService],
  exports: [CommunityMembershipsService],
})
export class CommunityMembershipsModule {}

---


### FILE: src/community-memberships/community-memberships.service.ts ###
import {
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CommunityMembership } from './entities/community-membership.entity';
import { User } from '../users/entities/user.entity';
import { CommunitiesService } from '../communities/communities.service';
import { UsersService } from 'src/users/users.service';
import { CommunityType } from 'src/communities/types';
import { CommunityMembershipStatus } from './types';

interface MembershipQuery {
  userId?: number;
  communityId?: number;
  page?: number;
  limit?: number;
}

@Injectable()
export class CommunityMembershipsService {
  constructor(
    @InjectRepository(CommunityMembership)
    private readonly membershipsRepository: Repository<CommunityMembership>,
    private readonly communitiesService: CommunitiesService,
    @InjectRepository(User)
    private readonly usersRepository: Repository<User>,
  ) { }


  async findMemberships(query: MembershipQuery): Promise<{ data: CommunityMembership[]; count: number }> {
    const where: any = {};
    const relations: string[] = [];

    if (query.userId) {
      where.userId = query.userId;
      relations.push('community');
    }

    if (query.communityId) {
      where.communityId = query.communityId;
      relations.push('user');
    }

    const options: any = { where, relations };

    // Pagination
    if (query.page !== undefined && query.limit !== undefined) {
      const page = Math.max(1, query.page);
      const limit = Math.max(1, query.limit);
      options.skip = (page - 1) * limit;
      options.take = limit;
    }

    const [data, count] = await this.membershipsRepository.findAndCount(options);
    return { data, count };
  }

  async findOne(userId: number, communityId: number): Promise<CommunityMembership | null> {
    return this.membershipsRepository.findOne({
      where: { userId, communityId },
    });
  }

  async createMembership(input: {
    userId: number;
    communityId: number;
    activate?: boolean;
  }) {
    const { userId, communityId, activate } = input;

    // Check community existence
    const community = await this.communitiesService.findOne(communityId);
    if (!community) {
      throw new NotFoundException(`Community ${communityId} not found`);
    }

    const userExists = await this.usersRepository.exist({
      where: { id: userId },
    });
    if (!userExists) {
      throw new NotFoundException(`User ${userId} not found`);
    }


    const existingMembership = await this.membershipsRepository.findOne({
      where: {
        userId: userId,
        communityId: community.id,
      },
    });

    if (existingMembership) {
      if (existingMembership.status === CommunityMembershipStatus.BLOCKED) {
        throw new ConflictException(
          `User ${userId} is blocked from community ${community.id}`,
        );
      }
      throw new ConflictException(
        `User ${userId} is already subscribed to community ${community.id}`,
      );
    }

    const communityType = community.communityType;
    let membershipStatus: CommunityMembershipStatus;

    if (activate) {
      membershipStatus = CommunityMembershipStatus.ACTIVE;
    } else if (communityType === CommunityType.PUBLIC) {
      membershipStatus = CommunityMembershipStatus.ACTIVE;
    } else {
      membershipStatus = CommunityMembershipStatus.PENDING;
    }

    const membership = this.membershipsRepository.create({
      userId: userId,
      communityId: community.id,
      status: membershipStatus,
    });

    const savedMembership = await this.membershipsRepository.save(
      membership,
    );

    await this.communitiesService.update({
      id: community.id,
      subscribersCount: community.subscribersCount + 1,
    });

    return savedMembership;
  }

  async deleteMembership(communityId: number, userId: number) {

    // Check community existence
    const community = await this.communitiesService.findOne(communityId);
    if (!community) throw new NotFoundException(`Community ${communityId} not found`);

    // Check user existence via UsersService
    const userExists = await this.usersRepository.exist({
      where: { id: userId },
    });
    if (!userExists) {
      throw new NotFoundException(`User ${userId} not found`);
    }


    const existingMembership = await this.membershipsRepository.findOne({
      where: {
        userId: userId,
        communityId: community.id,
      },
    });

    if (!existingMembership) {
      throw new NotFoundException(
        `User ${userId} is not subscribed to community ${community.id}`,
      );
    }

    await this.membershipsRepository.remove(existingMembership);

    await this.communitiesService.update({
      id: community.id,
      subscribersCount: community.subscribersCount - 1,
    });

    return { message: 'Unsubscribed successfully' };
  }

  // --- New methods for membership status checks ---
  async getMembershipStatus(userId: number, communityId: number): Promise<CommunityMembershipStatus | null> {
    const membership = await this.membershipsRepository.findOne({
      where: { userId, communityId },
      select: ['status'],
    });
    return membership ? membership.status : null;
  }

  async isActiveMember(userId: number, communityId: number): Promise<boolean> {
    const status = await this.getMembershipStatus(userId, communityId);
    return status === CommunityMembershipStatus.ACTIVE;
  }

  async isBlocked(userId: number, communityId: number): Promise<boolean> {
    const status = await this.getMembershipStatus(userId, communityId);
    return status === CommunityMembershipStatus.BLOCKED;
  }

  async activateMembership(
    userId: number,
    communityId: number,
  ): Promise<CommunityMembership> {
    const membership = await this.findOne(userId, communityId);
    if (!membership) {
      throw new NotFoundException('Membership not found.');
    }
    if (membership.status === CommunityMembershipStatus.BLOCKED) {
      throw new ConflictException('User is blocked from this community');
    }
    if (membership.status === CommunityMembershipStatus.ACTIVE) {
      return membership;
    }
    membership.status = CommunityMembershipStatus.ACTIVE;
    return this.membershipsRepository.save(membership);
  }
}

---


### FILE: src/community-memberships/entities/community-membership.entity.ts ###
import {
  Column,
  CreateDateColumn,
  Entity,
  ManyToOne,
  PrimaryColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';
import { CommunityMembershipStatus } from '../types';

@Entity('community_memberships')
export class CommunityMembership {
  @PrimaryColumn()
  userId: number;

  @PrimaryColumn()
  communityId: number;

  @ManyToOne(() => User, (user) => user.communityMemberships)
  user: User;

  @ManyToOne(() => Community, (community) => community.memberships)
  community: Community;

  @Column({ type: "simple-enum", enum:CommunityMembershipStatus, default: CommunityMembershipStatus.PENDING })
  status: CommunityMembershipStatus;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: src/community-memberships/community-memberships.controller.ts ###
import {
  Controller,
  Post,
  Param,
  ParseIntPipe,
  Delete,
  UseGuards,
  Get,
  Query,
} from '@nestjs/common';
import { CommunityMembershipsService } from './community-memberships.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { User } from '../users/entities/user.entity';
import { CommunityMembershipResponseDto } from './dto/community-membership-response.dto';
import { GetUser } from 'src/decorators/user.decorator';
import { CommunityMembership } from './entities/community-membership.entity';
import { CommunityMembershipQueryDto } from './dto/community-membership-query.dto';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';

@Controller()
export class CommunityMembershipsController {
  constructor(
    private readonly communityMembershipsService: CommunityMembershipsService,
  ) { }


  // Unified GET endpoint
  @Get('community-memberships')
  async findMemberships(
   @Query() query: CommunityMembershipQueryDto,
  ): Promise<PaginatedResponseDto<CommunityMembershipResponseDto>> {
    

    const { data, count } = await this.communityMembershipsService.findMemberships({
      userId:query.userId,
      communityId:query.communityId ,
      page:query.page ,
      limit : query.limit
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(CommunityMembershipResponseDto.fromEntity), paginationMeta);
  }

@UseGuards(JwtAuthGuard)
  @Post('communities/:communityId/memberships')
  async createMembership(
    @Param('communityId', ParseIntPipe) communityId: number,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommunityMembershipResponseDto>> {
    const membership = await this.communityMembershipsService.createMembership(
      communityId,
      user.id,
    );
    return new ResponseDto(CommunityMembershipResponseDto.fromEntity(membership));
  }
  
@UseGuards(JwtAuthGuard)
  @Delete('users/me/communities/:communityId/memberships')
  async deleteMembership(
    @Param('communityId', ParseIntPipe) communityId: number,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    await this.communityMembershipsService.deleteMembership(communityId, user.id);
    return new ResponseDto(true);
  }
}


---


### FILE: src/community-memberships/dto/community-membership-query.dto.ts ###
import { IsBoolean, IsNumber, IsOptional, IsString } from 'class-validator';
import { PaginationDto } from '../../common/dto/pagination.dto';
import { Transform } from 'class-transformer';

export class CommunityMembershipQueryDto extends PaginationDto {
  @IsOptional()
  @IsNumber()
  userId?: number;

  @IsOptional()
  @IsNumber()
  communityId?: number;

 
}

---


### FILE: src/community-memberships/dto/community-membership-response.dto.ts ###
import { Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { CommunityResponseDto } from '../../communities/dto/community-response.dto';
import { CommunityMembership } from '../entities/community-membership.entity';
import { CommunityMembershipStatus } from '../types';

export class CommunityMembershipResponseDto {
  @Expose()
  userId: number;

  @Expose()
  communityId: number;

  @Expose()
  @Type(() => UserResponseDto)
  user: UserResponseDto;

  @Expose()
  @Type(() => CommunityResponseDto)
  community: CommunityResponseDto;

  @Expose()
  status: CommunityMembershipStatus;

  @Expose()
  createdAt: Date;

  static fromEntity(
    entity: CommunityMembership,
  ): CommunityMembershipResponseDto {
    return plainToInstance(CommunityMembershipResponseDto, entity);
  }
}

---


### FILE: src/community-memberships/dto/create-community-membership.dto.ts ###
import { IsNumber } from 'class-validator';

export class CreateCommunityMembershipDto {
  @IsNumber()
  communityId: number;
}

---


### FILE: src/reactions/pipes/post-reaction.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { ReactionsService } from '../reactions.service';
import { PostReaction } from '../entities/post-reaction.entity';

@Injectable()
export class PostReactionPipe implements PipeTransform<
  string,
  Promise<PostReaction>
> {
  constructor(private readonly reactionsService: ReactionsService) {}

  async transform(value: string): Promise<PostReaction> {
    return this.reactionsService.findPostReactionById(+value);
  }
}

---


### FILE: src/reactions/pipes/comment-reaction.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { ReactionsService } from '../reactions.service';
import { CommentReaction } from '../entities/comment-reaction.entity';

@Injectable()
export class CommentReactionPipe implements PipeTransform<
  string,
  Promise<CommentReaction>
> {
  constructor(private readonly reactionsService: ReactionsService) {}

  async transform(value: string): Promise<CommentReaction> {
    return this.reactionsService.findCommentReactionById(+value);
  }
}

---


### FILE: src/reactions/reactions.controller.ts ###
import {
  Controller,
  Post,
  Get,
  Body,
  Param,
  Delete,
  UseGuards,
  NotFoundException,
  Query,
  Patch,
} from '@nestjs/common';
import { ReactionsService } from './reactions.service';
import { CreateReactionDto } from './dto/create-reaction.dto';
import { UpdateReactionDto } from './dto/update-reaction.dto';
import { User } from 'src/users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { Action } from 'src/casl/casl.types';
import { PostReaction } from './entities/post-reaction.entity';
import { CommentReaction } from './entities/comment-reaction.entity';
import { Post as PostEntity } from '../posts/entities/post.entity';
import { Comment as CommentEntity } from '../comments/entities/comment.entity';
import { CaslService } from 'src/casl/casl.service';
import { ReactionResponseDto } from './dto/reaction-response.dto';
import { PostReactionPipe } from './pipes/post-reaction.pipe';
import { CommentReactionPipe } from './pipes/comment-reaction.pipe';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { ReactionQueryDto } from './dto/reaction-query.dto';
import { CommentPipe } from 'src/comments/pipes/comment.pipe';
import { PostPipe } from 'src/posts/pipes/post.pipe';


@Controller()
export class ReactionsController {
  constructor(
    private readonly reactionsService: ReactionsService,
    private readonly caslService: CaslService,
  ) {}

  @Post('posts/:postId/reactions')
  @UseGuards(JwtAuthGuard)
  async createPostReaction(
    @Param('postId', PostPipe) post: PostEntity,
    @Body() dto: CreateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Create, PostReaction);
    const reaction = await this.reactionsService.create(
     {   type :dto.type,
      userId :user.id,
      postId: post.id,}
    );
    return new ResponseDto(ReactionResponseDto.fromEntity(reaction));
  }

  @Get('posts/:postId/reactions')
  async getPostReactions(
    @Param('postId', PostPipe) post: PostEntity,
    @Query() query: ReactionQueryDto,
  ): Promise<PaginatedResponseDto<ReactionResponseDto>> {
    const { data, count } = await this.reactionsService.findByPost({ postId: post.id, page: query.page, limit: query.limit });
    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );
    return new PaginatedResponseDto(data.map(ReactionResponseDto.fromEntity), paginationMeta);
  }

  @Patch('posts/:postId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async updatePostReaction(
    @Param('reactionId', PostReactionPipe) reaction: PostReaction,
    @Body() dto: UpdateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Update, reaction);
    const updatedReaction = await this.reactionsService.updatePostReaction({
       id:reaction.id,
       type:dto.type});
    return new ResponseDto(ReactionResponseDto.fromEntity(updatedReaction));
  }

  @Post('comments/:commentId/reactions')
  @UseGuards(JwtAuthGuard)
  async createCommentReaction(
    @Param('commentId', CommentPipe) comment: CommentEntity,
    @Body() dto: CreateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Create, CommentReaction);
    const reaction = await this.reactionsService.create(
   {   type :dto.type,
      userId :user.id,
      commentId: comment.id,}
    );
    return new ResponseDto(ReactionResponseDto.fromEntity(reaction));
  }

  @Get('comments/:commentId/reactions')
  async getCommentReactions(
    @Param('commentId', CommentPipe) comment: CommentEntity,
    @Query() query: ReactionQueryDto,
  ): Promise<PaginatedResponseDto<ReactionResponseDto>> {
    const { data, count } = await this.reactionsService.findByComment({ commentId: comment.id, page: query.page, limit: query.limit });
    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );
    return new PaginatedResponseDto(data.map(ReactionResponseDto.fromEntity), paginationMeta);
  }

  @Patch('comments/:commentId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async updateCommentReaction(
    @Param('reactionId', CommentReactionPipe) reaction: CommentReaction,
    @Body() dto: UpdateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Update, reaction);
    const updatedReaction = await this.reactionsService.updateCommentReaction({ id:reaction.id,
      type: dto.type});
    return new ResponseDto(ReactionResponseDto.fromEntity(updatedReaction));
  }

  @Delete('posts/:postId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async deletePostReaction(
    @Param('reactionId', PostReactionPipe) reaction: PostReaction,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, reaction);
    await this.reactionsService.deletePostReaction(reaction.id);
    return new ResponseDto(true);
  }

  @Delete('comments/:commentId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async deleteCommentReaction(
    @Param('reactionId', CommentReactionPipe) reaction: CommentReaction,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, reaction);
    await this.reactionsService.deleteCommentReaction(reaction.id);
    return new ResponseDto(true);
  }
}

---


### FILE: src/reactions/reactions.types.ts ###
export enum ReactionType {
  LIKE = 'like',
  DISLIKE = 'dislike',
}

---


### FILE: src/reactions/reactions.service.ts ###
import {
  Injectable,
  BadRequestException,
  ForbiddenException,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';

import { PostReaction } from './entities/post-reaction.entity';
import { CommentReaction } from './entities/comment-reaction.entity';
import { ReactionType } from './reactions.types';
import { PostsService } from 'src/posts/posts.service';
import { CommentsService } from 'src/comments/comments.service';
import { UpdateReactionDto } from './dto/update-reaction.dto';

@Injectable()
export class ReactionsService {
  constructor(
    @InjectRepository(PostReaction)
    private readonly postReactionRepo: Repository<PostReaction>,

    @InjectRepository(CommentReaction)
    private readonly commentReactionRepo: Repository<CommentReaction>,

    private readonly postsService: PostsService,
    private readonly commentsService: CommentsService,
  ) { }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // CREATE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async create({
    type,
    userId,
    postId,
    commentId,
  }: {
    type: ReactionType;
    userId: number;
    postId?: number;
    commentId?: number;
  }) {
    if (!Object.values(ReactionType).includes(type)) {
      throw new BadRequestException('Invalid reaction type');
    }

    if (!!postId === !!commentId) {
      throw new BadRequestException(
        'Reaction must target either a post or a comment (not both)',
      );
    }


    if (postId) {
      const post = await this.postsService.findOne(postId);
      if (!post) throw new NotFoundException(`Post with ID ${postId} not found`);

      const existing = await this.postReactionRepo.findOne({
        where: { userId, postId },
      });
      console.log(existing);
      
      if (existing) {
        throw new ForbiddenException(
          'You already reacted to this post',
        );
      }

      const newReaction = await this.postReactionRepo.save(
        this.postReactionRepo.create({ type, userId, postId }),
      );
      if (newReaction.type === ReactionType.LIKE) {
        await this.postsService.incrementLikesCount(postId);
      } else {
        await this.postsService.incrementDislikesCount(postId);
      }
      return newReaction;
    }
    else if (commentId) {
      const comment = await this.commentsService.findOne(commentId);
      if (!comment) throw new NotFoundException(`Comment with ID ${commentId} not found`);

      const existing = await this.commentReactionRepo.findOne({
        where: { userId, commentId },
      });

      if (existing) {
        throw new ForbiddenException(
          'You already reacted to this comment',
        );
      }

      const newReaction = await this.commentReactionRepo.save(
        this.commentReactionRepo.create({ type, userId, commentId }),
      );
      if (newReaction.type === ReactionType.LIKE) {
        await this.commentsService.incrementLikesCount(commentId);
      } else {
        await this.commentsService.incrementDislikesCount(commentId);
      }
      return newReaction;
    }
    throw new BadRequestException(
      'Reaction must target either a post or a comment',
    );

  }
  async findByPost({
    postId,
    page = 1,
    limit = 10,
  }: {
    postId: number;
    page?: number;
    limit?: number;
  }): Promise<{ data: PostReaction[]; count: number }> {
    const skip = (page - 1) * limit;

    const [data, count] = await this.postReactionRepo.findAndCount({
      where: { postId },
      relations: ['user'],
      select: {
        id: true,
        type: true,
        createdAt: true,
        user: { id: true, name: true },
      },
      skip,
      take: limit,
    });

    return { data, count };
  }

  async findByComment({
    commentId,
    page = 1,
    limit = 10,
  }: {
    commentId: number;
    page?: number;
    limit?: number;
  }): Promise<{ data: CommentReaction[]; count: number }> {
    const skip = (page - 1) * limit;

    const [data, count] = await this.commentReactionRepo.findAndCount({
      where: { commentId },
      relations: ['user'],
      select: {
        id: true,
        type: true,
        createdAt: true,
        user: { id: true, name: true },
      },
      skip,
      take: limit,
    });

    return { data, count };
  }

  async getUserReactionOnPost(
    userId: number,
    postId: number,
  ) {
    return this.postReactionRepo.findOne({ where: { userId, postId } });
  }

  async findPostReactionById(id: number): Promise<PostReaction> {
    const reaction = await this.postReactionRepo.findOne({ where: { id } });
    if (!reaction) {
      throw new NotFoundException('Post reaction not found');
    }
    return reaction;
  }

  async findCommentReactionById(id: number): Promise<CommentReaction> {
    const reaction = await this.commentReactionRepo.findOne({ where: { id } });
    if (!reaction) {
      throw new NotFoundException('Comment reaction not found');
    }
    return reaction;
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // UPDATE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 async updatePostReaction({
  id,
  type
}: {
  id: number;
  type: ReactionType;
}) {
  const reaction = await this.postReactionRepo.findOneBy({ id });
  if (!reaction) throw new NotFoundException('Post reaction not found');
  
  // Return early if no change
  if (reaction.type === type) return reaction;

  const oldType = reaction.type;
  const newType = type;
  const postId = reaction.postId;

  // Update counters based on change
  if (oldType === ReactionType.LIKE) {
    await this.postsService.decrementLikesCount(postId);
  } else if (oldType === ReactionType.DISLIKE) {
    await this.postsService.decrementDislikesCount(postId);
  }

  if (newType === ReactionType.LIKE) {
    await this.postsService.incrementLikesCount(postId);
  } else if (newType === ReactionType.DISLIKE) {
    await this.postsService.incrementDislikesCount(postId);
  }

  // Update reaction type
  reaction.type = newType;
  return this.postReactionRepo.save(reaction);
}

async updateCommentReaction({
  id,
  type
}: {
  id: number;
  type: ReactionType;
}) {
  const reaction = await this.commentReactionRepo.findOneBy({ id });
  if (!reaction) throw new NotFoundException('Comment reaction not found');

  // Return early if no change
  if (reaction.type === type) return reaction;

  const oldType = reaction.type;
  const newType = type;
  const commentId = reaction.commentId;

  // Update counters based on change
  if (oldType === ReactionType.LIKE) {
    await this.commentsService.decrementLikesCount(commentId);
  } else if (oldType === ReactionType.DISLIKE) {
    await this.commentsService.decrementDislikesCount(commentId);
  }

  if (newType === ReactionType.LIKE) {
    await this.commentsService.incrementLikesCount(commentId);
  } else if (newType === ReactionType.DISLIKE) {
    await this.commentsService.incrementDislikesCount(commentId);
  }

  // Update reaction type
  reaction.type = newType;
  return this.commentReactionRepo.save(reaction);
}
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // DELETE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async deletePostReaction(id: number) {
    const reaction = await this.postReactionRepo.findOneBy({ id });
    if (!reaction) {
      throw new NotFoundException('Post reaction not found');
    }

    const result = await this.postReactionRepo.delete(id);
    if (result.affected) {
      const post = await this.postsService.findOne(reaction.postId);
      if (!post) throw new NotFoundException(`Post with ID               
     ${reaction.postId} not found`);

      if (reaction.type === ReactionType.LIKE) {
        await this.postsService.decrementLikesCount(reaction.postId);
      } else {
        await this.postsService.decrementDislikesCount(reaction.postId);
      }
    }
  }

  async deleteCommentReaction(id: number) {
    const reaction = await this.commentReactionRepo.findOneBy({ id });
    if (!reaction) {
      throw new NotFoundException('Comment reaction not found');
    }

    const result = await this.commentReactionRepo.delete(id);
    if (result.affected) {
      const comment = await this.commentsService.findOne(reaction.commentId);
      if (!comment) throw new NotFoundException(`Comment with ID               
     ${reaction.commentId} not found`);

      if (reaction.type === ReactionType.LIKE) {
        await this.commentsService.decrementLikesCount(reaction.commentId);
      } else {
        await this.commentsService.decrementDislikesCount(reaction.commentId);
      }
    }
  }
}

---


### FILE: src/reactions/reactions.module.ts ###
import { Module } from '@nestjs/common';
import { ReactionsService } from './reactions.service';
import { ReactionsController } from './reactions.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PostReaction } from './entities/post-reaction.entity';
import { CommentReaction } from './entities/comment-reaction.entity';
import { CaslModule } from 'src/casl/casl.module';
import { PostsModule } from 'src/posts/posts.module';
import { CommentsModule } from 'src/comments/comments.module';

@Module({
  providers: [ReactionsService],
  controllers: [ReactionsController],
  imports: [
    TypeOrmModule.forFeature([PostReaction, CommentReaction]),
    CaslModule,
    PostsModule,
    CommentsModule,
  ],
  exports: [ReactionsService],
})
export class ReactionsModule {}

---


### FILE: src/reactions/entities/post-reaction.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  Index,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { ReactionType } from '../../reactions/reactions.types'; // Assuming ReactionType is still needed and will be moved or re-defined

@Entity('post_reactions')
@Index(['postId', 'userId'], { unique: true }) // Ensure a user can only react once to a post
export class PostReaction {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'simple-enum',
    enum: ReactionType,
  })
  type: ReactionType;

  @ManyToOne(() => Post, (post) => post.reactions, { onDelete: 'CASCADE' })
  post: Post;

  @Column()
  postId: number;

  @ManyToOne(() => User, (user) => user.postReactions, { onDelete: 'CASCADE' })
  user: User;

  @Column()
  userId: number;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

---


### FILE: src/reactions/entities/comment-reaction.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  Index,
} from 'typeorm';
import { Comment } from '../../comments/entities/comment.entity'; // Corrected path
import { User } from '../../users/entities/user.entity';
import { ReactionType } from '../../reactions/reactions.types'; // Assuming ReactionType is still needed and will be moved or re-defined

@Entity('comment_reactions')
@Index(['commentId', 'userId'], { unique: true }) // Ensure a user can only react once to a comment
export class CommentReaction {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'simple-enum',
    enum: ReactionType,
  })
  type: ReactionType;

  @ManyToOne(() => Comment, (comment) => comment.reactions, {
    onDelete: 'CASCADE',
  })
  comment: Comment;

  @Column()
  commentId: number;

  @ManyToOne(() => User, (user) => user.commentReactions, {
    onDelete: 'CASCADE',
  })
  user: User;

  @Column()
  userId: number;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

---


### FILE: src/reactions/dto/reaction-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsEnum, IsInt } from 'class-validator';
import { Type } from 'class-transformer';
import { ReactionType } from '../reactions.types';

export class ReactionQueryDto extends PaginationDto {
  @IsOptional()
  @IsEnum(ReactionType)
  type?: ReactionType;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  userId?: number;
}

---


### FILE: src/reactions/dto/reaction-response.dto.ts ###
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { PostReaction } from '../entities/post-reaction.entity';
import { CommentReaction } from '../entities/comment-reaction.entity';
import { ReactionType } from '../reactions.types';

@Exclude()
export class ReactionResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly type: ReactionType;
  @Expose() @Type(() => UserResponseDto) readonly user: UserResponseDto;
  @Expose() postId?: number;
  @Expose() commentId?: number;
  @Expose() readonly createdAt: Date;

  static fromEntity(
    entity: PostReaction | CommentReaction,
  ): ReactionResponseDto {
    const dto = plainToInstance(
      ReactionResponseDto,
      {
        ...entity,
        user: entity.user ? UserResponseDto.fromEntity(entity.user) : null,
      },
      { excludeExtraneousValues: true },
    );

    if ('postId' in entity) {
      dto.postId = entity.postId;
      dto.commentId = undefined; // Ensure commentId is not set if it's a post reaction
    } else if ('commentId' in entity) {
      dto.commentId = entity.commentId;
      dto.postId = undefined; // Ensure postId is not set if it's a comment reaction
    }

    return dto;
  }
}

---


### FILE: src/reactions/dto/update-reaction.dto.ts ###
import { IsEnum } from 'class-validator';
import { ReactionType } from '../reactions.types';

export class UpdateReactionDto {
  @IsEnum(ReactionType)
  type: ReactionType;
}
---


### FILE: src/reactions/dto/create-reaction.dto.ts ###
import { IsEnum } from 'class-validator';
import { ReactionType } from '../reactions.types';

export class CreateReactionDto {
  @IsEnum(ReactionType)
  type: ReactionType;
}

---


### FILE: src/common/dto/pagination-meta.dto.ts ###

export class PaginationMetaDto {
  page: number;

  limit: number;

  totalItems: number;

  totalPages: number;

  itemCount: number;

  constructor(page: number, limit: number, totalItems: number, itemCount: number) {
    this.page = page;
    this.limit = limit;
    this.totalItems = totalItems;
    this.itemCount = itemCount;
    this.totalPages = Math.ceil(this.totalItems / this.limit);
  }
}

---


### FILE: src/common/dto/response.dto.ts ###

export class ResponseDto<T> {
  data: T;

  message?: string;

  meta?: {
    count?: number;
    total?: number;
    [key: string]: any;
  };

  constructor(data: T, message?: string, meta?: { count?: number; total?: number; [key: string]: any }) {
    this.data = data;
    this.message = message;
    this.meta = meta;
  }
}

---


### FILE: src/common/dto/pagination.dto.ts ###
import { Type } from 'class-transformer';
import { IsInt, Min, IsOptional } from 'class-validator';

export class PaginationDto {
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page: number = 1; // default 1

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  limit: number = 10; // default 10
}

---


### FILE: src/common/dto/paginated-response.dto.ts ###
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { PaginationMetaDto } from './pagination-meta.dto';
import { ResponseDto } from './response.dto';

export class PaginatedResponseDto<T> extends ResponseDto<T[]> {
  data: T[];

  @Type(() => PaginationMetaDto)
  @ValidateNested()
  meta: PaginationMetaDto;

  constructor(data: T[], meta: PaginationMetaDto) {
    super(data,undefined, meta);
    this.data = data;
    this.meta = meta;
  }
}

---


### FILE: src/reports/reports.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ReportsService } from './reports.service';
import { ReportsController } from './reports.controller';
import { CommentReport } from './entities/comment-report.entity';
import { PostReport } from './entities/post-report.entity';
import { UserReport } from './entities/user-report.entity';
import { Post } from 'src/posts/entities/post.entity';
import { User } from 'src/users/entities/user.entity';
import { Comment } from 'src/comments/entities/comment.entity';
import { CaslModule } from 'src/casl/casl.module';
import { CommunityModerator } from 'src/community-moderators/entities/community-moderator.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      CommentReport,
      PostReport,
      UserReport,
      Post,
      User,
      Comment,
      CommunityModerator,
    ]),
    CaslModule,
  ],
  controllers: [ReportsController],
  providers: [ReportsService],
})
export class ReportsModule {}

---


### FILE: src/reports/reports.controller.ts ###
import { Controller, Post, Body, UseGuards, Patch, Param, Get, Query } from '@nestjs/common';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';
import { ReportsService } from './reports.service';
import { ReportQueryDto } from './dto/report-query.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { ReportResponseDto } from './dto/report-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { ResponseDto } from 'src/common/dto/response.dto';

@Controller('reports')
@UseGuards(JwtAuthGuard)
export class ReportsController {
  constructor(private readonly reportsService: ReportsService) {}

  @Post()
  async createReport(
    @Body() createReportDto: CreateReportDto,
    @GetUser() user: User,
  ) {
    return this.reportsService.create(createReportDto, user);
  }

  @Get()
  async findAll(
    @Query() query: ReportQueryDto & { communityId?: number },
    @GetUser() user: User,
  ): Promise<PaginatedResponseDto<ReportResponseDto>> {
    const { data, count } = await this.reportsService.findAll({
      ...query,
      userId: user.id,
    });
    const paginationMeta = new PaginationMetaDto(query.page, query.limit, count, data.length); // Use defaulted values
    return new PaginatedResponseDto(data.map(ReportResponseDto.fromEntity), paginationMeta);
  }

  @Get(':id')
  async findOne(@Param('id') id: number, @Query('entityType') entityType: 'comment' | 'post' | 'user'): Promise<ResponseDto<ReportResponseDto>> {
    const report = await this.reportsService.findOne(id, entityType);
    return new ResponseDto(ReportResponseDto.fromEntity(report));
  }

  @Patch(':id')
  async updateReportStatus(
    @Param('id') id: number,
    @Body() updateReportDto: UpdateReportDto,
  ) {
    // TODO: Add authorization check for moderators
    return this.reportsService.updateStatus(id, updateReportDto.status, updateReportDto.entityType);
  }
}

---


### FILE: src/reports/entities/comment-report.entity.ts ###
import {
  Entity,
  Column,
  ManyToOne,
} from 'typeorm';
import { Comment } from '../../comments/entities/comment.entity';
import { BaseReport } from './base-report.entity';
import { User } from '../../users/entities/user.entity';

@Entity('comment_reports')
export class CommentReport extends BaseReport {
  @ManyToOne(() => User, (user) => user.commentReports, { onDelete: 'CASCADE' })
  reporter: User;

  @Column()
  commentId: number;

    @Column()
  communityId: number;

  @ManyToOne(() => Comment, (comment) => comment.reports, { onDelete: 'CASCADE' })
  comment: Comment;

  @Column({ default: false })
  isPlatformComplaint: boolean;
}
---


### FILE: src/reports/entities/post-report.entity.ts ###
import {
  Entity,
  Column,
  ManyToOne,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { BaseReport } from './base-report.entity';
import { User } from '../../users/entities/user.entity'; // User import not needed here as reporter is inherited

@Entity('post_reports')
export class PostReport extends BaseReport {

 @ManyToOne(() => User, (user) => user.postReports, { onDelete: 'CASCADE' })
  reporter: User;

  @Column()
  postId: number;


  @Column()
  communityId: number;

  @ManyToOne(() => Post, (post) => post.reports, { onDelete: 'CASCADE' })
  post: Post;

  @Column({ default: false })
  isPlatformComplaint: boolean;
}
---


### FILE: src/reports/entities/user-report.entity.ts ###
import {
  Entity,
  Column,
  ManyToOne,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { BaseReport } from './base-report.entity';

@Entity('user_reports')
export class UserReport extends BaseReport {
  @ManyToOne(() => User, (user) => user.reportedUserReports, { onDelete: 'CASCADE' })
  reporter: User;

  @Column()
  reportedUserId: number;

  @ManyToOne(() => User, (user) => user.userReports, { onDelete: 'CASCADE' })
  reportedUser: User;

  @Column({ default: false })
  isPlatformComplaint: boolean;
}
---


### FILE: src/reports/entities/base-report.entity.ts ###
import {
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';

export enum ReportStatus {
  PENDING = 'pending',
  RESOLVED = 'resolved',
  DISMISSED = 'dismissed',
}

export abstract class BaseReport {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  reporterId: number;
/*
  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  reporter: User;
*/
  @Column()
  reason: string;

  @Column({ type: 'text', nullable: true })
  description: string;

  @Column({
    type: 'enum',
    enum: ReportStatus,
    default: ReportStatus.PENDING,
  })
  status: ReportStatus;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

}

---


### FILE: src/reports/reports.service.ts ###
import {
  Injectable,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User, UserRole } from 'src/users/entities/user.entity';
import { Comment } from 'src/comments/entities/comment.entity';
import { Post } from 'src/posts/entities/post.entity';
import { CommentReport } from './entities/comment-report.entity';
import { PostReport } from './entities/post-report.entity';
import { UserReport } from './entities/user-report.entity';
import { ReportStatus } from './entities/base-report.entity';
import { CommunityModerator } from 'src/community-moderators/entities/community-moderator.entity';

const PLATFORM_COMPLAINT_REASONS = [
  'HARASSMENT',
  'VIOLENCE',
  'HATE_CONTENT',
  'MINOR_ABUSE_OR_SEXUALIZATION',
  'PII',
  'INVOLUNTARY_PORN',
  'PROHIBITED_SALES',
  'IMPERSONATION',
  'MANIPULATED_CONTENT',
  'COPYRIGHT',
  'TRADEMARK',
  'SELF_HARM',
  'SPAM',
  'CONTRIBUTOR_PROGRAM',
];

@Injectable()
export class ReportsService {
  constructor(
    @InjectRepository(CommentReport)
    private readonly commentReportRepository: Repository<CommentReport>,

    @InjectRepository(PostReport)
    private readonly postReportRepository: Repository<PostReport>,

    @InjectRepository(UserReport)
    private readonly userReportRepository: Repository<UserReport>,

    @InjectRepository(Comment)
    private readonly commentsRepository: Repository<Comment>,

    @InjectRepository(Post)
    private readonly postsRepository: Repository<Post>,

    @InjectRepository(User)
    private readonly usersRepository: Repository<User>,

    @InjectRepository(CommunityModerator)
    private readonly communityModeratorRepository: Repository<CommunityModerator>,
  ) { }

  async create(
    {
      entityType,
      entityId,
      reason,
      description,
    }: {
      entityType: 'comment' | 'post' | 'user';
      entityId: number;
      reason: string;
      description?: string;
    },
    reporter: User,
  ) {
    const isPlatformComplaint = PLATFORM_COMPLAINT_REASONS.includes(
      reason.toUpperCase(),
    );

    if (entityType === 'comment') {
      const entity = await this.commentsRepository.findOne({
        where: { id: entityId },
      });
      if (!entity) throw new NotFoundException('Comment not found');

      const existingReport = await this.commentReportRepository.findOne({
        where: { commentId: entityId, reporterId: reporter.id },
      });
      if (existingReport) {
        throw new ConflictException('You have already reported this comment');
      }

      const report = this.commentReportRepository.create({
        reporterId: reporter.id,
        commentId: entityId,
        reason,
        description,
        isPlatformComplaint,
      });
      return this.commentReportRepository.save(report);
    }

    if (entityType === 'post') {
      const entity = await this.postsRepository.findOne({
        where: { id: entityId },
      });
      if (!entity) throw new NotFoundException('Post not found');

      const existingReport = await this.postReportRepository.findOne({
        where: { postId: entityId, reporterId: reporter.id },
      });
      if (existingReport) {
        throw new ConflictException('You have already reported this post');
      }

      const report = this.postReportRepository.create({
        reporterId: reporter.id,
        postId: entityId,
        reason,
        description,
        isPlatformComplaint,
        communityId: (entity as Post).communityId,
      });
      return this.postReportRepository.save(report);
    }

    if (entityType === 'user') {
      const entity = await this.usersRepository.findOne({
        where: { id: entityId },
      });
      if (!entity) throw new NotFoundException('User not found');

      if (entity.id === reporter.id) {
        throw new ConflictException('You cannot report yourself');
      }

      const existingReport = await this.userReportRepository.findOne({
        where: { reportedUserId: entityId, reporterId: reporter.id },
      });
      if (existingReport) {
        throw new ConflictException('You have already reported this user');
      }

      const report = this.userReportRepository.create({
        reporterId: reporter.id,
        reportedUserId: entityId,
        reason,
        description,
        isPlatformComplaint,
      });
      return this.userReportRepository.save(report);
    }
  }

  async findAll({
    page = 1,
    limit = 10,
    status,
    entityType,
    reporterId,
    userId,
    communityId,
  }: {
    page?: number;
    limit?: number;
    status?: ReportStatus;
    entityType?: 'comment' | 'post' | 'user';
    reporterId?: number;
    userId: number;
    communityId?: number;
  }): Promise<{ data: (CommentReport | PostReport | UserReport)[]; count: number }> {
    const offset = (page - 1) * limit;


    const user = await this.usersRepository.findOne({
      where: { id: userId },
    });

    if (!user) {
      throw new NotFoundException(`User ${userId} not found`);
    }
    const isModerator =
      communityId &&
      (await this.communityModeratorRepository.findOne({
        where: { moderatorId: userId, communityId },
      }));

    const parameters: any[] = [];
    let paramIndex = 1;

    const buildSelectQuery = (
      tableName: string,
      type: string,
      specificIdColumn: string,
    ) => {
      const whereClauses: string[] = [];

      if (status) {
        whereClauses.push(`status = $${paramIndex++}`);
        parameters.push(status);
      }

      if (reporterId) {
        whereClauses.push(`"reporterId" = $${paramIndex++}`);
        parameters.push(reporterId);
      }

      if (user.role == UserRole.ADMIN) {
        whereClauses.push(`"isPlatformComplaint" = TRUE`);
      } else if (isModerator && communityId) {
        whereClauses.push(`"communityId" = $${paramIndex++}`);
        parameters.push(communityId);
      } else {
        whereClauses.push(`"isPlatformComplaint" = FALSE`);
      }

      if (entityType && entityType !== type) return null;

      const where =
        whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';

      return `
        SELECT
          id,
          "reporterId",
          reason,
          description,
          status,
          "createdAt",
          "updatedAt",
          "isPlatformComplaint",
          "communityId",
          ${specificIdColumn} AS "entitySpecificId",
          '${type}' AS "entityType"
        FROM ${tableName}
        ${where}
      `;
    };

    const unionQueries = [
      buildSelectQuery('comment_reports', 'comment', 'commentId'),
      buildSelectQuery('post_reports', 'post', 'postId'),
      buildSelectQuery('user_reports', 'user', 'reportedUserId'),
    ].filter(Boolean);

    if (!unionQueries.length) {
      return { data: [], count: 0 };
    }

    const unionAllQuery = unionQueries.join(' UNION ALL ');

    const countQuery = `SELECT COUNT(*) FROM (${unionAllQuery}) AS union_counts`;
    const countResult = await this.commentReportRepository.query(
      countQuery,
      parameters,
    );
    const count = parseInt(countResult[0].count, 10);

    const dataQuery = `
      ${unionAllQuery}
      ORDER BY "createdAt" DESC
      LIMIT $${paramIndex++} OFFSET $${paramIndex++}
    `;
    parameters.push(limit, offset);

    const raw = await this.commentReportRepository.query(
      dataQuery,
      parameters,
    );

    const data = raw.map(item => ({
      id: item.id,
      reporterId: item.reporterId,
      reason: item.reason,
      description: item.description,
      status: item.status,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
      isPlatformComplaint: item.isPlatformComplaint,
      communityId: item.communityId,
      entityType: item.entityType,
      commentId: item.entityType === 'comment' ? item.entitySpecificId : undefined,
      postId: item.entityType === 'post' ? item.entitySpecificId : undefined,
      reportedUserId:
        item.entityType === 'user' ? item.entitySpecificId : undefined,
    }));

    return { data, count };
  }

  async findOne(
    id: number,
    entityType: 'comment' | 'post' | 'user',
  ): Promise<CommentReport | PostReport | UserReport> {
    let repository: Repository<any>;

    if (entityType === 'comment') repository = this.commentReportRepository;
    else if (entityType === 'post') repository = this.postReportRepository;
    else repository = this.userReportRepository;

    const report = await repository.findOne({ where: { id } });
    if (!report) {
      throw new NotFoundException(`Report ${id} not found`);
    }
    return report;
  }

  async updateStatus(
    id: number,
    status: ReportStatus,
    entityType: 'comment' | 'post' | 'user',
  ) {
    const report = await this.findOne(id, entityType);

    if (report.status === status) {
      throw new ConflictException(
        `Report is already with status "${status}"`,
      );
    }

    report.status = status;

    if (entityType === 'comment') {
      return this.commentReportRepository.save(report);
    }
    if (entityType === 'post') {
      return this.postReportRepository.save(report);
    }
    return this.userReportRepository.save(report);
  }
}

---


### FILE: src/reports/dto/create-report.dto.ts ###
import { IsString, IsIn, IsNumber, IsOptional } from 'class-validator';

export class CreateReportDto {
  @IsString()
  reason: string;

  @IsIn(['comment', 'post', 'user'])
  entityType: 'comment' | 'post' | 'user';

  @IsNumber()
  entityId: number;

  @IsString()
  @IsOptional()
  description?: string;
}

---


### FILE: src/reports/dto/report-response.dto.ts ###
import { ReportStatus } from '../entities/base-report.entity';
import { CommentReport } from '../entities/comment-report.entity';
import { PostReport } from '../entities/post-report.entity';
import { UserReport } from '../entities/user-report.entity';

export class ReportResponseDto {
  id: number;
  reason: string;
  description: string | null;
  status: ReportStatus;
  reporterId: number;
  createdAt: Date;
  updatedAt: Date;
  entityType: 'comment' | 'post' | 'user';
  commentId?: number;
  postId?: number;
  reportedUserId?: number;

  static fromEntity(
    report: CommentReport | PostReport | UserReport,
  ): ReportResponseDto {
    const dto = new ReportResponseDto();
    dto.id = report.id;
    dto.reason = report.reason;
    dto.description = report.description;
    dto.status = report.status;
    dto.reporterId = report.reporterId;
    dto.createdAt = report.createdAt;
    dto.updatedAt = report.updatedAt;

    if (report instanceof CommentReport) {
      dto.entityType = 'comment';
      dto.commentId = report.commentId;
    } else if (report instanceof PostReport) {
      dto.entityType = 'post';
      dto.postId = report.postId;
    } else if (report instanceof UserReport) {
      dto.entityType = 'user';
      dto.reportedUserId = report.reportedUserId;
    }

    return dto;
  }
}

---


### FILE: src/reports/dto/report-query.dto.ts ###
import { IsOptional, IsIn, IsNumber, IsEnum } from 'class-validator';
import { ReportStatus } from '../entities/base-report.entity';
import { Transform } from 'class-transformer';
import { PaginationDto } from 'src/common/dto/pagination.dto';

export class ReportQueryDto extends PaginationDto {

  @IsOptional()
  @IsEnum(ReportStatus)
  status?: ReportStatus;

  @IsOptional()
  @IsIn(['comment', 'post', 'user'])
  entityType?: 'comment' | 'post' | 'user';

  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  @IsNumber()
  reporterId?: number;

  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  @IsNumber()
  communityId?: number;
}

---


### FILE: src/reports/dto/update-report.dto.ts ###
import { IsEnum, IsIn } from 'class-validator';
import { ReportStatus } from '../entities/base-report.entity';

export class UpdateReportDto {
  @IsEnum(ReportStatus)
  status: ReportStatus;

  @IsIn(['comment', 'post', 'user'])
  entityType: 'comment' | 'post' | 'user';
}

---


### FILE: src/decorators/user.decorator.ts ###
// src/decorators/current-user.decorator.ts
import {
  createParamDecorator,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { User } from 'src/users/entities/user.entity';

export const GetUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): User => {
    const request = ctx.switchToHttp().getRequest();

    // This comes from JwtStrategy.validate() ‚Üí req.user
    const user: User | undefined = request.user;

    if (!user) {
      throw new UnauthorizedException(
        'No authenticated user found. Token ff may be missing or invalid.',
      );
    }

    return user;
  },
);

---


### FILE: src/email-verification/email-verification.controller.ts ###
import {
  Controller,
  Post,
  Body,
  BadRequestException,
  Query,
  Get,
  Res,
} from '@nestjs/common';
import { EmailVerificationService } from './email-verification.service';
import { SendVerificationDto } from './dto/send-verification.dto';
import { UsersService } from '../users/users.service';
import { ResponseDto } from 'src/common/dto/response.dto';
import type { Response } from 'express';
import { ConfigService } from '@nestjs/config';

@Controller('email')
export class EmailVerificationController {
  constructor(
    private readonly service: EmailVerificationService,
    private readonly usersService: UsersService,
    private readonly configService: ConfigService,
  ) { }

  @Post('resend')
  async resend(@Body() dto: SendVerificationDto): Promise<ResponseDto<null>> {
    const user = await this.usersService.findByEmail(dto.email);
    if (user && !user.emailVerifiedAt) {
      await this.service.sendVerificationEmail(user);
    }
    return new ResponseDto(null, 'If the email exists and is not verified, a new verification link has been sent.');
  }

  @Get('verify')
  async verify(
    @Query('token') token: string,
    @Res() res: Response,
  ): Promise<void> {
    const frontendUrl = this.configService.getOrThrow<string>(
      'FRONTEND_URL');
    const redirectUrl = new URL(`${frontendUrl}/verify-email`);

    if (!token) {
      redirectUrl.searchParams.set('error', 'Token is required');
      return res.redirect(redirectUrl.toString());
    }

    try {
      const userId = await this.service.verifyToken(token);
      await this.usersService.markEmailAsVerified(userId);

      redirectUrl.searchParams.set('success', '1');
      redirectUrl.searchParams.set( 'message',
        'Email verified successfully',
      );
    } catch (err) {
      const message =
        err instanceof BadRequestException
          ? err.message
          : 'Invalid or expired verification token';
      redirectUrl.searchParams.set('error', '1');
      redirectUrl.searchParams.set('message', message);
    }

    return res.redirect(redirectUrl.toString());
  }

}

---


### FILE: src/email-verification/entities/email-verification-token.entity.ts ###
// src/email-verification/entities/email-verification-token.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
} from 'typeorm';

@Entity('email_verification_tokens')
export class EmailVerificationToken {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  token: string;

  @Column()
  userId: number;

  @Column()
  expiresAt: Date;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: src/email-verification/email-verification.service.ts ###
import {
  Injectable,
  BadRequestException,
  InternalServerErrorException,
  Inject,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { randomUUID } from 'crypto';
import { EmailVerificationToken } from './entities/email-verification-token.entity';
import { User } from 'src/users/entities/user.entity';
import type { IMailService } from 'src/mail/interfaces/mail-service.interface';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class EmailVerificationService {
  constructor(
    @InjectRepository(EmailVerificationToken)
    private readonly tokenRepo: Repository<EmailVerificationToken>,
    private readonly configService: ConfigService,
    @Inject('IMailService')
    private readonly mailService: IMailService,
  ) {
    this.EXPIRATION_MS = this.configService.get<number>(
      'EMAIL_VERIFICATION_TOKEN_EXPIRATION',
      15 * 60 * 1000,
    );
  }
  EXPIRATION_MS: number;

  private async deleteExistingTokens(userId: number): Promise<void> {
    await this.tokenRepo.delete({ userId });
  }

  async generateToken(userId: number): Promise<string> {
    await this.deleteExistingTokens(userId);

    const token = randomUUID();
    const record = this.tokenRepo.create({
      token,
      userId,
      expiresAt: new Date(Date.now() + this.EXPIRATION_MS),
    });

    await this.tokenRepo.save(record);
    return token;
  }

  private generateVerificationLink(token: string): string {
    // You can move APP_DOMAIN to ConfigService if needed
    const domain = this.configService.get<string>('APP_DOMAIN'); // e.g. https://myapp.com
    const path = '/api/email/verify';
    return `${domain}${path}?token=${token}`;
  }

  async sendVerificationEmail(user: User): Promise<void> {
    const token = await this.generateToken(user.id);
    const verifyUrl = this.generateVerificationLink(token);

    try {
      await this.mailService.sendEmail(
        user.email,
        'Verify Your Email',
        'verify-email', // templateName (templates/verify-email.hbs)
        { name: user.name, verifyUrl }, // context for the template
      );
    } catch (err) {
      console.error('Error sending verification email:', err);
      throw new InternalServerErrorException(
        'Failed to send verification email',
      );
    }
  }

  async verifyToken(token: string): Promise<number> {
    const record = await this.tokenRepo.findOne({ where: { token } });

    if (!record) throw new BadRequestException('Invalid token');
    if (record.expiresAt < new Date()) {
      await this.tokenRepo.delete({ token });
      throw new BadRequestException('Token expired');
    }

    await this.tokenRepo.delete({ token });
    return record.userId;
  }
}

---


### FILE: src/email-verification/dto/verify-email.dto.ts ###
export class VerifyEmailDto {
  token: string;
}

---


### FILE: src/email-verification/dto/send-verification.dto.ts ###
import { IsEmail, IsNotEmpty } from 'class-validator';

export class SendVerificationDto {
  @IsNotEmpty()
  @IsEmail()
  email: string; // ‚úÖ Use email, a public identifier
}

---


### FILE: src/email-verification/email-verification.module.ts ###
// src/email-verification/email-verification.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { EmailVerificationService } from './email-verification.service';
import { EmailVerificationController } from './email-verification.controller';
import { EmailVerificationToken } from './entities/email-verification-token.entity';
import { UsersModule } from 'src/users/users.module';
import { MailModule } from 'src/mail/mail.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([EmailVerificationToken]),
    UsersModule,
    MailModule,
  ],
  controllers: [EmailVerificationController],
  providers: [EmailVerificationService],
  exports: [EmailVerificationService],
})
export class EmailVerificationModule {}

---


### FILE: src/casl/casl.types.ts ###
export enum Action {
  Manage = 'manage',
  Create = 'create',
  Read = 'read',
  Update = 'update',
  Delete = 'delete',
}

---


### FILE: src/casl/casl.service.ts ###
import { Injectable, ForbiddenException } from '@nestjs/common';
// 1. Import 'Subjects' from your CASL ability factory
import {
  CaslAbilityFactory,
  AppAbility,
  Subjects,
} from './casl-ability.factory';
import { Action } from './casl.types';

@Injectable()
export class CaslService {
  constructor(private readonly caslAbilityFactory: CaslAbilityFactory) {}

  /**
   * Private helper method to create the ability object.
   */
  private getAbility(user: any): AppAbility {
    return this.caslAbilityFactory.createForUser(user);
  }

  /**
   * Checks if user can perform an action on a specific resource.
   * Throws ForbiddenException if not allowed.
   */
  // 2. Add 'extends Subjects' constraint to generic type T
  enforce<T extends Subjects>(user: any, action: Action, resource: T): void {
    const ability = this.getAbility(user);

    if (!ability.can(action, resource)) {
      throw new ForbiddenException(
        'You are not allowed to perform this action',
      );
    }
  }

  /**
   * Returns true/false without throwing.
   */
  // 3. Add 'extends Subjects' constraint to generic type T
  can<T extends Subjects>(user: any, action: Action, resource: T): boolean {
    const ability = this.getAbility(user);

    return ability.can(action, resource);
  }
}

---


### FILE: src/casl/policies.guard.ts ###
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { CaslAbilityFactory, AppAbility } from './casl-ability.factory';
import { CHECK_POLICIES_KEY } from './check-policies.decorator';
import { PolicyHandler } from './policy-handler.interface';

@Injectable()
export class PoliciesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private caslAbilityFactory: CaslAbilityFactory,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const policyHandlers =
      this.reflector.get<PolicyHandler[]>(
        CHECK_POLICIES_KEY,
        context.getHandler(),
      ) || [];

    const { user } = context.switchToHttp().getRequest();

    const ability = this.caslAbilityFactory.createForUser(user);

    return policyHandlers.every((handler) =>
      this.execPolicyHandler(handler, ability),
    );
  }

  private execPolicyHandler(handler: PolicyHandler, ability: AppAbility) {
    if (typeof handler === 'function') {
      return handler(ability);
    }
    return handler.handle(ability);
  }
}

---


### FILE: src/casl/casl-ability.factory.ts ###
import {
  AbilityBuilder,
  createMongoAbility,
  MongoAbility,
  InferSubjects,
  ExtractSubjectType,
} from '@casl/ability';
import { Injectable } from '@nestjs/common';
import { User } from '../users/entities/user.entity';
import { Post } from '../posts/entities/post.entity';
import { Comment } from '../comments/entities/comment.entity';
import { PostReaction } from '../reactions/entities/post-reaction.entity';
import { CommentReaction } from '../reactions/entities/comment-reaction.entity';
import { Action } from './casl.types';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembershipStatus } from 'src/community-memberships/types';
import { CommunityType } from 'src/communities/types';

export type Subjects =
  | InferSubjects<
    | typeof Post
    | typeof Comment
    | typeof PostReaction
    | typeof CommentReaction
    | typeof User
    | typeof Community
  >
  | 'all';

export type AppAbility = MongoAbility<[Action, Subjects]>;

@Injectable()
export class CaslAbilityFactory {
  createForUser(user: User) {
    const { can, cannot, build } = new AbilityBuilder<AppAbility>(
      createMongoAbility,
    );

    // ---- Post Permissions ----
    can(Action.Read, Post); // any post
    can(Action.Create, Post);
    can(Action.Update, Post, { authorId: user.id }); // only own
    can(Action.Delete, Post, { authorId: user.id });

    // ---- Comment Permissions ----
    can(Action.Read, Comment);
    can(Action.Create, Comment);
    can(Action.Update, Comment, { authorId: user.id });
    can(Action.Delete, Comment, { authorId: user.id });

    // ---- Reaction Permissions ----
    // PostReaction
    can(Action.Create, PostReaction);
    can(Action.Delete, PostReaction, { userId: user.id });
    can(Action.Update, PostReaction, { userId: user.id });


    // CommentReaction
    can(Action.Create, CommentReaction);
    can(Action.Delete, CommentReaction, { userId: user.id });
    can(Action.Update, CommentReaction, { userId: user.id });

    can(Action.Delete, Community, { ownerId: user.id });
    can(Action.Update, Community, { ownerId: user.id });



    return build({
      detectSubjectType: (item) =>
        item.constructor as ExtractSubjectType<Subjects>,
    });
  }
}

---


### FILE: src/casl/casl.module.ts ###
import { Module } from '@nestjs/common';
import { CaslAbilityFactory } from './casl-ability.factory';
import { CaslService } from './casl.service';

@Module({
  providers: [CaslAbilityFactory, CaslService],
  exports: [CaslAbilityFactory, CaslService],
})
export class CaslModule {}

---


### FILE: src/casl/policy-handler.interface.ts ###
import { AppAbility } from '../casl/casl-ability.factory';

interface IPolicyHandler {
  handle(ability: AppAbility): boolean;
}

type PolicyHandlerCallback = (ability: AppAbility) => boolean;

export type PolicyHandler = IPolicyHandler | PolicyHandlerCallback;

---


### FILE: src/casl/check-policies.decorator.ts ###
import { SetMetadata } from '@nestjs/common';
import { PolicyHandler } from './policy-handler.interface';

export const CHECK_POLICIES_KEY = 'check_policy';
export const CheckPolicies = (...handlers: PolicyHandler[]) =>
  SetMetadata(CHECK_POLICIES_KEY, handlers);

---


### FILE: src/casl/index.ts ###
export * from './casl.types';
export * from './casl-ability.factory';
export * from './policy-handler.interface';
export * from './check-policies.decorator';
export * from './policies.guard';
export * from './casl.module';

---


### FILE: src/posts/pipes/post.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { PostsService } from '../posts.service';
import { Post } from '../entities/post.entity';

@Injectable()
export class PostPipe implements PipeTransform<string, Promise<Post>> {
  constructor(private readonly postsService: PostsService) {}

  async transform(value: string): Promise<Post> {
    const post = await this.postsService.findOne(+value);

    if (!post) {
      throw new NotFoundException('Post not found');
    }

    return post;
  }
}

---


### FILE: src/posts/posts.module.ts ###
import { Module } from '@nestjs/common';
import { PostsService } from './posts.service';
import { PostsController } from './posts.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Post } from './entities/post.entity';
import { CaslModule } from 'src/casl/casl.module';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-membership.entity';

@Module({
  imports: [TypeOrmModule.forFeature(
    [Post, Community, CommunityMembership]),
    CaslModule,

  ],
  providers: [PostsService],
  controllers: [PostsController],
  exports: [PostsService],
})
export class PostsModule { }

---


### FILE: src/posts/posts.service.ts ###
import { BadRequestException, ForbiddenException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Brackets, Repository } from 'typeorm';
import { Post } from './entities/post.entity';
import { PostSort } from './dto/post-query.dto';
import { CommunityType } from 'src/communities/types';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-membership.entity';
import { CommunityMembershipStatus } from 'src/community-memberships/types';

@Injectable()
export class PostsService {
  constructor(
    @InjectRepository(Post)
    private postsRepository: Repository<Post>,
    @InjectRepository(Community)
    private readonly communityRepository: Repository<Community>,

    @InjectRepository(CommunityMembership)
    private readonly membershipRepository: Repository<CommunityMembership>,) { }

  async findAll(
    options: {
      page?: number;
      limit?: number;
      search?: string;
      authorId?: number;
      sort?: PostSort;
      startDate?: Date;
      endDate?: Date;
      currentUserId?: number;
      communityId?: number;
    },
  ): Promise<{
    data: Post[];
    count: number;
  }> {
    const {
      page = 1,
      limit = 10,
      search,
      authorId,
      sort,
      startDate,
      endDate,
      currentUserId,
      communityId,
    } = options;

    const query = this.postsRepository
      .createQueryBuilder('post')
      .leftJoinAndSelect('post.author', 'author')
      .leftJoinAndSelect('post.community', 'community')
      .where('post.isApproved = :approved', { approved: true });

    if (currentUserId) {
      query.leftJoinAndMapOne(
        'post.userReaction',
        'post.reactions',
        'userReaction',
        'userReaction.userId = :currentUserId',
        { currentUserId },
      );
    }

    if (search) {
      query.where(
        new Brackets((qb) => {
          qb.where('post.title LIKE :search', {
            search: `%${search}%`,
          }).orWhere('post.content LIKE :search', { search: `%${search}%` });
        }),
      );
    }

    if (authorId) {
      query.andWhere('post.author.id = :authorId', { authorId });
    }

    if (communityId) {
      query.andWhere('post.community.id = :communityId', { communityId });
    }

    if (startDate) {
      query.andWhere('post.createdAt >= :startDate', { startDate });
    }


    if (endDate) {
      query.andWhere('post.createdAt <= :endDate', { endDate });
    }

    if (sort === PostSort.POPULAR) {
      query
        .leftJoin('post.reactions', 'allReactions') // Join all reactions for the post
        .addSelect('COUNT(allReactions.id)', 'reactionCount')
        .groupBy('post.id')
        .orderBy('reactionCount', 'DESC');
    } else if (sort === PostSort.NEWEST) {
      query.orderBy('post.createdAt', 'DESC');
    } else if (sort === PostSort.OLDEST) {
      query.orderBy('post.createdAt', 'ASC');
    } else {
      query.orderBy('post.createdAt', 'DESC');
    }

    // Community visibility rules
    if (!currentUserId) {
      // Not logged in ‚Üí hide PRIVATE communities and show only approved posts
      query.andWhere('community.communityType != :privateType', {
        privateType: 'private',
      });
      query.andWhere('post.isApproved = :isApproved', { isApproved: true });
    } else {
      query.andWhere(
        new Brackets((qb) => {
          qb.where('community.communityType != :privateType', {
            privateType: 'private',
          }).orWhere(
            `EXISTS (
          SELECT 1
          FROM community_memberships cs
          WHERE cs.communityId = community.id
          AND cs.userId = :currentUserId
          AND cs.status = 'approved'
        )`,
          );
        }),
      ).setParameter('privateType', 'private')
        .setParameter('currentUserId', currentUserId);
    }

    const [data, count] = await query
      .take(limit)
      .skip((page - 1) * limit)
      .getManyAndCount();



    return { data: data, count };
  }


  async findOne(id: number, currentUserId?: number): Promise<Post | null> {
    // Start building query
    const query = this.postsRepository.createQueryBuilder('post')
      .leftJoinAndSelect('post.author', 'author')
      .leftJoinAndSelect('post.comments', 'comments')
      .leftJoinAndSelect('post.community', 'community');

    // Optionally join user's reaction if currentUserId is provided
    if (currentUserId) {
      query.leftJoinAndMapOne(
        'post.userReaction',
        'post.reactions',
        'userReaction',
        'userReaction.userId = :currentUserId',
        { currentUserId },
      );
    }

    // Filter by post ID
    query.where('post.id = :id', { id });

    // TODO: Implement actual admin check based on user roles
    const isAdmin = false; // Placeholder for admin check

    if (!currentUserId || !isAdmin) {
      query.andWhere('post.isApproved = :isApproved', { isApproved: true });
    }

    // Execute query
    const post = await query.getOne();
    return post;
  }

  async create(
    { title, content, authorId, communityId, isApproved }: { title: string; content: string; authorId: number; communityId: number; isApproved?: boolean },
  ): Promise<Post> {
    const community = await this.communityRepository.findOneBy({ id: communityId });
    if (!community) {
      throw new NotFoundException(`Community with ID ${communityId} not found`);
    }
    // Check if user can contribute based on community rules
    await this.assertUserCanPostToCommunity(authorId, community);

    const post = this.postsRepository.create({
      title,
      content,
      authorId,
      community,
      isApproved: isApproved !== undefined ? isApproved : false, // Set isApproved based on provided value or default to false
    });
    return this.postsRepository.save(post);
  }
  async update(
    postUpdateData: {
      id: number;
      title?: string;
      content?: string;
    },
  ): Promise<Post> {
    const post = await this.postsRepository.findOneBy({ id: postUpdateData.id });
    if (!post) {
      throw new NotFoundException('Post not found');
    }

    if (postUpdateData.title !== undefined) post.title = postUpdateData.title;
    if (postUpdateData.content !== undefined) post.content = postUpdateData.content;

    return this.postsRepository.save(post);
  }

  async remove(id: number): Promise<boolean> {
    const post = await this.postsRepository.findOneBy({ id });
    if (!post) {
      throw new NotFoundException('Post not found'); // TODO: Use a more specific NestJS exception
    }
    const res = await this.postsRepository.remove(post);
    return !!res;
  }


  async updatePostApprovalStatus(postId: number, isApproved: boolean): Promise<Post> {
    const post = await this.postsRepository.findOneBy({ id: postId });
    if (!post) {
      throw new NotFoundException('Post not found');
    }
    post.isApproved = isApproved;
    post.approvedAt = isApproved ? new Date() : null;
    return this.postsRepository.save(post);
  }

  async updateCommentsLockedStatus(postId: number, commentsLocked: boolean): Promise<Post> {
    const post = await this.postsRepository.findOneBy({ id: postId });
    if (!post) {
      throw new NotFoundException('Post not found');
    }
    post.commentsLocked = commentsLocked;
    return this.postsRepository.save(post);
  }


  async incrementCommentsCount(postId: number): Promise<void> {
    await this.postsRepository.increment({ id: postId }, 'commentsCount', 1);
  }

  async decrementCommentsCount(postId: number): Promise<void> {
    await this.postsRepository.decrement({ id: postId }, 'commentsCount', 1);
  }

  async incrementLikesCount(postId: number): Promise<void> {
    await this.postsRepository.increment({ id: postId }, 'likesCount', 1);
  }

  async decrementLikesCount(postId: number): Promise<void> {
    await this.postsRepository.decrement({ id: postId }, 'likesCount', 1);
  }

  async incrementDislikesCount(postId: number): Promise<void> {
    await this.postsRepository.increment({ id: postId }, 'dislikesCount', 1);
  }

  async decrementDislikesCount(postId: number): Promise<void> {
    await this.postsRepository.decrement({ id: postId }, 'dislikesCount', 1);
  }

  async incrementViews(postId: number): Promise<void> {
    await this.postsRepository.increment({ id: postId }, 'views', 1);
  }

  async assertUserCanPostToCommunity(
    userId: number,
    community: Community,
  ): Promise<void> {
    switch (community.communityType) {
      case CommunityType.PUBLIC:
        return;

      case CommunityType.RESTRICTED:
      case CommunityType.PRIVATE:
        const isActive = await this.membershipRepository.exist({
          where: {
            userId,
            communityId: community.id,
            status: CommunityMembershipStatus.ACTIVE,
          },
        });

        if (!isActive) {
          throw new ForbiddenException('You cannot post in this community');
        }
        return;

      default:
        throw new ForbiddenException('Posting not allowed');
    }
  }


}

---


### FILE: src/posts/entities/post.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToMany,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
} from 'typeorm';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { Community } from '../../communities/entities/community.entity';
import { ReactionType } from 'src/reactions/reactions.types';
import { PostReport } from '../../reports/entities/post-report.entity';

@Entity('posts')
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @Column()
  content: string;

  @ManyToOne(() => User, (user) => user.posts, {
    nullable: false,
    onDelete: 'CASCADE',
  })
  author: User;
  // FK explicite
  @Column()
  authorId: number;

  @ManyToOne(() => Community, (community) => community.posts, {
    nullable: false,
    onDelete: 'RESTRICT',
  })
  community: Community;

  @Column({ nullable: false })
  communityId: number;

  @Column({ default: 0 })
  commentsCount: number;

  @OneToMany(() => Comment, (comment) => comment.post)
  comments: Comment[];

  @Column({ default: 0 })
  views: number;

  @OneToMany(() => PostReaction, (reaction) => reaction.post)
  reactions: PostReaction[];

  @Column({ default: 0 })
  likesCount: number;

  @Column({ default: 0 })
  dislikesCount: number;

  @Column({ default: false })
  commentsLocked: boolean;

  @Column({ default: false })
  isApproved: boolean;

  @Column({ type: 'datetime', nullable: true })
  approvedAt: Date | null;

  @OneToMany(() => PostReport, (postReport) => postReport.post)
  reports: PostReport[];

  userReaction?: { id: number; type: ReactionType };
  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @DeleteDateColumn()
  deletedAt: Date;
}

---


### FILE: src/posts/posts.controller.ts ###
import {
  Controller,
  Get,
  Post as HttpPost,
  Body,
  Param,
  Patch,
  Delete,
  UseGuards,
  Query,
  Req,
  NotFoundException,
} from '@nestjs/common';
import { PostsService } from './posts.service';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';
import { UpdatePostApprovalDto } from './dto/update-post-approval.dto'; // Import the new DTO
import { UpdateCommentsLockedDto } from './dto/update-comments-locked.dto';
import { Post as PostEntity } from './entities/post.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { PostPipe } from 'src/posts/pipes/post.pipe';
import { Action } from 'src/casl/casl.types';
import { CaslService } from 'src/casl/casl.service';
import { PostResponseDto } from './dto/post-response.dto';
import { PostQueryDto } from './dto/post-query.dto';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { OptionalJwtAuthGuard } from 'src/auth/guards/optional-jwt-auth.guard';
import type { Request } from 'express';
import { CommunityType } from 'src/communities/types';
import { Membership } from 'rxjs';
import { CommunityMembershipStatus } from 'src/community-memberships/types';

@Controller('posts')
export class PostsController {
  constructor(
    private readonly postsService: PostsService,
    private readonly caslService: CaslService,
  ) { }

  @Get()
  @UseGuards(JwtAuthGuard)
  async findAll(@Query() query: PostQueryDto,
    @Req() req: any
  ): Promise<PaginatedResponseDto<PostResponseDto>> {

    const { data, count } = await this.postsService.findAll({
      page: query.page,
      limit: query.limit,
      search: query.search,
      authorId: query.authorId,
      sort: query.sort,
      startDate: query.startDate,
      endDate: query.endDate,
      currentUserId: req.user?.id ?? undefined,
      communityId: query.communityId,
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(PostResponseDto.fromEntity), paginationMeta);
  }

  @Get(':id')
  @UseGuards(OptionalJwtAuthGuard)
  async findOne(
    @Param('id') id: string,
    @GetUser() user?: User, // Get user if authenticated
  ): Promise<ResponseDto<PostResponseDto>> {
    const postId = +id;
    const post = await this.postsService.findOne(postId, user?.id); // Pass currentUserId

    if (!post) {
      throw new NotFoundException(`Post not found`);
    }

    this.postsService.incrementViews(postId);
    return new ResponseDto(PostResponseDto.fromEntity(post));
  }

  @HttpPost()
  @UseGuards(JwtAuthGuard)
  async create(
    @Body() dto: CreatePostDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<PostResponseDto>> {
    this.caslService.enforce(user, Action.Create, PostEntity);
    const post = await this.postsService.create({
      title: dto.title,
      content: dto.content,
      authorId: user.id,
      communityId: dto.communityId,
    });
    return new ResponseDto(PostResponseDto.fromEntity(post));
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', PostPipe) post: PostEntity,
    @Body() dto: UpdatePostDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<PostResponseDto>> {
    this.caslService.enforce(user, Action.Update, post);
    const updatedPost = await this.postsService.update({
      id: post.id,
      title: dto.title,
      content: dto.content,
    });
    return new ResponseDto(PostResponseDto.fromEntity(updatedPost));
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  async remove(@Param('id', PostPipe) post: PostEntity, @GetUser() user: User): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, post);
    const success = await this.postsService.remove(post.id);
    return new ResponseDto(success);
  }

  @Patch(':id/approve')
  @UseGuards(JwtAuthGuard)
  // TODO: Add admin role guard here
  async updatePostApprovalStatus(
    @Param('id', PostPipe) post: PostEntity,
    @Body() dto: UpdatePostApprovalDto, // Use the new DTO
    @GetUser() user: User, // For potential admin check
  ): Promise<ResponseDto<PostResponseDto>> {
    // Implement admin role check using caslService.enforce here
    // For now, let's assume `user` is an admin or has the right permissions
    const updatedPost = await this.postsService.updatePostApprovalStatus(post.id, dto.isApproved);
    return new ResponseDto(PostResponseDto.fromEntity(updatedPost));
  }

  @Patch(':id/comments-locked')
  @UseGuards(JwtAuthGuard)
  // TODO: Add proper authorization using caslService.enforce
  async updateCommentsLockedStatus(
    @Param('id', PostPipe) post: PostEntity,
    @Body() dto: UpdateCommentsLockedDto,
    @GetUser() user: User, // For authorization check
  ): Promise<ResponseDto<PostResponseDto>> {
    this.caslService.enforce(user, Action.Update, post); // Enforce update on commentsLocked field
    const updatedPost = await this.postsService.updateCommentsLockedStatus(post.id, dto.commentsLocked);
    return new ResponseDto(PostResponseDto.fromEntity(updatedPost));
  }


  }

---


### FILE: src/posts/dto/update-post.dto.ts ###
// src/posts/dto/update-post.dto.ts

import { PartialType } from '@nestjs/mapped-types'; // <-- 1. Make sure this is imported
import { CreatePostDto } from './create-post.dto'; // <-- 2. Make sure you import CreatePostDto

// 3. Extend PartialType of your base DTO
export class UpdatePostDto extends PartialType(CreatePostDto) {
  // If you need to add custom validation or properties, they go here.
  // Otherwise, leave the body empty.
}

---


### FILE: src/posts/dto/update-comments-locked.dto.ts ###
import { IsBoolean } from 'class-validator';

export class UpdateCommentsLockedDto {
  @IsBoolean()
  commentsLocked: boolean;
}

---


### FILE: src/posts/dto/post-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsString, IsInt, IsEnum, IsISO8601 } from 'class-validator';
import { Type } from 'class-transformer';

export enum PostSort {
  NEWEST = 'newest',
  POPULAR = 'popular',
  OLDEST = 'oldest',
}

export class PostQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  search?: string; // Filter by title or content

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  authorId?: number;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  communityId?: number;

  @IsOptional()
  @IsEnum(PostSort)
  sort?: PostSort;

  @IsOptional()
  @IsISO8601()
  @Type(() => Date)
  startDate?: Date;

  @IsOptional()
  @IsISO8601()
  @Type(() => Date)
  endDate?: Date;
}

---


### FILE: src/posts/dto/post-response.dto.ts ###
// src/posts/dto/post-response.dto.ts
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { Post } from '../entities/post.entity';
import { ReactionResponseDto } from 'src/reactions/dto/reaction-response.dto';
import { CommunityResponseDto } from 'src/communities/dto/community-response.dto';

@Exclude()
export class PostResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly title: string;
  @Expose() readonly content: string;
  @Expose() readonly views: number;
  @Expose() readonly createdAt: Date;
  @Expose() readonly updatedAt: Date;

  @Expose() @Type(() => UserResponseDto) readonly author: UserResponseDto;
  
  @Expose() @Type(() => CommunityResponseDto) readonly community?: CommunityResponseDto;

  @Expose() readonly commentsCount: number;
  @Expose() readonly likesCount: number;
  @Expose() readonly dislikesCount: number;
  
  @Expose() @Type(() => ReactionResponseDto) 
  readonly userReaction?: ReactionResponseDto | null;

  static fromEntity(entity: Post & { userReaction?: any }): PostResponseDto {
    return plainToInstance(
      PostResponseDto,
      {
        ...entity,
        author: entity.author ? UserResponseDto.fromEntity(entity.author) : null,
        community: entity.community ? CommunityResponseDto.fromEntity(entity.community) : null,
        commentsCount: entity.commentsCount,
        userReaction: entity.userReaction ? ReactionResponseDto.fromEntity(entity.userReaction) : null,
      },
      { excludeExtraneousValues: true },
    );
  }
}
---


### FILE: src/posts/dto/update-post-approval.dto.ts ###
import { IsBoolean, IsNotEmpty } from 'class-validator';

export class UpdatePostApprovalDto {
  @IsBoolean()
  @IsNotEmpty()
  isApproved: boolean;
}

---


### FILE: src/posts/dto/create-post.dto.ts ###
import { IsString, IsNotEmpty, IsInt, IsBoolean, IsOptional } from 'class-validator';
import { Type } from 'class-transformer';

export class CreatePostDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  @IsNotEmpty()
  content: string;

  @IsInt()
  @IsNotEmpty()
  @Type(() => Number)
  communityId: number;

  @IsBoolean()
  @IsOptional()
  isApproved?: boolean;
}

---


### FILE: src/auth/auth.service.ts ###
// src/auth/auth.service.ts
import {
  BadRequestException,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService } from '../users/users.service';
import * as bcrypt from 'bcrypt';
import { User } from 'src/users/entities/user.entity';

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UsersService,
    private readonly jwt: JwtService,
    private readonly config: ConfigService,
  ) {}

  // -------------------------------------------------------------------------
  // Register (local account)
  // -------------------------------------------------------------------------
  async register(name: string, email: string, password: string): Promise<User> {
    return this.userService.createUser(
     { name,
      email,
      password, }
    );
  }

  // -------------------------------------------------------------------------
  // Validate credentials (used by LocalStrategy)
  // -------------------------------------------------------------------------
 // In auth.service.ts, update the validateUser method:
async validateUser(email: string, password: string): Promise<User> {
  const user = await this.userService.findByEmail(email);
  
  // If user doesn't exist or has no password (social-only account)
  if (!user || !user.password) {
    throw new UnauthorizedException('Invalid credentials');
  }
  
  const isMatch = await bcrypt.compare(password, user.password);
  
  if (!isMatch) {
    throw new UnauthorizedException('Invalid credentials');
  }
  
  return user;
}

  // -------------------------------------------------------------------------
  // Sign in (called after successful local or refresh validation)
  // -------------------------------------------------------------------------
  async signIn(user: User) {
    return this.generateTokens(user);
  }

  // -------------------------------------------------------------------------
  // Google OAuth login / link
  // -------------------------------------------------------------------------
  async googleLogin(oauthUser: {
    email: string;
    fullName?: string;
    id: string;
    picture?: string;
  }): Promise<User> {
    if (!oauthUser?.email) {
      throw new BadRequestException('Google account has no accessible email');
    }

    let user: User | null = null;

    try {
      user = await this.userService.findByEmail(oauthUser.email);
    } catch {
      user = null; // not found
    }

    if (!user) {
      // First time ‚Üí create new user
     return this.userService.createUser({
  name: oauthUser.fullName ?? oauthUser.email.split('@')[0],
  email: oauthUser.email,
  password: undefined, // no password
  provider: 'google',
  providerId: oauthUser.id,
  emailVerifiedAt: new Date(), // email already verified by Google
});

    }

    // Existing user ‚Üí make sure provider data is up-to-date
    return this.userService.updateUser({user ,
      name: oauthUser.fullName ?? user.name,
      provider: 'google',
      providerId: oauthUser.id,
      emailVerifiedAt: user.emailVerifiedAt ?? new Date(),
    });
  }

  // -------------------------------------------------------------------------
  // Refresh token flow
  // -------------------------------------------------------------------------
  async renewTokens(refreshToken: string) {
    const payload = this.jwt.verify(refreshToken, {
      secret: this.config.get<string>('JWT_REFRESH_SECRET'), // use ConfigService
    });
    const user = await this.userService.findOneById(payload.sub);
    return this.generateTokens(user);
  }

  // -------------------------------------------------------------------------
  // Token generation (shared)
  // -------------------------------------------------------------------------
  private generateTokens(user: User) {
    const payload = { sub: user.id, email: user.email };

    const accessToken = this.jwt.sign(payload, {
      secret: this.config.get<string>('JWT_ACCESS_SECRET'),
      expiresIn: this.config.getOrThrow('JWT_ACCESS_EXPIRES_IN'),
    });

    const refreshToken = this.jwt.sign(payload, {
      secret: this.config.get<string>('JWT_REFRESH_SECRET'),
      expiresIn: this.config.getOrThrow('JWT_REFRESH_EXPIRES_IN'),
    });

    return { accessToken, refreshToken };
  }
}
---


### FILE: src/auth/dtos/register.dto.ts ###
import { IsEmail, IsString, MinLength } from 'class-validator';

export class RegisterDto {
  
  @IsEmail()
  email: string;

  @IsString()
   name: string;

  @IsString()
  @MinLength(6)
  password: string;
}

---


### FILE: src/auth/dtos/login.dto.ts ###
import { IsEmail, IsString, MinLength } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(6)
  password: string;
}

---


### FILE: src/auth/dtos/refresh.dto.ts ###
import { IsString, IsNotEmpty } from 'class-validator';

export class RefreshDto {
  @IsString()
  @IsNotEmpty()
  refreshToken: string;
}

---


### FILE: src/auth/auth.controller.ts ###
import {
  Controller,
  Post,
  Body,
  UseGuards,
  Get,
  Req,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto } from './dtos/register.dto';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { JwtRefreshGuard } from './guards/jwt-refresh.guard';
import { EmailVerificationService } from 'src/email-verification/email-verification.service';
import { AuthGuard } from '@nestjs/passport';
import { UserResponseDto } from 'src/users/dtos/user-response.dto';
import { User } from 'src/users/entities/user.entity';
import { RefreshDto } from './dtos/refresh.dto';
import { ResponseDto } from 'src/common/dto/response.dto';

@Controller('auth')
export class AuthController {
  constructor(
    private readonly authService: AuthService,
    private readonly emailVerificationService: EmailVerificationService,
  ) {}

  @Post('register')
  async register(@Body() dto: RegisterDto): Promise<ResponseDto<UserResponseDto>> {
    const user = await this.authService.register(
      dto.name,
      dto.email,
      dto.password,
    );
    await this.emailVerificationService.sendVerificationEmail(user);
    return new ResponseDto(UserResponseDto.fromEntity(user), 'Registration successful. Please verify your email.');
  }

  @UseGuards(LocalAuthGuard)
  @Post('login')
  async login(@Req() req: { user: User }): Promise<ResponseDto<{ user: UserResponseDto; accessToken: string; refreshToken: string }>> {
    if (!req.user.emailVerifiedAt) {
      await this.emailVerificationService.sendVerificationEmail(req.user);

      throw new UnauthorizedException(
        'Email not verified. Verification email sent.',
      );
    }
    const tokens = await this.authService.signIn(req.user);
    return new ResponseDto({
      user: UserResponseDto.fromEntity(req.user),
      ...tokens,
    });
  }

  @UseGuards(JwtRefreshGuard)
  @Post('refresh')
  async refresh(@Body() dto: RefreshDto, @Req() req): Promise<ResponseDto<{ user: UserResponseDto; accessToken: string; refreshToken: string }>> {
    const tokens = await this.authService.renewTokens(dto.refreshToken);
    return new ResponseDto({
      user: UserResponseDto.fromEntity(req.user),
      ...tokens,
    });
  }

  // Step 1: Redirect to Google OAuth
  @Get('google')
  @UseGuards(AuthGuard('google'))
  async googleAuth() {
    // Passport automatically redirects to Google
  }

  // Step 2: Google callback ‚Üí GoogleStrategy.validate() ‚Üí req.user
  @Get('google/callback')
  @UseGuards(AuthGuard('google'))
  async googleCallback(@Req() req: { user: any }): Promise<ResponseDto<{ user: UserResponseDto; accessToken: string; refreshToken: string }>> {
    const user = await this.authService.googleLogin(req.user);
    const tokens = await this.authService.signIn(user);
    return new ResponseDto({
      user: UserResponseDto.fromEntity(user),
      ...tokens,
    });
  }
}

---


### FILE: src/auth/auth.module.ts ###
import { Module } from '@nestjs/common';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';

import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';

import { UsersModule } from '../users/users.module';
import { JwtStrategy } from './strategies/jwt.strategy';
import { JwtRefreshStrategy } from './strategies/jwt-refresh.strategy';
import { LocalStrategy } from './strategies/local.strategy';
import { EmailVerificationModule } from 'src/email-verification/email-verification.module';
import { GoogleStrategy } from './strategies/google.strategy';
import { ConfigService } from '@nestjs/config';

@Module({
  imports: [
    UsersModule,
    PassportModule,
 JwtModule.registerAsync({
  inject: [ConfigService],
  useFactory: (config: ConfigService) => {
    const secret = config.getOrThrow<string>('JWT_ACCESS_SECRET');
    const expiresIn = config.getOrThrow('JWT_ACCESS_EXPIRES_IN');

    return {
      secret,
      signOptions: { expiresIn },
    };
  },
})
 ,
    EmailVerificationModule,
  ],
  controllers: [AuthController],
  providers: [
    AuthService,
    LocalStrategy,
    JwtStrategy,
    JwtRefreshStrategy,
    GoogleStrategy,
  ],
  exports: [AuthService],
})
export class AuthModule {}

---


### FILE: src/auth/guards/optional-jwt-auth.guard.ts ###
import { Injectable, ExecutionContext } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class OptionalJwtAuthGuard extends AuthGuard('jwt') {
  // Only run passport when there's an Authorization header (or cookie extractor)
  canActivate(context: ExecutionContext) {
    const req = context.switchToHttp().getRequest();
    const authHeader = req.headers?.authorization;

    // If no auth header, allow anonymously
    if (!authHeader) {
      return true;
    }

    // If header exists, run the normal jwt guard which will call validate()
    return super.canActivate(context) as boolean | Promise<boolean>;
  }

  // handleRequest receives (err, user, info)
  handleRequest(err: any, user: any, info: any) {
    // log details to debug why authentication failed
    if (info) {
      console.log('OptionalJwtAuthGuard - passport info:', info);
    }
    if (err) {
      // real error (e.g. DB lookup failed) ‚Äî rethrow
      throw err;
    }

    // If passport failed to authenticate it may pass `false` or `undefined` here.
    // We want to silence that and allow anonymous access, so return null in that case.
    if (!user) {
      return null;
    }

    // Auth succeeded
    return user;
  }
}

---


### FILE: src/auth/guards/jwt-refresh.guard.ts ###
import { AuthGuard } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtRefreshGuard extends AuthGuard('jwt-refresh') {}

---


### FILE: src/auth/guards/jwt-auth.guard.ts ###
import { AuthGuard } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

---


### FILE: src/auth/guards/local-auth.guard.ts ###
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

---


### FILE: src/auth/strategies/local.strategy.ts ###
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { AuthService } from '../auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy, 'local') {
  constructor(private readonly authService: AuthService) {
    super({ usernameField: 'email' });
  }

  async validate(email: string, password: string) {
  try {
      const user = await this.authService.validateUser(email, password);
   
      return user;
    } catch (exception) {
      // Optional: log the original error for debugging
      console.error('Auth validation error:', exception);

      // Throw generic message to client
      throw new UnauthorizedException('Invalid credentials');
    }
  
  }
}

---


### FILE: src/auth/strategies/google.strategy.ts ###
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, VerifyCallback } from 'passport-google-oauth20';
import { AuthService } from '../auth.service';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  constructor(
    private readonly authService: AuthService,
    private readonly config: ConfigService,
  ) {
    super({
      clientID: config.get<string>('GOOGLE_CLIENT_ID'),
      clientSecret: config.get<string>('GOOGLE_CLIENT_SECRET'),
      callbackURL: config.get<string>('GOOGLE_CALLBACK_URL'),
      scope: ['email', 'profile'],
      passReqToCallback: false,
    });
  }

  // profile comes from Google; map to our OAuthUser shape
  async validate(
    accessToken: string,
    refreshToken: string,
    profile: any,
    done: VerifyCallback,
  ): Promise<any> {
    try {
      const emailObj = (profile.emails && profile.emails[0]) || {
        value: undefined,
      };
      const oauthUser = {
        provider: 'google',
        providerId: profile.id,
        email: emailObj.value,
        name: profile.displayName,
      };

      // return the object that will be available as req.user
      return done(null, oauthUser);
    } catch (err) {
      return done(err as Error, false);
    }
  }
}

---


### FILE: src/auth/strategies/jwt.strategy.ts ###
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService } from 'src/users/users.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy, 'jwt') {
  constructor(
    config: ConfigService,
    private readonly userService: UsersService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: config.getOrThrow<string>('JWT_ACCESS_SECRET'),
    });
  }

  // Hypothetical improvement
  async validate(payload: { sub: number; email: string }) {
    // 1. Check database for active user
    const user = await this.userService.findOneById(payload.sub);

    // 2. Reject if user doesn't exist (e.g., account was deleted)
    if (!user) {
      throw new UnauthorizedException();
    }

    // 3. Attach user object to req.user
    return user;
  }
}

---


### FILE: src/auth/strategies/jwt-refresh.strategy.ts ###
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { UsersService } from 'src/users/users.service';

@Injectable()
export class JwtRefreshStrategy extends PassportStrategy(
  Strategy,
  'jwt-refresh',
) {
  constructor(
    config: ConfigService,
    private readonly userService: UsersService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromBodyField('refreshToken'),
      secretOrKey: config.getOrThrow<string>('JWT_REFRESH_SECRET'),
    });
  }

  async validate(payload: { sub: number; email: string }) {
    // 1. Check database for active user
    const user = await this.userService.findOneById(payload.sub);

    // 2. Reject if user doesn't exist (e.g., account was deleted)
    if (!user) {
      throw new UnauthorizedException();
    }

    // 3. Attach user object to req.user
    return user;
  }
}

---


### FILE: src/reset-password/password-reset.controller.ts ###
import { Controller, Post, Body, Inject } from '@nestjs/common';
import { PasswordResetService } from './password-reset.service';
import { ForgotDto } from './dto/forgot.dto';
import { ResetDto } from './dto/reset.dto';
import { UsersService } from '../users/users.service';
import type { IMailService } from 'src/mail/interfaces/mail-service.interface';
import { ConfigService } from '@nestjs/config';

@Controller('reset-password')
export class PasswordResetController {
  constructor(
    private resetService: PasswordResetService,
    private usersService: UsersService,
    @Inject('IMailService') private mailService: IMailService,
    private config: ConfigService,
  ) {}

  @Post('forgot')
  async forgot(@Body() dto: ForgotDto) {
    try {
      const user = await this.usersService.findByEmail(dto.email);
      if (!user) return { message: 'Email sent if account exists' };

      const { token } = await this.resetService.generateToken(user.id);

      const resetLink = this.resetService.generateResetLink(token);
      await this.mailService.sendEmail(
        user.email,
        'Reset Your Password',
        'reset-password',
        { name: user.name, resetLink },
      );

      return { message: 'Email sent if account exists' };
    } catch (err) {
      console.log(err);

      return { message: 'Email sent if account exists' };
    }
  }

  @Post('reset')
  async reset(@Body() dto: ResetDto) {
    const userId = await this.resetService.validateToken(dto.token);
    const user = await this.usersService.findOneById(userId);

    await this.usersService.updateUser( 
      { user,
         password: dto.password });
    return { message: 'Password updated' };
  }
}

---


### FILE: src/reset-password/reset-password.module.ts ###
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PasswordResetToken } from './entities/password-reset-token.entity';
import { PasswordResetService } from './password-reset.service';
import { PasswordResetController } from './password-reset.controller';
import { UsersModule } from '../users/users.module';
import { MailModule } from 'src/mail/mail.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([PasswordResetToken]),
    MailModule,
    UsersModule,
  ],
  controllers: [PasswordResetController],
  providers: [PasswordResetService],
  exports: [PasswordResetService],
})
export class ResetPasswordModule {}

---


### FILE: src/reset-password/password-reset.service.ts ###
import { Injectable, BadRequestException } from '@nestjs/common';
import { PasswordResetToken } from './entities/password-reset-token.entity';
import { Repository, MoreThan } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { randomBytes } from 'crypto';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class PasswordResetService {
  private  TOKEN_EXPIRATION_MINUTES : number;

  constructor(
    @InjectRepository(PasswordResetToken)
    private repo: Repository<PasswordResetToken>,
    private config: ConfigService,
  ) {
    this.TOKEN_EXPIRATION_MINUTES=config.get<number>("TOKEN_EXPIRATION_MINUTES") ?? 15
  }

  /** Public API **/

  async generateToken(userId: number) {
    const token = this.generateTokenValue();
    const expiresAt = this.calculateExpiration();

    await this.saveToken(userId, token, expiresAt);

    return { token, expiresAt };
  }

  async validateToken(token: string) {
    const tokenRow = await this.findValidToken(token);

    if (!tokenRow) throw new BadRequestException('Invalid or expired token');

    await this.deleteToken(tokenRow.id);

    return tokenRow.userId;
  }

  public generateResetLink(token: string): string {
    const frontendUrl = this.config.get<string>(
      'APP_DOMAIN',
      'http://localhost:3000',
    );
    const resetPath = '/reset-password';
    return `${frontendUrl}${resetPath}?token=${token}`;
  }
  /** Private helpers **/

  private generateTokenValue(): string {
    return randomBytes(32).toString('hex');
  }

  private calculateExpiration(): Date {
    const now = new Date();
    return new Date(now.getTime() + this.TOKEN_EXPIRATION_MINUTES * 60_000);
  }

  private async saveToken(userId: number, token: string, expiresAt: Date) {
    const entity = this.repo.create({ userId, token, expiresAt });
    await this.repo.save(entity);
  }

  private async findValidToken(
    token: string,
  ): Promise<PasswordResetToken | null> {
    return this.repo.findOne({
      where: { token, expiresAt: MoreThan(new Date()) },
    });
  }

  private async deleteToken(id: number) {
    await this.repo.delete(id);
  }
}

---


### FILE: src/reset-password/entities/password-reset-token.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  Index,
} from 'typeorm';

@Entity({ name: 'password_reset_tokens' })
export class PasswordResetToken {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  @Index()
  userId: number;

  @Column()
  @Index()
  token: string;

  @Column()
  expiresAt: Date;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: src/reset-password/dto/reset.dto.ts ###
import { IsString, MinLength } from 'class-validator';

export class ResetDto {
  @IsString()
  token: string;

  @IsString()
  @MinLength(8)
  password: string;
}

---


### FILE: src/reset-password/dto/forgot.dto.ts ###
import { IsEmail } from 'class-validator';

export class ForgotDto {
  @IsEmail()
  email: string;
}

---


### FILE: src/communities/types.ts ###
export enum CommunityType {
  PUBLIC = 'public',
  RESTRICTED = 'restricted',
  PRIVATE = 'private',
}

---


### FILE: src/communities/communities.service.ts ###
import {
  ConflictException,
  ForbiddenException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Not, Repository } from 'typeorm';
import { Community } from './entities/community.entity';
import { CommunityType } from './types';
import { User } from '../users/entities/user.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-membership.entity';
import { CommunityMembershipStatus } from 'src/community-memberships/types';

@Injectable()
export class CommunitiesService {
  constructor(
    @InjectRepository(Community)
    private readonly communitiesRepository: Repository<Community>,
    @InjectRepository(Community)
    private readonly communityRepository: Repository<Community>,
    @InjectRepository(CommunityMembership)
    private readonly membershipRepository: Repository<CommunityMembership>
  ) { }

  async create(data: {
    userId: number;
    name: string;
    displayName?: string;
    description?: string;
    communityType?: CommunityType;
  }) {
    const existingCommunity = await this.communitiesRepository.findOne({
      where: { name: data.name },
    });

    if (existingCommunity) {
      throw new ConflictException('Community with this name already exists.');
    }

    const community = this.communitiesRepository.create({
      ...data,
      owner: { id: data.userId },
    });

    return this.communitiesRepository.save(community);
  }

  findAll(query: {
    limit?: number;
    page?: number;
    name?: string;
    displayName?: string;
    communityType?: CommunityType;
    sort?: string;
  }) {
    const { limit = 10, page = 1, name, displayName, communityType, sort } = query;
    const queryBuilder = this.communitiesRepository
      .createQueryBuilder('community')
      .leftJoinAndSelect('community.owner', 'owner')
      .take(limit)
      .skip((page - 1) * limit);

    if (name) queryBuilder.andWhere('community.name LIKE :name', { name: `%${name}%` });
    if (displayName) queryBuilder.andWhere('community.displayName LIKE :displayName', { displayName: `%${displayName}%` });
    if (communityType !== undefined) queryBuilder.andWhere('community.communityType = :communityType', { communityType });
    if (sort === 'popular') queryBuilder.orderBy('community.subscribersCount', 'DESC');

    return queryBuilder.getManyAndCount();
  }

  async findOne(id: number, user?: User) {
    const community = await this.communitiesRepository.findOne({
      where: { id },
      relations: ['owner'],
    });

    if (!community) throw new NotFoundException(`Community with ID ${id} not found.`);

    await this.assertUserCanViewCommunity(user?.id, community);
    return community;


  }

  async findByName(name: string, user?: User) {
    const community = await this.communitiesRepository.findOne({
      where: { name },
      relations: ['owner'],
    });

    if (!community) throw new NotFoundException(`Community with name "${name}" not found.`);

    await this.assertUserCanViewCommunity(user?.id, community);
    return community;

  }

  async update(data: {
    id: number;
    name?: string;
    displayName?: string;
    description?: string;
    communityType?: CommunityType;
    subscribersCount?: number;
  }) {
    const { id, name } = data;

    if (name) {
      const existing = await this.communitiesRepository.findOne({
        where: { name, id: Not(id) },
      });
      if (existing) throw new ConflictException('Community name already exists.');
    }

    const community = await this.communitiesRepository.preload(data);
    if (!community) throw new NotFoundException(`Community with ID ${id} not found.`);

    return this.communitiesRepository.save(community);
  }

  async remove(id: number) {
    const community = await this.findOne(id);
    await this.communitiesRepository.remove(community);
  }
  async assertUserCanViewCommunity(
    userId: number | undefined,
    community: Community,
  ): Promise<void> {
    switch (community.communityType) {
      case CommunityType.PUBLIC:
      case CommunityType.RESTRICTED:
        return;

      case CommunityType.PRIVATE:
        if (!userId) {
          throw new ForbiddenException('Login required to view this community');
        }

        const isMember = await this.membershipRepository.exist({
          where: {
            userId,
            communityId: community.id,
            status: CommunityMembershipStatus.ACTIVE,
          },
        });

        if (!isMember) {
          throw new ForbiddenException('You are not a member of this community');
        }
        return;

      default:
        throw new ForbiddenException('Community is not accessible');
    }
  }

}

---


### FILE: src/communities/entities/community.entity.ts ###
import {
  Column,
  CreateDateColumn,
  Entity,
  ManyToOne,
  OneToMany,
  PrimaryGeneratedColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';
import { CommunityMembership } from '../../community-memberships/entities/community-membership.entity';
import { CommunityType } from '../types';
import { CommunityModerator } from '../../community-moderators/entities/community-moderator.entity'; // Import CommunityModerator

@Entity('communities')
export class Community {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 50, unique: true })
  name: string;

  @Column({ type: 'varchar', length: 100, nullable: true })
  displayName: string;

  @Column({ type: 'text', nullable: true })
  description: string;

@ManyToOne(() => User, (user) => user.createdCommunities)
owner: User;

@Column({ nullable: true })
ownerId: number;

  @CreateDateColumn()
  createdAt: Date;

  @Column({ type: 'simple-enum', enum : CommunityType, default: CommunityType.PUBLIC })
  communityType: CommunityType;

  @Column({ type: 'integer', default: 0 })
  subscribersCount: number;

  @OneToMany(() => Post, (post) => post.community)
  posts: Post[];

  @OneToMany(
    () => CommunityMembership,
    (membership) => membership.community,
  )
  memberships: CommunityMembership[];

  @OneToMany(() => CommunityModerator, (communityModerator) => communityModerator.community)
  moderators: CommunityModerator[];
}

---


### FILE: src/communities/communities.controller.ts ###
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  ParseIntPipe,
  UseGuards,
} from '@nestjs/common';
import { CommunitiesService } from './communities.service';
import { CreateCommunityDto } from './dto/create-community.dto';
import { UpdateCommunityDto } from './dto/update-community.dto';
import { CommunityQueryDto } from './dto/community-query.dto';
import { CommunityResponseDto } from './dto/community-response.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { User } from '../users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';

@Controller('communities')
export class CommunitiesController {
  constructor(private readonly communitiesService: CommunitiesService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  async create(
    @Body() createCommunityDto: CreateCommunityDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommunityResponseDto>> {
    const community = await this.communitiesService.create({
       userId :user.id ,
      name: createCommunityDto.name,
      displayName: createCommunityDto.displayName,
      description: createCommunityDto.description,
      communityType: createCommunityDto.communityType,
    });
    return new ResponseDto(CommunityResponseDto.fromEntity(community));
  }

  @Get()
  async findAll(@Query() query: CommunityQueryDto): Promise<PaginatedResponseDto<CommunityResponseDto>> {
    const [communities, count] = await this.communitiesService.findAll({
      limit: query.limit,
      page: query.page,
      name: query.name,
      displayName: query.displayName,
      communityType: query.communityType,
      sort: query.sort,
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      communities.length,
    );

    return new PaginatedResponseDto(communities.map(c => CommunityResponseDto.fromEntity(c)), paginationMeta);
  }

  @Get(':id')
  async findOne(@Param('id', ParseIntPipe) id: number): Promise<ResponseDto<CommunityResponseDto>> {
    const community = await this.communitiesService.findOne(id);
    return new ResponseDto(CommunityResponseDto.fromEntity(community));
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateCommunityDto: UpdateCommunityDto,
  ): Promise<ResponseDto<CommunityResponseDto>> {
    const community = await this.communitiesService.update(  {
      id,
      name: updateCommunityDto.name,
      displayName: updateCommunityDto.displayName,
      description: updateCommunityDto.description,
      communityType: updateCommunityDto.communityType,
    });
    return new ResponseDto(CommunityResponseDto.fromEntity(community));
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  async remove(@Param('id', ParseIntPipe) id: number): Promise<ResponseDto<void>> {
    const success = await this.communitiesService.remove(id);
    return new ResponseDto(success);
  }
}

---


### FILE: src/communities/communities.module.ts ###
import { Module } from '@nestjs/common';
import { CommunitiesService } from './communities.service';
import { CommunitiesController } from './communities.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Community } from './entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-membership.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Community]),
CommunityMembership],
  controllers: [CommunitiesController],
  providers: [CommunitiesService],
  exports: [CommunitiesService],
})
export class CommunitiesModule {}

---


### FILE: src/communities/dto/create-community.dto.ts ###
import {
  IsEnum,
  IsOptional,
  IsString,
  Length,
  Matches,
} from 'class-validator';
import { CommunityType } from '../types';

export class CreateCommunityDto {
  @IsString()
  @Length(3, 50)
  @Matches(/^[a-z0-9\-]+$/, {
    message: 'Name can only contain lowercase letters, numbers, and hyphens.',
  })
  name: string;

  @IsOptional()
  @IsString()
  @Length(3, 100)
  displayName?: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsEnum(CommunityType)
  communityType?: CommunityType;
}

---


### FILE: src/communities/dto/community-response.dto.ts ###
import { Exclude, Expose, plainToInstance } from 'class-transformer';
import { Community } from '../entities/community.entity';
import { CommunityType } from '../types'; // Import CommunityType

@Exclude()
export class CommunityResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly name: string;
  @Expose() readonly displayName: string;
  @Expose() readonly description: string;
  @Expose() readonly isPublic: boolean;
  @Expose() readonly subscribersCount: number;
  @Expose() readonly createdAt: Date;

  static fromEntity(entity: Community): CommunityResponseDto {
    const dto = plainToInstance(CommunityResponseDto, entity, {
      excludeExtraneousValues: true,
    });
    dto.isPublic = entity.communityType === CommunityType.PUBLIC;
    return dto;
  }
}
---


### FILE: src/communities/dto/community-query.dto.ts ###
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { PaginationDto } from '../../common/dto/pagination.dto';
import { CommunityType } from '../types';

export class CommunityQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  displayName?: string;

  @IsOptional()
  @IsEnum(CommunityType)
  communityType?: CommunityType;

  @IsOptional()
  @IsString()
  sort?: string;
}

---


### FILE: src/communities/dto/update-community.dto.ts ###
import { PartialType } from '@nestjs/mapped-types';
import { CreateCommunityDto } from './create-community.dto';

export class UpdateCommunityDto extends PartialType(CreateCommunityDto) {}

---


### FILE: src/mail/interfaces/mail-service.interface.ts ###
export interface IMailService {
  sendEmail(
    to: string,
    subject: string,
    templateName: string,
    context: any,
  ): Promise<void>;
}

---


### FILE: src/mail/services/nodemailer-mail.service.ts ###
import { Injectable } from '@nestjs/common';
import { MailerService } from '@nestjs-modules/mailer';
import { IMailService } from '../interfaces/mail-service.interface';

@Injectable()
export class NodemailerMailService implements IMailService {
  constructor(private readonly mailerService: MailerService) {}

  async sendEmail(
    to: string,
    subject: string,
    templateName: string,
    context: any,
  ): Promise<void> {
    await this.mailerService.sendMail({
      to,
      subject,
      template: templateName,
      context,
    });
  }
}

---


### FILE: src/mail/mail.module.ts ###
import { Module } from '@nestjs/common';
import { MailerModule } from '@nestjs-modules/mailer';
import { NodemailerMailService } from './services/nodemailer-mail.service';
import { IMailService } from './interfaces/mail-service.interface';
import { ConfigService } from '@nestjs/config';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
@Module({
  imports: [
    MailerModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        transport: {
          host: config.getOrThrow<string>('SMTP_HOST'),
          port: config.getOrThrow<number>('SMTP_PORT'),
          secure: false,
          /* auth: {
            user: config.getOrThrow<string>('SMTP_USER'),
            pass: config.getOrThrow<string>('SMTP_PASS'),
          },*/
        },
        defaults: {
          from: config.getOrThrow<string>('SMTP_FROM'),
        },
        template: {
          dir: process.cwd() + '/src/mail/templates',
          adapter: new HandlebarsAdapter(),
          options: { strict: true },
        },
      }),
    }),
  ],
  providers: [
    {
      provide: 'IMailService',
      useClass: NodemailerMailService,
    },
  ],
  exports: ['IMailService'],
})
export class MailModule {}

---


### FILE: src/app.service.ts ###
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return '<h1>Hello World!';
  }
}

---


### FILE: src/profile/profile.service.ts ###
import { ConflictException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Not, Repository } from 'typeorm';
import { Profile } from './entities/profile.entity';
import { User } from 'src/users/entities/user.entity';

interface CreateProfileParams {
  user: User;
  username: string;
  bio?: string | null;
  picture?: string | null;
}

interface UpdateProfileParams {
  profile: Profile;
  username?: string | null;
  bio?: string | null;
  picture?: string | null; // This will now be the file path
}

@Injectable()
export class ProfileService {
  constructor(
    @InjectRepository(Profile)
    private readonly profileRepo: Repository<Profile>,
  ) { }

  async createProfile(params: CreateProfileParams): Promise<Profile> {

    const existingProfile = await this
      .findOneByUserId(params.user.id)
      .catch(() => null);
    if (existingProfile) {
      throw new ConflictException('Profile already exists for this user.');
    }

    const existingUsername = await this.profileRepo.findOne({
      where: { username: params.username }, // exclude current profile
    });
    if (existingUsername) {
      throw new ConflictException('Username is already taken.');
    }

    const profile = this.profileRepo.create({
      user: params.user,
      username: params.username ?? null,
      bio: params.bio ?? null,
      picture: params.picture ?? null,
    });
    return this.profileRepo.save(profile);
  }

  async updateProfile(params: UpdateProfileParams): Promise<Profile> {
    const { profile, username, bio, picture } = params;

    if (username) {
      const existingUsername = await this.profileRepo.findOne({
        where: { username, id: Not(profile.id) }, // exclude current profile
      });
      if (existingUsername) {
        throw new ConflictException('Username is already taken.');
      }
    }

    Object.assign(profile, {
      ...(username !== undefined && { username }),
      ...(bio !== undefined && { bio }),
      ...(picture !== undefined && { picture }), // Directly assign the path
    });
    return this.profileRepo.save(profile);
  }

  async findOneByUserId(userId: number): Promise<Profile> {
    const profile = await this.profileRepo.findOne({ where: { user: { id: userId } } });
    if (!profile) {
      throw new NotFoundException(`Profile for user with ID ${userId} not found.`);
    }
    return profile;
  }
}
---


### FILE: src/profile/dtos/create-profile.dto.ts ###
import { IsNotEmpty, IsString, IsOptional, IsAlphanumeric, MinLength, MaxLength } from 'class-validator';

export class CreateProfileDto {
  @IsNotEmpty()
  @IsString()
  @IsAlphanumeric()
  @MinLength(3)
  @MaxLength(20)
  username: string;

  @IsOptional()
  @IsString()
  @MaxLength(255)
  bio?: string;
}
---


### FILE: src/profile/dtos/update-profile.dto.ts ###
import { IsOptional, IsString, IsUrl, IsAlphanumeric, MinLength, MaxLength } from 'class-validator';

export class UpdateProfileDto {
  @IsOptional()
  @IsString()
  @IsAlphanumeric()
  @MinLength(3)
  @MaxLength(20)
  username?: string;

  @IsOptional()
  @IsString()
  @MaxLength(255)
  bio?: string;
}

---


### FILE: src/profile/dtos/profile-response.dto.ts ###
import { Expose } from 'class-transformer';
import { Profile } from '../entities/profile.entity';

export class ProfileResponseDto {
  @Expose()
  id: number;

  @Expose()
  username: string;

  @Expose()
  bio: string | null;

  @Expose()
  picture: string | null;

  /**
   * Factory method: converts a Profile entity into this DTO.
   * Purely copies values; no business or environment logic.
   */
  static fromEntity(entity: Profile): ProfileResponseDto {
    const dto = new ProfileResponseDto();
    dto.id = entity.id;
    dto.username = entity.username;
    dto.bio = entity.bio ?? null;
    dto.picture = entity.picture ?? null;
    return dto;
  }
}

---


### FILE: src/profile/interceptors/picture.interceptor.ts ###
import { FileInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname } from 'path';

/**
 * Reusable interceptor for profile picture uploads.
 * @param field The name of the file field (default: 'picture')
 */
export function PictureInterceptor(field = 'picture') {
  return FileInterceptor(field, {
    storage: diskStorage({
      destination: './uploads',
      filename: (_req, file, cb) => {
        const randomName = Array(32)
          .fill(null)
          .map(() => Math.floor(Math.random() * 16).toString(16))
          .join('');
        cb(null, `${randomName}${extname(file.originalname)}`);
      },
    }),
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
    fileFilter: (_req, file, callback) => {
      const allowedTypes = /jpeg|jpg|png|gif/;
      callback(null, allowedTypes.test(file.mimetype));
    },
  });
}

---


### FILE: src/profile/profile.controller.ts ###
import {
  Controller,
  Get,
  UseGuards,
  Patch,
  Body,
  UseInterceptors,
  UploadedFile,
  Post,
  ConflictException,
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ProfileService } from './profile.service';
import { UpdateProfileDto } from './dtos/update-profile.dto';
import { CreateProfileDto } from './dtos/create-profile.dto';
import { User } from 'src/users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { FileInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname } from 'path';
import { ProfileResponseDto } from './dtos/profile-response.dto';
import { ConfigService } from '@nestjs/config';
import { PictureInterceptor } from './interceptors/picture.interceptor';

@Controller('profile')
export class ProfileController {
  constructor(private readonly profileService: ProfileService

  ) { }
  @UseGuards(JwtAuthGuard)
  @Get()
  async getMyProfile(@GetUser() user: User): Promise<ProfileResponseDto> {
    const profile = await this.profileService.findOneByUserId(user.id);
    return ProfileResponseDto.fromEntity(profile);
  }

  @UseGuards(JwtAuthGuard)
  @Post()
  @UseInterceptors(PictureInterceptor
  )
  async createMyProfile(
    @GetUser() user: User,
    @Body() createProfileDto: CreateProfileDto,
    @UploadedFile() file: Express.Multer.File,
  ): Promise<ProfileResponseDto> {

    const profile = await this.profileService.createProfile({
      user,
      username: createProfileDto.username,
      bio: createProfileDto.bio,
      picture: file ? file.path : undefined,
    });

    return ProfileResponseDto.fromEntity(profile);
  }

  @UseGuards(JwtAuthGuard)
  @Patch()
  @UseInterceptors(PictureInterceptor)
  async updateMyProfile(
    @GetUser() user: User,
    @Body() updateProfileDto: UpdateProfileDto,
    @UploadedFile() file: Express.Multer.File,
  ): Promise<ProfileResponseDto> {
    const profile = await this.profileService.findOneByUserId(user.id);

    const updatedProfile = await this.profileService.updateProfile({
      profile,
      username: updateProfileDto.username,
      bio: updateProfileDto.bio,
      picture: file ? file.path : undefined,
    });

    return ProfileResponseDto.fromEntity(updatedProfile);
  }
}
---


### FILE: src/profile/entities/profile.entity.ts ###
// src/profile/entities/profile.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, OneToOne, JoinColumn } from 'typeorm';
import { User } from '../../users/entities/user.entity'; // Updated path

@Entity('profiles') // Updated entity name
export class Profile { // Updated class name
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', unique: true })
  username: string;

  @Column({ type: 'text', nullable: true })
  bio: string | null;

  @Column({ type: 'varchar', nullable: true })
  picture: string | null;

  @OneToOne(() => User, user => user.profile)
  @JoinColumn()
  user: User;
}

---


### FILE: src/profile/profile.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Profile } from './entities/profile.entity';
import { ProfileService } from './profile.service';
import { ProfileController } from './profile.controller';

@Module({
  imports: [TypeOrmModule.forFeature([Profile])],
  providers: [ProfileService],
  controllers: [ProfileController],
  exports: [ProfileService], // Export ProfileService so other modules can use it
})
export class ProfileModule {}

---


### FILE: src/app.module.ts ###
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';

import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UsersModule } from './users/users.module';
import { PostsModule } from './posts/posts.module';
import { CommentsModule } from './comments/comments.module';
import { ReactionsModule } from './reactions/reactions.module';
import { CommunitiesModule } from './communities/communities.module';
import { CommunityMembershipsModule } from './community-memberships/community-memberships.module';

import { User } from './users/entities/user.entity';
import { Post } from './posts/entities/post.entity';
import { Comment } from './comments/entities/comment.entity';
import { AuthModule } from './auth/auth.module';
import { CaslModule } from './casl/casl.module';
import { EmailVerificationToken } from './email-verification/entities/email-verification-token.entity';

import { ResetPasswordModule } from './reset-password/reset-password.module';
import { PasswordResetToken } from './reset-password/entities/password-reset-token.entity';
import { CommentReaction } from './reactions/entities/comment-reaction.entity';
import { PostReaction } from './reactions/entities/post-reaction.entity';
import { Profile } from './profile/entities/profile.entity';
import { ProfileModule } from './profile/profile.module';
import { Community } from './communities/entities/community.entity';
import { CommunityMembership } from './community-memberships/entities/community-membership.entity';
import { CommunityModeratorsModule } from './community-moderators/community-moderators.module';
import { ReportsModule } from './reports/reports.module';
import { CommentReport } from './reports/entities/comment-report.entity';
import { PostReport } from './reports/entities/post-report.entity';
import { UserReport } from './reports/entities/user-report.entity';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }), // loads .env globally

    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        type: config.getOrThrow<'sqlite' | 'mysql'>('DB_TYPE'),
        database: config.getOrThrow<string>('DB_NAME'),
        entities: [
          User,
          Post,
          Comment,
          CommentReaction,
          PostReaction,
          EmailVerificationToken,
          PasswordResetToken,
          Profile,
          Community,
          CommunityMembership,
          CommentReport,
          PostReport,
          UserReport,
        ],
        migrations: ['./src/migrations/*.ts'],
        synchronize: false,
      }),
    }),

    UsersModule,
    PostsModule,
    CommentsModule,
    ReactionsModule,
    AuthModule,
    CaslModule,
    ResetPasswordModule,
    ProfileModule,
    CommunitiesModule,
    CommunityMembershipsModule,
    CommunityModeratorsModule,
    ReportsModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

---


### FILE: src/community-moderators/community-moderators.controller.ts ###
import {
  Controller,
  Post,
  Get,
  Param,
  Delete,
  Body,
  ParseIntPipe,
  HttpCode,
  HttpStatus,
  Query,
  UseGuards,
} from '@nestjs/common';
import { CommunityModeratorsService } from './community-moderators.service';
import { CommunityModeratorResponseDto } from './dto/community-moderator-response.dto';
import { CommunityModeratorQueryDto } from './dto/community-moderator-query.dto';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';

@Controller('communities/:communityId/moderators')
export class CommunityModeratorsController {
  constructor(private readonly service: CommunityModeratorsService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  async create(
    @Param('communityId', ParseIntPipe) communityId: number,
    @Body('userId', ParseIntPipe) userId: number,
    @GetUser() currentUser: User,
  ): Promise<ResponseDto<CommunityModeratorResponseDto>> {
    const communityModerator = await this.service.create({
      userId,
      communityId,
      currentUser,
    });
    return new ResponseDto(
      CommunityModeratorResponseDto.fromEntity(communityModerator),
    );
  }

  @Get()
  async findAll(
    @Param('communityId', ParseIntPipe) communityId: number,
    @Query() queryDto: CommunityModeratorQueryDto,
  ): Promise<PaginatedResponseDto<CommunityModeratorResponseDto>> {
    const { data, count } = await this.service.findAll({
      communityId,
      page: queryDto.page,
      limit: queryDto.limit,
    });

    const paginationMeta = new PaginationMetaDto(
      queryDto.page,
      queryDto.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(
      data.map(CommunityModeratorResponseDto.fromEntity),
      paginationMeta,
    );
  }

  @Get(':moderatorId')
  async findOne(
    @Param('communityId', ParseIntPipe) communityId: number,
    @Param('moderatorId', ParseIntPipe) moderatorId: number,
  ): Promise<ResponseDto<CommunityModeratorResponseDto>> {
    const communityModerator = await this.service.findOne({
      moderatorId,
      communityId,
    });
    return new ResponseDto(
      CommunityModeratorResponseDto.fromEntity(communityModerator),
    );
  }

  @Delete(':moderatorId')
  @HttpCode(HttpStatus.NO_CONTENT)
  @UseGuards(JwtAuthGuard)
  async remove(
    @Param('communityId', ParseIntPipe) communityId: number,
    @Param('moderatorId', ParseIntPipe) moderatorId: number,
    @GetUser() currentUser: User,
  ): Promise<void> {
    await this.service.remove({ moderatorId, communityId, currentUser });
  }
}

---


### FILE: src/community-moderators/community-moderators.service.ts ###
import {
  Injectable,
  NotFoundException,
  ConflictException,
  BadRequestException,
  ForbiddenException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CommunityModerator } from './entities/community-moderator.entity';
import { UsersService } from '../users/users.service';
import { CommunitiesService } from '../communities/communities.service';
import { CommunityMembershipsService } from '../community-memberships/community-memberships.service';
import { User } from 'src/users/entities/user.entity';
import { CommunityMembershipStatus } from 'src/community-memberships/types';

@Injectable()
export class CommunityModeratorsService {
  constructor(
    @InjectRepository(CommunityModerator)
    private readonly communityModeratorRepository: Repository<CommunityModerator>,
    private readonly usersService: UsersService,
    private readonly communitiesService: CommunitiesService,
    private readonly membershipsService: CommunityMembershipsService,
  ) {}

  async create(options: {
    userId: number;
    communityId: number;
    currentUser: User;
  }): Promise<CommunityModerator> {
    const { userId, communityId, currentUser } = options;

    const community = await this.communitiesService.findOne(communityId);
    if (!community) {
      throw new NotFoundException(`Community with ID ${communityId} not found`);
    }

    if (community.ownerId !== currentUser.id) {
      throw new ForbiddenException('You are not the owner of this community');
    }

    const user = await this.usersService.findOneById(userId);
    if (!user) {
      throw new NotFoundException(`User with ID ${userId} not found`);
    }

    if (!user.emailVerifiedAt) {
      throw new BadRequestException('User is not active');
    }

    const isModerator = await this.communityModeratorRepository.exist({
      where: { moderatorId: userId, communityId },
    });

    if (isModerator) {
      throw new ConflictException('User is already a moderator');
    }

    const membership = await this.membershipsService.findOne(
      userId,
      communityId,
    );

    if (membership) {
      if (membership.status === CommunityMembershipStatus.BLOCKED) {
        throw new BadRequestException(
          'Blocked users cannot be made moderators.',
        );
      }
      if (membership.status === CommunityMembershipStatus.PENDING) {
        await this.membershipsService.activateMembership(
          userId,
          communityId,
        );
      }
    } else {
      await this.membershipsService.createMembership({
        userId,
        communityId,
        activate: true,
      });
    }

    const moderatorEntity = this.communityModeratorRepository.create({
      moderator: user,
      community,
    });
    return this.communityModeratorRepository.save(moderatorEntity);
  }

  async findAll(options: {
    communityId: number;
    page?: number;
    limit?: number;
  }): Promise<{ data: CommunityModerator[]; count: number }> {
    const { communityId, page = 1, limit = 10 } = options;
    const [data, count] = await this.communityModeratorRepository
      .createQueryBuilder('moderator')
      .where('moderator.communityId = :communityId', { communityId })
      .leftJoinAndSelect('moderator.moderator', 'user')
      .take(limit)
      .skip((page - 1) * limit)
      .getManyAndCount();

    return { data, count };
  }

  async findOne(options: {
    moderatorId: number;
    communityId: number;
  }): Promise<CommunityModerator> {
    const { moderatorId, communityId } = options;
    const communityModerator = await this.communityModeratorRepository.findOne({
      where: { moderatorId, communityId },
      relations: ['moderator', 'community'],
    });
    if (!communityModerator) {
      throw new NotFoundException(
        `CommunityModerator with moderator ID ${moderatorId} and community ID ${communityId} not found`,
      );
    }
    return communityModerator;
  }

  async remove(options: {
    moderatorId: number;
    communityId: number;
    currentUser: User;
  }): Promise<void> {
    const { moderatorId, communityId, currentUser } = options;

    const community = await this.communitiesService.findOne(communityId);
    if (!community) {
      throw new NotFoundException(`Community with ID ${communityId} not found`);
    }

    if (community.ownerId !== currentUser.id) {
      throw new ForbiddenException('You are not the owner of this community');
    }

    const moderator = await this.communityModeratorRepository.findOne({
      where: { moderatorId, communityId },
    });

    if (!moderator) {
      throw new NotFoundException('Moderator not found');
    }

    await this.communityModeratorRepository.delete({ moderatorId, communityId });
  }
}

---


### FILE: src/community-moderators/entities/community-moderator.entity.ts ###
// backend/src/community-moderators/entities/community-moderator.entity.ts
import { Entity, PrimaryGeneratedColumn, ManyToOne, PrimaryColumn } from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';

@Entity('community_moderators')
export class CommunityModerator {
  @PrimaryColumn()
  moderatorId: number;

  @PrimaryColumn()
  communityId: number;

  @ManyToOne(() => User, (user) => user.moderatedCommunities)
  moderator: User;

  @ManyToOne(() => Community, (community) => community.moderators)
  community: Community;
}

---


### FILE: src/community-moderators/community-moderators.module.ts ###
// backend/src/community-moderators/community-moderators.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CommunityModerator } from './entities/community-moderator.entity';
import { CommunityModeratorsService } from './community-moderators.service';
import { CommunityModeratorsController } from './community-moderators.controller';
import { UsersModule } from '../users/users.module'; // Import UsersModule
import { CommunitiesModule } from '../communities/communities.module'; // Import CommunitiesModule

@Module({
  imports: [
    TypeOrmModule.forFeature([CommunityModerator]),
    UsersModule, // Add UsersModule
    CommunitiesModule, // Add CommunitiesModule
  ],
  providers: [CommunityModeratorsService],
  controllers: [CommunityModeratorsController],
  exports: [CommunityModeratorsService],
})
export class CommunityModeratorsModule {}

---


### FILE: src/community-moderators/dto/update-moderator.dto.ts ###
// backend/src/moderators/dto/update-moderator.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateModeratorDto } from './create-moderator.dto';

export class UpdateModeratorDto extends PartialType(CreateModeratorDto) {}

---


### FILE: src/community-moderators/dto/create-community-moderator.dto.ts ###
// backend/src/community-moderators/dto/create-community-moderator.dto.ts
export class CreateCommunityModeratorDto {
  userId: number;
  communityId: number;
}

---


### FILE: src/community-moderators/dto/community-moderator-paginated-response.dto.ts ###
// backend/src/community-moderators/dto/community-moderator-paginated-response.dto.ts
import { PaginatedResponseDto } from '../../common/dto/paginated-response.dto';
import { CommunityModeratorResponseDto } from './community-moderator-response.dto';

export class CommunityModeratorPaginatedResponseDto extends PaginatedResponseDto<CommunityModeratorResponseDto> {
  data: CommunityModeratorResponseDto[];
}

---


### FILE: src/community-moderators/dto/community-moderator-response.dto.ts ###
// backend/src/community-moderators/dto/community-moderator-response.dto.ts
import { Expose, Type } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { CommunityResponseDto } from '../../communities/dto/community-response.dto';
import { CommunityModerator } from '../entities/community-moderator.entity'; // Import CommunityModerator

export class CommunityModeratorResponseDto {
  @Expose()
  moderatorId: number;

  @Expose()
  communityId: number;

  @Expose()
  @Type(() => UserResponseDto)
  moderator: UserResponseDto;

  @Expose()
  @Type(() => CommunityResponseDto)
  community: CommunityResponseDto;

  static fromEntity(entity: CommunityModerator): CommunityModeratorResponseDto {
    const dto = new CommunityModeratorResponseDto();
    dto.moderatorId = entity.moderatorId;
    dto.communityId = entity.communityId;
    dto.moderator = entity.moderator;
    dto.community = CommunityResponseDto.fromEntity(entity.community);
    return dto;
  }
}

---


### FILE: src/community-moderators/dto/community-moderator-query.dto.ts ###
// backend/src/community-moderators/dto/community-moderator-query.dto.ts
import { IsOptional, IsNumberString } from 'class-validator';
import { PaginationDto } from '../../common/dto/pagination.dto';

export class CommunityModeratorQueryDto extends PaginationDto {
  @IsOptional()
  @IsNumberString()
  userId?: number;
}

---


### FILE: src/data-source.ts ###
import { DataSource } from 'typeorm';
import { config } from 'dotenv';
import { Post } from './posts/entities/post.entity';
import { User } from './users/entities/user.entity';
import { Comment } from './comments/entities/comment.entity';
import { PostReaction } from './reactions/entities/post-reaction.entity';
import { CommentReaction } from './reactions/entities/comment-reaction.entity';
import { EmailVerificationToken } from './email-verification/entities/email-verification-token.entity';
import { PasswordResetToken } from './reset-password/entities/password-reset-token.entity';
import { Profile } from './profile/entities/profile.entity';
import { Community } from './communities/entities/community.entity'; // Import Community
import { CommunityMembership } from './community-memberships/entities/community-membership.entity'; // Import CommunityMembership
import { CommunityModerator } from './community-moderators/entities/community-moderator.entity'; // Import CommunityModerator
import { PostReport } from './reports/entities/post-report.entity';
import { CommentReport } from './reports/entities/comment-report.entity';
import { UserReport } from './reports/entities/user-report.entity';

config(); // load .env manually

const dbName = process.env.DB_NAME;
if (!dbName) {
  throw new Error('DB_NAME environment variable is not defined.');
}

export const AppDataSource = new DataSource({
  type: 'sqlite',
  database: dbName,
  entities: [
    User,
    Post,
    Comment,
    PostReaction,
    CommentReaction,
    PasswordResetToken,
    EmailVerificationToken,
    Profile,
    Community, // Add Community
    CommunityMembership, // Add CommunityMembership
    CommunityModerator, // Add Moderator
    PostReport,
    CommentReport,
    UserReport,
  ],
  synchronize: false,
  migrations: ['src/database/migrations/*.ts'],
  logging: true,
});

---


### FILE: src/comments/pipes/comment.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { CommentsService } from '../comments.service';
import { Comment } from '../entities/comment.entity';

@Injectable()
export class CommentPipe implements PipeTransform<string, Promise<Comment>> {
  constructor(private readonly commentsService: CommentsService) {}

  async transform(value: string): Promise<Comment> {
    const comment = await this.commentsService.findOne(+value);

    if (!comment) {
      throw new NotFoundException('Comment not found');
    }

    return comment;
  }
}

---


### FILE: src/comments/comments.service.ts ###
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Brackets, Repository } from 'typeorm';
import { Comment } from './entities/comment.entity';

import { PostsService } from 'src/posts/posts.service';

@Injectable()
export class CommentsService {
  constructor(
    @InjectRepository(Comment)
    private readonly commentRepo: Repository<Comment>,
    private readonly postsService: PostsService, // Inject PostsService
  ) { }

  async findAll(options: {
    postId?: number;
    authorId?: number;
    search?: string;
    page?: number;
    limit?: number;
    currentUserId?: number;
    parentId?: number;
  }): Promise<{ data: Comment[]; count: number }> {
    const { postId, authorId, search, page = 1, limit = 10, currentUserId, parentId } = options;

    const query = this.commentRepo
      .createQueryBuilder('comment')
      .leftJoinAndSelect('comment.author', 'author')
      .leftJoinAndSelect('comment.post', 'post')
      .leftJoinAndSelect('comment.parent', 'parent');

    if (parentId) {
      query.andWhere('comment.parentId = :parentId', { parentId });
    } else if (postId) {
      query.andWhere('comment.parentId IS NULL');
    }

    if (currentUserId) {
      query.leftJoinAndMapOne(
        'comment.userReaction',
        'comment.reactions',
        'userReaction',
        'userReaction.userId = :currentUserId',
      );
      query.setParameter('currentUserId', currentUserId);
    }

    if (search) {
      query.andWhere('comment.content LIKE :search', { search: `%${search}%` });
    }
    if (authorId) {
      query.andWhere('comment.author.id = :authorId', { authorId });
    }
    if (postId) {
      query.andWhere('comment.post.id = :postId', { postId });
    }

    query.orderBy('comment.createdAt', 'DESC');

    const [data, count] = await query.take(limit).skip((page - 1) * limit).getManyAndCount();

    const commentsWithLimitedReplies = await Promise.all(
      data.map(async (comment) => {
        const repliesQuery = this.commentRepo
          .createQueryBuilder('reply')
          .leftJoinAndSelect('reply.author', 'author')
          .where('reply.parentId = :commentId', { commentId: comment.id })
          .orderBy('reply.createdAt', 'ASC')
          .take(2);

        if (currentUserId) {
          repliesQuery.leftJoinAndMapOne(
            'reply.userReaction',
            'reply.reactions',
            'userReaction',
            'userReaction.userId = :currentUserId',
          );
          repliesQuery.setParameter('currentUserId', currentUserId);
        }

        comment.replies = await repliesQuery.getMany();
        return comment;
      }),
    );

    return { data: commentsWithLimitedReplies, count };
  }

  async findOne(id: number, currentUserId?: number) {

    const mainCommentQuery = this.commentRepo.createQueryBuilder('comment')

      .leftJoinAndSelect('comment.author', 'author')

      .leftJoinAndSelect('comment.post', 'post')

      .leftJoinAndSelect('comment.parent', 'parent');

    if (currentUserId) {

      mainCommentQuery.leftJoinAndMapOne(

        'comment.userReaction',

        'comment.reactions',

        'userReaction',

        'userReaction.userId = :currentUserId',

      );

      mainCommentQuery.setParameter('currentUserId', currentUserId);

    }

    mainCommentQuery.where('comment.id = :id', { id });

    const comment = await mainCommentQuery.getOne();

    if (comment) {

      const repliesQuery = this.commentRepo

        .createQueryBuilder('reply')

        .leftJoinAndSelect('reply.author', 'author')

        .where('reply.parentId = :commentId', { commentId: comment.id })

        .orderBy('reply.createdAt', 'ASC')

        .take(2); // Limit to 2 replies

      if (currentUserId) {

        repliesQuery.leftJoinAndMapOne(

          'reply.userReaction',

          'reply.reactions',

          'userReaction',

          'userReaction.userId = :currentUserId',

        );

        repliesQuery.setParameter('currentUserId', currentUserId);

      }

      comment.replies = await repliesQuery.getMany();

    }

    return comment;

  }

  async createComment(
    postId: number,
    content: string,
    userId: number,
    parentId?: number,
  ) {
    // We get the post via postsService.findOne to ensure consistency and proper typeorm relations loading
    const post = await this.postsService.findOne(postId);
    if (!post) {
      throw new NotFoundException('Post not found');
    }

    if (post.commentsLocked) {
      throw new BadRequestException('Comments are locked for this post.');
    }

    
    const comment = this.commentRepo.create({
      content,
      authorId: userId,
      post: post,
    });

    if (parentId) {
      const parent = await this.commentRepo.findOne({
        where: { id: parentId },
        relations: ['post'],
      });
      if (!parent)
        throw new NotFoundException('Parent comment not found');
      if (parent.post.id !== postId) {
        throw new BadRequestException(
          'Parent comment does not belong to this post',
        );
      }
      comment.parent = parent;
      await this.incrementRepliesCount(parentId);
    }

    const savedComment = await this.commentRepo.save(comment);

    // Increment commentsCount on the post using PostsService
    await this.postsService.incrementCommentsCount(post.id);

    return savedComment;
  }

  async update(
    updateCommentData: {
      id: number;
      content?: string;
    },
  ): Promise<Comment> {
    const comment = await this.commentRepo.findOneBy({
      id: updateCommentData.id,
    });
    if (!comment) {
      throw new NotFoundException('Comment not found');
    }

    if (updateCommentData.content !== undefined)
      comment.content = updateCommentData.content;

    return this.commentRepo.save(comment);
  }

  async remove(id: number): Promise<boolean> {
    const comment = await this.commentRepo.findOne({
      where: { id },
      relations: ['post', 'parent'], // Load post and parent relation to update counts
    });
    if (!comment) {
      throw new NotFoundException('Comment not found');
    }

    // Decrement commentsCount on the post using PostsService
    if (comment.post) {
      await this.postsService.decrementCommentsCount(comment.post.id);
    }

    // Decrement repliesCount on the parent comment
    if (comment.parent) {
      await this.decrementRepliesCount(comment.parent.id);
    }

    await this.commentRepo.remove(comment);
    return true;
  }

  async incrementLikesCount(commentId: number): Promise<void> {
    await this.commentRepo.increment({ id: commentId }, 'likesCount', 1);
  }

  async decrementLikesCount(commentId: number): Promise<void> {
    await this.commentRepo.decrement({ id: commentId }, 'likesCount', 1);
  }

  async incrementDislikesCount(commentId: number): Promise<void> {
    await this.commentRepo.increment({ id: commentId }, 'dislikesCount', 1);
  }

  async decrementDislikesCount(commentId: number): Promise<void> {
    await this.commentRepo.decrement({ id: commentId }, 'dislikesCount', 1);
  }

  async incrementRepliesCount(commentId: number): Promise<void> {
    await this.commentRepo.increment({ id: commentId }, 'repliesCount', 1);
  }

  async decrementRepliesCount(commentId: number): Promise<void> {
    await this.commentRepo.decrement({ id: commentId }, 'repliesCount', 1);
  }
}

---


### FILE: src/comments/comments.controller.ts ###
import {
  Controller,
  Get,
  Post as HttpPost,
  Patch,
  Delete,
  Param,
  Body,
  UseGuards,
  Query,
  NotFoundException, // Added
} from '@nestjs/common';
import { CommentsService } from './comments.service';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UpdateCommentDto } from './dto/update-comment.dto';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { OptionalJwtAuthGuard } from 'src/auth/guards/optional-jwt-auth.guard'; // Added
import { Action } from 'src/casl/casl.types';
import { Comment } from './entities/comment.entity';
// Removed CommentPipe
import { Post as PostEntity } from 'src/posts/entities/post.entity';
import { PostPipe } from 'src/posts/pipes/post.pipe';
import { CaslService } from 'src/casl/casl.service';
import { CommentResponseDto } from './dto/comment-response.dto';
import { CommentQueryDto } from './dto/comment-query.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { ResponseDto } from 'src/common/dto/response.dto';
import { CommentPipe } from './pipes/comment.pipe';

@Controller()
export class CommentsController {
  constructor(
    private readonly commentsService: CommentsService,
    private readonly caslService: CaslService,
  ) { }

  @Get('comments')
  @UseGuards(OptionalJwtAuthGuard) // Add guard to get user
  async findAll(@Query() query: CommentQueryDto, @GetUser() user: User): Promise<PaginatedResponseDto<CommentResponseDto>> {
    const { data, count } = await this.commentsService.findAll(
    { page: query.page,
      limit :query.limit,
      search :query.search,
      authorId :query.authorId,
      currentUserId: user?.id, // Pass currentUserId
    }
    );

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(CommentResponseDto.fromEntity), paginationMeta);
  }

  @Get('posts/:postId/comments')
  @UseGuards(OptionalJwtAuthGuard) // Add guard to get user
  async findByPost(
    @Param('postId', PostPipe) post: PostEntity,
    @Query() query: CommentQueryDto,
    @GetUser() user: User, // Get current user
  ): Promise<PaginatedResponseDto<CommentResponseDto>> {
    const { data, count } = await this.commentsService.findAll(
      {
        postId: post.id,
        page: query.page,
        limit: query.limit,
        currentUserId: user?.id, // Pass currentUserId
        parentId: query.parentId,
      }
    );

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );
    
    return new PaginatedResponseDto(data.map(CommentResponseDto.fromEntity), paginationMeta);
  }

  @HttpPost('posts/:postId/comments')
  @UseGuards(JwtAuthGuard)
  async createForPost(
    @Param('postId', PostPipe) post: PostEntity,
    @Body() dto: CreateCommentDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommentResponseDto>> {
    this.caslService.enforce(user, Action.Create, Comment);
    const comment = await this.commentsService.createComment(
      post.id,
      dto.content,
      user.id,
      dto.parentId,
    );
    return new ResponseDto(CommentResponseDto.fromEntity(comment));
  }

  @Get('comments/:id')
  @UseGuards(OptionalJwtAuthGuard) // Add guard to get user
  async findOne(
    @Param('id') id: number, // Get id directly
    @GetUser() user: User, // Get current user
  ): Promise<ResponseDto<CommentResponseDto>> {
    const comment = await this.commentsService.findOne(id, user?.id); // Call service method
    if (!comment) {
      throw new NotFoundException('Comment not found');
    }
    return new ResponseDto(CommentResponseDto.fromEntity(comment));
  }

  @Patch('comments/:id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', CommentPipe) comment: Comment,
    @Body() dto: UpdateCommentDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommentResponseDto>> {
    this.caslService.enforce(user, Action.Update, comment);
    const updatedComment = await this.commentsService.update(
      {
        id: comment.id,
        content: dto.content,
      }
    );
    return new ResponseDto(CommentResponseDto.fromEntity(updatedComment));
  }

  @Delete('comments/:id')
  @UseGuards(JwtAuthGuard)
  async remove(
    @Param('id', CommentPipe) comment: Comment,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, comment);
    const success = await this.commentsService.remove(comment.id);
    return new ResponseDto(success);
  }
}


---


### FILE: src/comments/entities/comment.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  OneToMany,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { ReactionType } from 'src/reactions/reactions.types';
import { CommentReport } from '../../reports/entities/comment-report.entity';

@Entity('comments')
export class Comment {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  content: string;

  @ManyToOne(() => Post, (post) => post.comments, { onDelete: 'CASCADE' })
  post: Post;

  @ManyToOne(() => User, (user) => user.comments, {
    nullable: false,
    onDelete: 'CASCADE',
  })
  author: User;
  // FK explicite
  @Column()
  authorId: number;

  @ManyToOne(() => Comment, (comment) => comment.replies, {
    nullable: true,
    onDelete: 'CASCADE',
  })
  parent: Comment;

 @Column({nullable :true})
  parentId: number;

  @OneToMany(() => Comment, (comment) => comment.parent)
  replies: Comment[];

  @OneToMany(() => CommentReaction, (reaction) => reaction.comment)
  reactions: CommentReaction[];

  @Column({ default: 0 })
  likesCount: number;

  @Column({ default: 0 })
  dislikesCount: number;

  @Column({ default: 0 })
  repliesCount: number;

  @OneToMany(() => CommentReport, (commentReport) => commentReport.comment)
  reports: CommentReport[];

  userReaction?: { id: number; type: ReactionType };

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @DeleteDateColumn()
  deletedAt: Date;
}

---


### FILE: src/comments/comments.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Comment } from './entities/comment.entity';
import { CommentsService } from './comments.service';
import { CommentsController } from './comments.controller';
import { PostsModule } from 'src/posts/posts.module';
import { CaslModule } from 'src/casl/casl.module';
import { CommunitiesModule } from 'src/communities/communities.module';
import { CommunityMembership } from 'src/community-memberships/entities/community-membership.entity';
import { CommunityAccessModule } from 'src/community-access/community-access.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([Comment]),
    PostsModule,
    CaslModule,
    CommunitiesModule,
    CommunityAccessModule
    
  ],
  providers: [CommentsService],
  controllers: [CommentsController],
  exports: [CommentsService],
})
export class CommentsModule {}

---


### FILE: src/comments/dto/comment-response.dto.ts ###
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { Comment } from '../entities/comment.entity';
import { CommentReaction } from 'src/reactions/entities/comment-reaction.entity';
import { ReactionResponseDto } from 'src/reactions/dto/reaction-response.dto';

@Exclude()
export class CommentResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly content: string;
  @Expose() readonly createdAt: Date;
  @Expose() readonly updatedAt: Date;

  @Expose() @Type(() => UserResponseDto) readonly author: UserResponseDto;
  @Expose() readonly postId: number;
  @Expose() readonly parentId?: number;
  @Expose() readonly likesCount: number;
  @Expose() readonly dislikesCount: number;
  @Expose() readonly repliesCount: number;
  @Expose() @Type(() => ReactionResponseDto)
  readonly userReaction?: ReactionResponseDto | null;
  @Expose()
  @Type(() => CommentResponseDto)
  readonly replies?: CommentResponseDto[];

  static fromEntity(entity: Comment & { userReaction?: any }): CommentResponseDto {
    return plainToInstance(
      CommentResponseDto,
      {
        ...entity,
        author: entity.author
          ? UserResponseDto.fromEntity(entity.author)
          : null,
        replies:
          entity.replies?.map((r) => CommentResponseDto.fromEntity(r)) ?? [],
        userReaction: entity.userReaction
          ? ReactionResponseDto.fromEntity(entity.userReaction)
          : null,
      },
      { excludeExtraneousValues: true },
    );
  }
}

---


### FILE: src/comments/dto/comment-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsString, IsInt } from 'class-validator';
import { Type } from 'class-transformer';

export class CommentQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  search?: string; // Filter by content

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  authorId?: number;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  parentId?: number;
  }

---


### FILE: src/comments/dto/create-comment.dto.ts ###
import { IsNotEmpty, IsInt, IsOptional } from 'class-validator';

export class CreateCommentDto {
  @IsNotEmpty()
  content: string;

  // Add the optional parent ID
  @IsOptional()
  @IsInt()
  parentId?: number;
}

---


### FILE: src/comments/dto/update-comment.dto.ts ###
import { PartialType } from '@nestjs/mapped-types';
import { CreateCommentDto } from './create-comment.dto';

export class UpdateCommentDto extends PartialType(CreateCommentDto) {}

---

