

--- CONFIGURATION FILES ---


### FILE: package.json ###
{
  "name": "my-app",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "typeorm": "ts-node -r tsconfig-paths/register ./node_modules/typeorm/cli.js",
    "migration:generate": "npm run typeorm -- migration:generate -d ./src/data-source.ts",
    "migration:run": "npm run typeorm -- migration:run -d ./src/data-source.ts",
    "migration:revert": "npm run typeorm -- migration:revert -d ./src/data-source.ts",
    "seed": "ts-node src/database/seeds/index.ts",
    "db:drop": "npm run typeorm -- schema:drop -d ./src/data-source.ts"
  },
  "dependencies": {
    "@nestjs/common": "^11.0.1",
    "@nestjs/core": "^11.0.1",
    "@nestjs/mapped-types": "^2.1.0",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/typeorm": "^11.0.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.3",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "sqlite3": "^5.1.7",
    "typeorm": "^0.3.27"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@faker-js/faker": "^10.1.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

---

### FILE: nest-cli.json ###
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

---

### FILE: tsconfig.json ###
{
  "compilerOptions": {
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "resolvePackageJsonExports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}

---

### FILE: src/app.controller.ts ###
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

---


### FILE: src/database/seeds/post.seed.ts ###
import { AppDataSource } from '../../data-source';
import { postFactory } from '../factories/post.factory';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';

export async function seedPosts(users: User[]) {
  await AppDataSource.initialize();
  const postRepo = AppDataSource.getRepository(Post);

  const posts: Post[] = Array.from({ length: 10 }).map(() => {
    const author = users[Math.floor(Math.random() * users.length)];
    return postFactory(author);
  });

  await postRepo.save(posts);
  console.log('Seeded 10 posts ✅');

  await AppDataSource.destroy();
  return posts;
}

if (require.main === module) seedPosts([]);

---


### FILE: src/database/seeds/reaction.seed.ts ###
import { AppDataSource } from '../../data-source';
import { reactionFactory } from '../factories/reaction.factory';
import { Reaction } from '../../reactions/entities/reaction.entity';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';

/**
 * Seed Reactions for given posts and comments using provided users
 */
export async function seedReactions(posts: Post[], comments: Comment[], users: User[]): Promise<Reaction[]> {
  if (!users.length) {
    throw new Error('At least one user is required to seed reactions.');
  }

  await AppDataSource.initialize();
  const reactionRepo = AppDataSource.getRepository(Reaction);
  const reactions: Reaction[] = [];

  // Generate Reactions for Posts (1-3 reactions per post)
  posts.forEach(post => {
    const numReactions = Math.floor(Math.random() * 3) + 1; 
    for (let i = 0; i < numReactions; i++) {
      // Pick a random user
      const user = users[Math.floor(Math.random() * users.length)];
      reactions.push(reactionFactory(user, post, undefined));
    }
  });

  // Generate Reactions for Comments (1-2 reactions per comment)
  comments.forEach(comment => {
    const numReactions = Math.floor(Math.random() * 2) + 1; 
    for (let i = 0; i < numReactions; i++) {
      const user = users[Math.floor(Math.random() * users.length)];
      reactions.push(reactionFactory(user, undefined, comment));
    }
  });

  await reactionRepo.save(reactions);
  console.log(`Seeded ${reactions.length} reactions ✅`);

  await AppDataSource.destroy();
  return reactions;
}


---


### FILE: src/database/seeds/user.seed.ts ###
import { AppDataSource } from '../../data-source';
import { userFactory } from '../factories/user.factory';
import { User } from '../../users/entities/user.entity';

export async function seedUsers() {
  await AppDataSource.initialize();
  const userRepo = AppDataSource.getRepository(User);

  const users: User[] = Array.from({ length: 5 }).map(() => userFactory());

  await userRepo.save(users);
  console.log('Seeded 5 users ✅');

  await AppDataSource.destroy();
  return users;
}

if (require.main === module) seedUsers();

---


### FILE: src/database/seeds/comment.seed.ts ###
import { AppDataSource } from '../../data-source';
import { commentFactory } from '../factories/comment.factory';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';

export async function seedComments(users: User[], posts: Post[]) {
  await AppDataSource.initialize();
  const commentRepo = AppDataSource.getRepository(Comment);

  const comments: Comment[] = Array.from({ length: 30 }).map(() => {
    const author = users[Math.floor(Math.random() * users.length)];
    const post = posts[Math.floor(Math.random() * posts.length)];
    return commentFactory(author, post);
  });

  await commentRepo.save(comments);
  console.log('Seeded 30 comments ✅');

  await AppDataSource.destroy();
    return comments; // <-- important!
}

if (require.main === module) seedComments([], []);

---


### FILE: src/database/seeds/index.ts ###
import { seedUsers } from './user.seed';
import { seedPosts } from './post.seed';
import { seedComments } from './comment.seed';
import { seedReactions } from './reaction.seed'; // <-- if you want to seed reactions

async function main() {
  try {
    // Seed users
    const users = await seedUsers();

    // Seed posts
    const posts = await seedPosts(users);

    // Seed comments
    const comments = await seedComments(users, posts);

    // Seed reactions (optional)
    await seedReactions(posts, comments, users);

    console.log('Database seeding complete ✅');
  } catch (error) {
    console.error('Seeding failed ❌', error);
  } finally {
    // Optional: ensure datasource is destroyed if needed
    // await AppDataSource.destroy();
  }
}

main();

---


### FILE: src/database/factories/reaction.factory.ts ###
import { Reaction, ReactionType } from '../../reactions/entities/reaction.entity';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity'; // <-- ADDED USER IMPORT
import { faker } from '@faker-js/faker';

/**
 * Creates a Reaction object. Requires a User (user) and either a Post or a Comment target.
 */
export function reactionFactory(user: User, post?: Post, comment?: Comment): Reaction {
  if (!post && !comment) {
    throw new Error('Reaction factory must be called with a Post or a Comment.');
  }

  const reaction = new Reaction();
  
  // Assign the reaction author
  reaction.user = user;

  // Randomly assign a reaction type
  const types = Object.values(ReactionType);
  reaction.type = faker.helpers.arrayElement(types);

  // Assign the target entity (polymorphism via nullable columns)
  reaction.post = post ?? null;
  reaction.comment = comment ?? null;

  return reaction;
}

---


### FILE: src/database/factories/user.factory.ts ###
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';

export function userFactory(): User {
  const user = new User();
  user.name = faker.person.fullName();
  user.email = faker.internet.email();
  return user;
}

---


### FILE: src/database/factories/post.factory.ts ###
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';

export function postFactory(author: User): Post {
  const post = new Post();
  post.title = faker.lorem.sentence();
  post.content = faker.lorem.paragraph();
  post.author = author;
  return post;
}

---


### FILE: src/database/factories/comment.factory.ts ###
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';
import { faker } from '@faker-js/faker';

export function commentFactory(author: User, post: Post): Comment {
  const comment = new Comment();
  comment.content = faker.lorem.sentence();
  comment.author = author;
  comment.post = post;
  return comment;
}

---


### FILE: src/main.ts ###
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe({ whitelist: true ,
      transform: true, // auto-convert types
       transformOptions: {
    enableImplicitConversion: true, // <--- This is the key
  },
  }));

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

---


### FILE: src/users/entities/user.entity.ts ###
import { Entity, PrimaryGeneratedColumn, Column, OneToMany } from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { Reaction } from '../../reactions/entities/reaction.entity';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column({ unique: true })
  email: string;

  @OneToMany(() => Post, post => post.author)
  posts: Post[];

  @OneToMany(() => Comment, comment => comment.author)
  comments: Comment[];

  // --- NEW FIELD FOR REACTIONS ---
  @OneToMany(() => Reaction, reaction => reaction.user) // <-- ADD THIS FIELD
  reactions: Reaction[];
}

---


### FILE: src/reactions/reactions.controller.ts ###
import { Controller, Post, Get, Body, Param, Delete } from '@nestjs/common';
import { ReactionsService } from './reactions.service';
import { CreateReactionDto } from './dto/create-reaction.dto';
import { User } from 'src/users/entities/user.entity';

@Controller()
export class ReactionsController {
  constructor(private readonly reactionsService: ReactionsService) { }

  // -----------------------------
  // Reactions for Posts
  // -----------------------------
  @Post('posts/:postId/reactions')
  createPostReaction(
    @Param('postId') postId: number,
    @Body() dto: CreateReactionDto
  ) {
    // Combine DTO with route param
// Return a mock user for testing
    const user = new User();
    user.id = 1;
    user.name = 'Mock User';
    user.email = 'mock@example.com';
      return this.reactionsService.create({ dto,user ,postId });
  }

  @Get('posts/:postId/reactions')
  getPostReactions(@Param('postId') postId: number) {
    return this.reactionsService.findByPost(postId);
  }

  // -----------------------------
  // Reactions for Comments
  // -----------------------------
  @Post('comments/:commentId/reactions')
  createCommentReaction(
    @Param('commentId') commentId: number,
    @Body() dto: CreateReactionDto
  ) {
// Return a mock user for testing
    const user = new User();
    user.id = 1;
    user.name = 'Mock User';
    user.email = 'mock@example.com';
    return this.reactionsService.create({ dto,user ,commentId });
   }

  @Get('comments/:commentId/reactions')
  getCommentReactions(@Param('commentId') commentId: number) {
    return this.reactionsService.findByComment(commentId);
  }

  @Delete('reactions/:reactionId')
  deleteReaction(@Param('reactionId') reactionId: number) {
    
    return this.reactionsService.delete( reactionId );
  }
}

---


### FILE: src/reactions/reactions.service.ts ###
// src/reactions/reactions.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Reaction } from './entities/reaction.entity';
import { CreateReactionDto } from './dto/create-reaction.dto';
import { User } from '../users/entities/user.entity';

@Injectable()
export class ReactionsService {
  constructor(
    @InjectRepository(Reaction)
    private readonly repo: Repository<Reaction>,
  ) { }

  /**
   * Create a reaction using named arguments (PHP-style)
   */
  async create({
    dto,
    user,
    postId,
    commentId,
  }: {
    dto: CreateReactionDto;
    user: User;
    postId?: number;
    commentId?: number;
  }): Promise<Reaction> {
    if (!postId && !commentId) {
      throw new NotFoundException('Reaction must target a post or a comment.');
    }
// First check if user already reacted to this target
const existing = await this.repo.findOne({
  where: {
    user: { id: user.id },
    ...(postId ? { post: { id: postId } } : { comment: { id: commentId } }),
  },
});

if (existing) {
  if (existing.type === dto.type) {
    // same type → remove (toggle off)
    return await this.repo.remove(existing);
  } else {
    // different type → update
    existing.type = dto.type;
    return this.repo.save(existing);
  }
}

// else create new
    const reaction = this.repo.create({
      type: dto.type,
      user,
      post: postId ? { id: postId } : undefined,
      comment: commentId ? { id: commentId } : undefined,
    });

    return this.repo.save(reaction);
  }

  findByPost(postId: number) {
    return this.repo.find({
      where: { post: { id: postId } },
      relations: ['post', 'comment', 'user'],
    });
  }

  findByComment(commentId: number) {
    return this.repo.find({
      where: { comment: { id: commentId } },
      relations: ['post', 'comment', 'user'],
    });
  }

  async delete(

    reactionId: number): Promise<void> {
    const reaction = await this.repo.findOne({
      where: { id: reactionId },
      relations: ['user', 'post', 'comment'],
    });

    if (!reaction) {
      throw new NotFoundException('Reaction not found');
    }



    await this.repo.remove(reaction);
  }
}

---


### FILE: src/reactions/reactions.module.ts ###
import { Module } from '@nestjs/common';
import { ReactionsService } from './reactions.service';
import { ReactionsController } from './reactions.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Reaction } from './entities/reaction.entity';

@Module({
  providers: [ReactionsService],
  controllers: [ReactionsController] ,
  imports: [TypeOrmModule.forFeature([Reaction])],
})
export class ReactionsModule {}

---


### FILE: src/reactions/entities/reaction.entity.ts ###
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';

export enum ReactionType {
  LIKE = 'like',
  DISLIKE = 'dislike',
}

@Entity()
export class Reaction {
  @PrimaryGeneratedColumn()
  id: number;

@Column({
  type: 'simple-enum',
  enum: ReactionType,
})
type: ReactionType;

  @ManyToOne(() => Post, { nullable: true })
  post?: Post | null;

  @ManyToOne(() => Comment, { nullable: true })
  comment?: Comment | null;

  @ManyToOne(() => User, user => user.reactions, { nullable: false, onDelete: 'CASCADE' })
  user: User; // <-- ADD THIS FIELD

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

---


### FILE: src/reactions/dto/update-reaction.dto.ts ###
import { PartialType } from '@nestjs/mapped-types';
import { CreateReactionDto } from './create-reaction.dto';

export class UpdateReactionDto extends PartialType(CreateReactionDto) {}

---


### FILE: src/reactions/dto/create-reaction.dto.ts ###
import { IsEnum } from 'class-validator';
import { ReactionType } from '../entities/reaction.entity';

export class CreateReactionDto {
  @IsEnum(ReactionType)
  type: ReactionType;
}

---


### FILE: src/posts/posts.module.ts ###
import { Module } from '@nestjs/common';
import { PostsService } from './posts.service';
import { PostsController } from './posts.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Post } from './entities/post.entity';

@Module({
    imports: [TypeOrmModule.forFeature([Post])],
  providers: [PostsService],
  controllers: [PostsController]
})
export class PostsModule {}

---


### FILE: src/posts/posts.service.ts ###
// posts/posts.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Post } from './entities/post.entity';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';

@Injectable()
export class PostsService {
  constructor(
    @InjectRepository(Post)
    private postsRepository: Repository<Post>,
  ) {}

  // load relations: author and comments
  findAll(): Promise<Post[]> {
    return this.postsRepository.find({
      relations: ['author', 'comments',"reactions"], // eager load related entities
    });
  }

  findOne(id: number): Promise<Post | null> {
    return this.postsRepository.findOne({
      where: { id },
      relations: ['author', 'comments','reactions'],
    });
  }

  create(createPostDto: CreatePostDto): Promise<Post> {
    const post = this.postsRepository.create(createPostDto);
    return this.postsRepository.save(post);
  }

  async update(id: number, updatePostDto: UpdatePostDto): Promise<Post | null> {
    await this.postsRepository.update(id, updatePostDto);
    return this.findOne(id); // return post with relations
  }

async remove(id: number): Promise<boolean> {
  const result = await this.postsRepository.delete(id);
  return !!result.affected; // converts undefined/null/0 to false, >0 to true
}
}

---


### FILE: src/posts/entities/post.entity.ts ###
import { Entity, PrimaryGeneratedColumn, Column, OneToMany, ManyToOne, CreateDateColumn, UpdateDateColumn, DeleteDateColumn } from 'typeorm';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { Reaction } from '../../reactions/entities/reaction.entity';

@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @Column()
  content: string;

  @ManyToOne(() => User, user => user.posts, { nullable: false, onDelete: 'CASCADE' })
  author: User;

  @OneToMany(() => Comment, comment => comment.post)
  comments: Comment[];

  @Column({ default: 0 })
  views: number;

  @OneToMany(() => Reaction, reaction => reaction.post)
reactions: Reaction[];


  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @DeleteDateColumn()
  deletedAt: Date;
}

---


### FILE: src/posts/posts.controller.ts ###
// posts/posts.controller.ts
import { Controller, Get, Post, Body, Param, Patch, Delete, ParseIntPipe } from '@nestjs/common';
import { PostsService } from './posts.service';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';
import type { Post as PostType } from './entities/post.entity';

@Controller('posts')
export class PostsController {
  constructor(private readonly postsService: PostsService) {}

  @Get()
  findAll(): Promise<PostType[]> {
    return this.postsService.findAll();
  }

  @Get(':id')
  findOne(@Param('id', ParseIntPipe) id: number): Promise<PostType | null> {
    return this.postsService.findOne(id);
  }

  @Post()
  create(@Body() createPostDto: CreatePostDto): Promise<PostType> {
    return this.postsService.create(createPostDto);
  }

  @Patch(':id')
  update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updatePostDto: UpdatePostDto,
  ): Promise<PostType | null> {
    return this.postsService.update(id, updatePostDto);
  }

  @Delete(':id')
  remove(@Param('id', ParseIntPipe) id: number): Promise<{ deleted: boolean }> {
    return this.postsService.remove(id).then(deleted => ({ deleted }));
  }
}

---


### FILE: src/posts/dto/update-post.dto.ts ###
export class UpdatePostDto {
  title?: string;
  content?: string;
}

---


### FILE: src/posts/dto/create-post.dto.ts ###
import { IsString, IsNotEmpty, IsInt } from 'class-validator';

export class CreatePostDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  @IsNotEmpty()
  content: string;

  @IsInt()
  authorId: number;
}

---


### FILE: src/app.service.ts ###
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return '<h1>Hello World!';
  }
}

---


### FILE: src/migrations/1764720178421-inital.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class Inital1764720178421 implements MigrationInterface {
    name = 'Inital1764720178421'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "user" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar NOT NULL, "email" varchar NOT NULL, CONSTRAINT "UQ_e12875dfb3b1d92d7d7c5377e22" UNIQUE ("email"))`);
        await queryRunner.query(`CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL)`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL)`);
        await queryRunner.query(`CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "comment"`);
        await queryRunner.query(`DROP TABLE "comment"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment" RENAME TO "comment"`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`ALTER TABLE "comment" RENAME TO "temporary_comment"`);
        await queryRunner.query(`CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL)`);
        await queryRunner.query(`INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "temporary_comment"`);
        await queryRunner.query(`DROP TABLE "temporary_comment"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`DROP TABLE "comment"`);
        await queryRunner.query(`DROP TABLE "user"`);
    }

}

---


### FILE: src/migrations/1764783033004-AddReactions.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddReactions1764783033004 implements MigrationInterface {
    name = 'AddReactions1764783033004'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL)`);
        await queryRunner.query(`CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "comment"`);
        await queryRunner.query(`DROP TABLE "comment"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment" RENAME TO "comment"`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
        await queryRunner.query(`CREATE TABLE "temporary_reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_e58a09ab17e3ce4c47a1a330ae1" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "reaction"`);
        await queryRunner.query(`DROP TABLE "reaction"`);
        await queryRunner.query(`ALTER TABLE "temporary_reaction" RENAME TO "reaction"`);
        await queryRunner.query(`CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`);
        await queryRunner.query(`DROP TABLE "comment"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment" RENAME TO "comment"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "comment" RENAME TO "temporary_comment"`);
        await queryRunner.query(`CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`);
        await queryRunner.query(`DROP TABLE "temporary_comment"`);
        await queryRunner.query(`ALTER TABLE "reaction" RENAME TO "temporary_reaction"`);
        await queryRunner.query(`CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL)`);
        await queryRunner.query(`INSERT INTO "reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "temporary_reaction"`);
        await queryRunner.query(`DROP TABLE "temporary_reaction"`);
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`ALTER TABLE "comment" RENAME TO "temporary_comment"`);
        await queryRunner.query(`CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "temporary_comment"`);
        await queryRunner.query(`DROP TABLE "temporary_comment"`);
        await queryRunner.query(`DROP TABLE "reaction"`);
    }

}

---


### FILE: src/app.module.ts ###
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PostsModule } from './posts/posts.module';
import { Post } from './posts/entities/post.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CommentsModule } from './comments/comments.module';
import { User } from './users/entities/user.entity';
import { Comment } from './comments/entities/comment.entity';
import { ReactionsModule } from './reactions/reactions.module';
import { Reaction } from './reactions/entities/reaction.entity';

@Module({
  imports: [PostsModule,TypeOrmModule.forRoot({
      type: 'sqlite',
      database: 'forum.db',
  entities: [User, Post, Comment,Reaction],  // <-- include ALL entities  migrations: ['./src/migrations/*.ts'], // <-- migration folder
      synchronize: false,     })
      , CommentsModule, ReactionsModule,],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

---


### FILE: src/data-source.ts ###
import { DataSource } from 'typeorm';
import { Post } from './posts/entities/post.entity';
import { User } from './users/entities/user.entity';
import { Comment } from './comments/entities/comment.entity';
import { Reaction } from './reactions/entities/reaction.entity';

export const AppDataSource = new DataSource({
  type: 'sqlite',
  database: 'forum.db',
  entities: [User, Post, Comment,Reaction],  // <-- include ALL entities  migrations: ['./src/migrations/*.ts'], // <-- migration folder
  synchronize: false,                   // never auto-sync in production

  migrations: ['src/migrations/*.ts'],
});

---


### FILE: src/comments/comments.service.ts ###
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Comment } from './entities/comment.entity';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UpdateCommentDto } from './dto/update-comment.dto';

@Injectable()
export class CommentsService {
  constructor(
    @InjectRepository(Comment)
    private readonly commentRepo: Repository<Comment>,
  ) {}

  findByPost(postId: number) {
    return this.commentRepo.find({
      where: { post: { id: postId } },
      relations: ['author', 'post'],
    });
  }

  findOne(id: number) {
    return this.commentRepo.findOne({
      where: { id },
      relations: ['author', 'post'],
    });
  }

// src/comments/comments.service.ts (Conceptual Merge)
async create(
    postId: number,
    dto: CreateCommentDto & { parentId?: number }, // allow parentId in body
    authorId: number, // will come from @CurrentUser() later
  ): Promise<Comment> {

    const comment = this.commentRepo.create({
      content: dto.content,
      author: { id: authorId },
    });

    if (dto.parentId) {
      // This is a reply → find parent to get post and link hierarchy
      const parentComment = await this.commentRepo.findOne({
        where: { id: dto.parentId },
        relations: ['post'],
      });

      if (!parentComment) {
        throw new NotFoundException('Parent comment not found');
      }

      if (parentComment.post.id !== postId) {
        throw new NotFoundException('Parent comment does not belong to this post');
      }

      comment.parent = parentComment;
      comment.post = parentComment.post; // inherit post from parent
    }

    return this.commentRepo.save(comment);
  }


  async update(id: number, updateCommentDto: UpdateCommentDto) {
    await this.commentRepo.update(id, updateCommentDto);
    return this.findOne(id);
  }

  async remove(id: number): Promise<boolean> {
    const result = await this.commentRepo.delete(id);
    return !!result.affected;
  }
}

---


### FILE: src/comments/comments.controller.ts ###
import { Controller, Get, Post, Patch, Delete, Param, Body } from '@nestjs/common';
import { CommentsService } from './comments.service';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UpdateCommentDto } from './dto/update-comment.dto';

@Controller()
export class CommentsController {
  constructor(private readonly commentsService: CommentsService) {}

  @Get('posts/:postId/comments')
  findByPost(@Param('postId') postId: string) {
    return this.commentsService.findByPost(+postId);
  }

  @Post('posts/:postId/comments')
  createForPost(
    @Param('postId') postId: string,
    @Body() createCommentDto: CreateCommentDto,
  ) {
    return this.commentsService.createForPost(+postId, createCommentDto);
  }

  @Get('comments/:id')
  findOne(@Param('id') id: string) {
    return this.commentsService.findOne(+id);
  }

  @Patch('comments/:id')
  update(@Param('id') id: string, @Body() updateCommentDto: UpdateCommentDto) {
    return this.commentsService.update(+id, updateCommentDto);
  }

  @Delete('comments/:id')
  remove(@Param('id') id: string) {
    return this.commentsService.remove(+id);
  }
}

---


### FILE: src/comments/entities/comment.entity.ts ###
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, CreateDateColumn, UpdateDateColumn, DeleteDateColumn, OneToMany } from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { Reaction } from '../../reactions/entities/reaction.entity';

@Entity()
export class Comment {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  content: string;

  @ManyToOne(() => Post, post => post.comments, { onDelete: 'CASCADE' })
  post: Post;

  @ManyToOne(() => User, user => user.comments, { nullable: false, onDelete: 'CASCADE' })
  author: User;

  @ManyToOne(() => Comment, comment => comment.replies, { nullable: true, onDelete: 'CASCADE' })
  parent: Comment;

  @OneToMany(() => Comment, comment => comment.parent)
  replies: Comment[];

  @OneToMany(() => Reaction, reaction => reaction.comment)
reactions: Reaction[];


  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @DeleteDateColumn()
  deletedAt: Date;
}

---


### FILE: src/comments/comments.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Comment } from './entities/comment.entity';
import { CommentsService } from './comments.service';
import { CommentsController } from './comments.controller';

@Module({
  imports: [TypeOrmModule.forFeature([Comment])],
  providers: [CommentsService],
  controllers: [CommentsController],
})
export class CommentsModule {}

---


### FILE: src/comments/dto/create-comment.dto.ts ###
import { IsNotEmpty, IsInt, IsOptional } from 'class-validator';

export class CreateCommentDto {
  @IsNotEmpty()
  content: string;

  @IsInt()
  authorId: number;

  // Add the optional parent ID
  @IsOptional()
  @IsInt()
  parentId?: number;
}

---


### FILE: src/comments/dto/update-comment.dto.ts ###
import { PartialType } from '@nestjs/mapped-types';
import { CreateCommentDto } from './create-comment.dto';

export class UpdateCommentDto extends PartialType(CreateCommentDto) {}

---

