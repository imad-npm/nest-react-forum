

--- CONFIGURATION FILES ---


--- BACKEND SOURCE ---


### FILE: backend/src/app.controller.ts ###
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

---


### FILE: backend/src/database/seeds/post.seed.ts ###
import { postFactory } from '../factories/post.factory';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity'; // Import Community entity
import { AppDataSource } from '../../data-source';

export async function seedPosts(users: User[], communities: Community[]) {
  const postRepo = AppDataSource.getRepository(Post);

  const posts: Post[] = Array.from({ length: 30 }).map(() => {
    const author = users[Math.floor(Math.random() * users.length)];
    const community = communities[Math.floor(Math.random() * communities.length)]; // Select a random community
    return postFactory(author, community);
  });

  await postRepo.save(posts);
  console.log('Seeded 30 posts ‚úÖ');

  return posts;
}

if (require.main === module) seedPosts([], []);

---


### FILE: backend/src/database/seeds/reaction.seed.ts ###
import { AppDataSource } from '../../data-source';
import { postReactionFactory } from '../factories/post-reaction.factory';
import { commentReactionFactory } from '../factories/comment-reaction.factory';

import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
export async function seedReactions(
  posts: Post[],
  comments: Comment[],
  users: User[],
): Promise<(PostReaction | CommentReaction)[]> {
  if (!users.length) {
    throw new Error('At least one user is required to seed reactions.');
  }

  const postReactionRepo = AppDataSource.getRepository(PostReaction);
  const commentReactionRepo = AppDataSource.getRepository(CommentReaction);
  const postRepo = AppDataSource.getRepository(Post);
  const commentRepo = AppDataSource.getRepository(Comment);

  const postReactionsToSave: PostReaction[] = [];
  const commentReactionsToSave: CommentReaction[] = [];

  const pickRandomUniqueUsers = (count: number): User[] => {
    const unique = new Set<number>();
    const picked: User[] = [];

    while (unique.size < count && unique.size < users.length) {
      const user = users[Math.floor(Math.random() * users.length)];
      if (!unique.has(user.id)) {
        unique.add(user.id);
        picked.push(user);
      }
    }
    return picked;
  };

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // POSTS
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (const post of posts) {
    const num = Math.floor(Math.random() * 3) + 1;
    for (const user of pickRandomUniqueUsers(num)) {
      postReactionsToSave.push(postReactionFactory(user, post));
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // COMMENTS
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (const comment of comments) {
    const num = Math.floor(Math.random() * 2) + 1;
    for (const user of pickRandomUniqueUsers(num)) {
      commentReactionsToSave.push(commentReactionFactory(user, comment));
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SAVE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const savedPostReactions = await postReactionRepo.save(postReactionsToSave);
  const savedCommentReactions = await commentReactionRepo.save(
    commentReactionsToSave,
  );

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üîÅ REBUILD COUNTERS (THE IMPORTANT PART)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // POSTS
  await postRepo
    .createQueryBuilder()
    .update(Post)
    .set({
      likesCount: () => `
        (
          SELECT COUNT(*)
          FROM post_reactions pr
          WHERE pr.postId = posts.id
            AND pr.type = 'like'
        )
      `,
      dislikesCount: () => `
        (
          SELECT COUNT(*)
          FROM post_reactions pr
          WHERE pr.postId = posts.id
            AND pr.type = 'dislike'
        )
      `,
    })
    .execute();

  // COMMENTS
  await commentRepo
    .createQueryBuilder()
    .update(Comment)
    .set({
      likesCount: () => `
        (
          SELECT COUNT(*)
          FROM comment_reactions cr
          WHERE cr.commentId = comments.id
            AND cr.type = 'like'
        )
      `,
      dislikesCount: () => `
        (
          SELECT COUNT(*)
          FROM comment_reactions cr
          WHERE cr.commentId = comments.id
            AND cr.type = 'dislike'
        )
      `,
    })
    .execute();

  const all = [...savedPostReactions, ...savedCommentReactions];
  console.log(`Seeded ${all.length} reactions ‚úÖ`);
  console.log(`Rebuilt like/dislike counters ‚úÖ`);

  return all;
}

---


### FILE: backend/src/database/seeds/user.seed.ts ###
import { AppDataSource } from '../../data-source';
import { userFactory } from '../factories/user.factory';
import { User } from '../../users/entities/user.entity';
import * as bcrypt from 'bcrypt';
import { faker } from '@faker-js/faker';

export async function seedUsers() {
  const userRepo = AppDataSource.getRepository(User);

  const users: User[] = Array.from({ length: 6 }).map(() => {
    return userFactory();
  });

  // Handle the special 'testuser'
  const testUser = new User();
  testUser.username = 'testuser';
  testUser.email = 'test@example.com';
  testUser.password = bcrypt.hashSync('password123', 10);
  testUser.emailVerifiedAt = new Date();

  users.push(testUser);

  await Promise.all(
    users.map(async (user) => {
      await userRepo.save(user); // Save user
    }),
  );

  console.log(`Seeded ${users.length} users ‚úÖ`);

  return users;
}

if (require.main === module) seedUsers();

---


### FILE: backend/src/database/seeds/community-restriction.seed.ts ###
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';
import { CommunityRestriction } from '../../community-restrictions/entities/community-restriction.entity';
import { communityRestrictionFactory } from '../factories/community-restriction.factory';
import { AppDataSource } from '../../data-source';

export async function seedCommunityRestrictions(
  users: User[],
  communities: Community[],
): Promise<CommunityRestriction[]> {
  const restrictions: CommunityRestriction[] = [];
  const communityRestrictionRepository = AppDataSource.getRepository(CommunityRestriction);

  for (const community of communities) {
    const bannedUser = users.find((user) => user.id !== community.ownerId);
    const creatorUser = users[Math.floor(Math.random() * users.length)];

    if (bannedUser && creatorUser) {
      const restriction = communityRestrictionFactory(
        bannedUser,
        community,
        creatorUser,
      );
      restrictions.push(restriction);
    }
  }

  return communityRestrictionRepository.save(restrictions);
}

---


### FILE: backend/src/database/seeds/comment.seed.ts ###
import { AppDataSource } from '../../data-source';
import { commentFactory } from '../factories/comment.factory';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';

export async function seedComments(users: User[], posts: Post[]) {
  const commentRepo = AppDataSource.getRepository(Comment);
  const postRepo = AppDataSource.getRepository(Post);

  // 1. Create initial top-level comments
  const topLevelComments: Comment[] = [];
  for (let i = 0; i < 300; i++) {
    const author = users[Math.floor(Math.random() * users.length)];
    const post = posts[Math.floor(Math.random() * posts.length)];
    topLevelComments.push(commentFactory(author, post));
  }
  await commentRepo.save(topLevelComments);
  console.log(`Seeded ${topLevelComments.length} top-level comments ‚úÖ`);

  // 2. Create replies to top-level comments
  const firstLevelReplies: Comment[] = [];
  for (let i = 0; i < topLevelComments.length / 2; i++) {
    const parentComment = topLevelComments[i];
    const numberOfReplies = Math.floor(Math.random() * 3) + 1; // 1 to 3 replies
    for (let j = 0; j < numberOfReplies; j++) {
      const author = users[Math.floor(Math.random() * users.length)];
      const post = parentComment.post;
      firstLevelReplies.push(commentFactory(author, post, parentComment.id));
    }
  }
  await commentRepo.save(firstLevelReplies);
  console.log(`Seeded ${firstLevelReplies.length} first-level replies ‚úÖ`);

  // 3. Create nested replies (replies to replies)
  const secondLevelReplies: Comment[] = [];
  for (let i = 0; i < firstLevelReplies.length / 3; i++) {
    const parentComment = firstLevelReplies[i];
    const numberOfReplies = Math.floor(Math.random() * 2) + 1; // 1 to 2 replies
    for (let j = 0; j < numberOfReplies; j++) {
      const author = users[Math.floor(Math.random() * users.length)];
      const post = parentComment.post;
      secondLevelReplies.push(commentFactory(author, post, parentComment.id));
    }
  }
  await commentRepo.save(secondLevelReplies);
  console.log(`Seeded ${secondLevelReplies.length} second-level replies ‚úÖ`);

  const allComments = [...topLevelComments, ...firstLevelReplies, ...secondLevelReplies];
  console.log(`Seeded total ${allComments.length} comments ‚úÖ`);

  // Efficiently update commentsCount for all posts using a single query
  await postRepo
    .createQueryBuilder()
    .update(Post)
    .set({
      commentsCount: () =>
        `(SELECT COUNT(*) FROM comments WHERE comments.postId = posts.id)`
    })
    .execute();

  console.log('Updated commentsCount for all posts efficiently ‚úÖ');

  await commentRepo
  .createQueryBuilder()
  .update(Comment)
  .set({
    repliesCount: () =>
      `(SELECT COUNT(*) FROM comments AS c2 WHERE c2.parentId = comments.id)`,
  })
  .execute();
  
  console.log('Updated repliesCount for all comments efficiently ‚úÖ');

  return allComments;
}

if (require.main === module) seedComments([], []);

---


### FILE: backend/src/database/seeds/community-memberships.seed.ts ###
import { AppDataSource } from '../../data-source';
import { communityMembershipFactory } from '../factories/community-memberships.factory';
import { CommunityMembership } from '../../community-memberships/entities/community-memberships.entity';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';
import { CommunityMembershipRole } from '../../community-memberships/types';


export async function seedCommunityMemberships(
  users: User[],
  communities: Community[],
): Promise<CommunityMembership[]> {
  const membershipRepo = AppDataSource.getRepository(CommunityMembership);
  const communityRepo = AppDataSource.getRepository(Community);

  const memberships: CommunityMembership[] = [];

  // Track next moderator rank per community
  const nextRankByCommunity = new Map<number, number>();

  for (const user of users) {
    const numMemberships = Math.floor(Math.random() * 3) + 1; // 1 to 3 communities
    const shuffled = [...communities].sort(() => 0.5 - Math.random());
    const toSubscribe = shuffled.slice(0, numMemberships);

    for (let i = 0; i < toSubscribe.length; i++) {
      const community = toSubscribe[i];
      const membership = communityMembershipFactory();
      membership.userId = user.id;
      membership.communityId = community.id;

      // First community for a user is always a moderator role
      if (i === 0) {
        membership.role = CommunityMembershipRole.MODERATOR;
        const nextRank = nextRankByCommunity.get(community.id) ?? 0;
        membership.rank = nextRank;
        nextRankByCommunity.set(community.id, nextRank + 1);
      } else {
        membership.role = CommunityMembershipRole.MEMBER;
        membership.rank = null;
      }

      memberships.push(membership);
    }
  }

  await membershipRepo.save(memberships);

  await communityRepo
    .createQueryBuilder()
    .update(Community)
    .set({
      membersCount: () => `
        (
          SELECT COUNT(*)
          FROM community_memberships cm
          WHERE cm.communityId = communities.id
        )
      `,
    })
    .execute();

  console.log(`Seeded ${memberships.length} community memberships ‚úÖ`);
  console.log(`Updated communities.membersCount ‚úÖ`);

  return memberships;
}

---


### FILE: backend/src/database/seeds/community-membership-request.seed.ts ###
import { AppDataSource } from '../../data-source';
import {
  CommunityMembershipRequest,
  CommunityMembershipRequestStatus,
} from '../../community-membership-requests/entities/community-membership-request.entity';
import { communityMembershipRequestFactory } from '../factories/community-membership-request.factory';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';
import { CommunityMembership } from '../../community-memberships/entities/community-memberships.entity';
import { communityMembershipFactory } from '../factories/community-memberships.factory';
import { CommunityMembershipRole } from '../../community-memberships/types';

export async function seedCommunityMembershipRequests(
  users: User[],
  communities: Community[],
): Promise<CommunityMembershipRequest[]> {
  const requestRepo = AppDataSource.getRepository(CommunityMembershipRequest);
  const membershipRepo = AppDataSource.getRepository(CommunityMembership);
  const communityRepo = AppDataSource.getRepository(Community);


  if (users.length === 0 || communities.length === 0) {
    console.warn(
      'Skipping CommunityMembershipRequest seeding: No users or communities found.',
    );
    return [];
  }

  const communityMembershipRequests: CommunityMembershipRequest[] = [];
  const numberOfRequestsToAttempt = 50; // You can adjust this number

  // To keep track of already created requests to avoid duplicates
  const createdRequestPairs = new Set<string>();

  for (let i = 0; i < numberOfRequestsToAttempt; i++) {
    const randomUser = users[Math.floor(Math.random() * users.length)];
    const randomCommunity =
      communities[Math.floor(Math.random() * communities.length)];

    const pairKey = `${randomUser.id}-${randomCommunity.id}`;

    if (createdRequestPairs.has(pairKey)) {
      continue; // Skip if this pair already has a pending request
    }

    // Check for existing request OR existing membership to prevent conflicts
    const existingRequest = await requestRepo.findOne({
      where: {
        userId: randomUser.id,
        communityId: randomCommunity.id,
      },
    });

    const existingMembership = await membershipRepo.findOne({
      where: {
        userId: randomUser.id,
        communityId: randomCommunity.id,
      },
    });


    if (!existingRequest && !existingMembership) {
      communityMembershipRequests.push(
        communityMembershipRequestFactory(randomUser, randomCommunity),
      );
      createdRequestPairs.add(pairKey);
    }
  }

  const savedRequests = await requestRepo.save(communityMembershipRequests);
  console.log(`Seeded ${savedRequests.length} community membership requests ‚úÖ`);

  const communityMemberships: CommunityMembership[] = [];
  // Track next moderator rank per community
  const nextRankByCommunity = new Map<number, number>();


  for (const request of savedRequests) {
    if (request.status === CommunityMembershipRequestStatus.ACCEPTED) {
      const membership = communityMembershipFactory();
      membership.userId = request.userId;
      membership.communityId = request.communityId;
      membership.user = request.user;
      membership.community = request.community;
      membership.role = CommunityMembershipRole.MEMBER; // Always assign MEMBER role
      membership.rank = null;
      communityMemberships.push(membership);
    }
  }

  await membershipRepo.save(communityMemberships);
  console.log(`Seeded ${communityMemberships.length} community memberships from accepted requests ‚úÖ`);

  await communityRepo
    .createQueryBuilder()
    .update(Community)
    .set({
      membersCount: () => `
        (
          SELECT COUNT(*)
          FROM community_memberships cm
          WHERE cm.communityId = communities.id
        )
      `,
    })
    .execute();
  console.log(`Updated communities.membersCount for new memberships ‚úÖ`);

  return savedRequests;
}

---


### FILE: backend/src/database/seeds/community.seed.ts ###
import { AppDataSource } from '../../data-source';
import { communityFactory } from '../factories/community.factory';
import { Community } from '../../communities/entities/community.entity';
import { User } from '../../users/entities/user.entity';

export async function seedCommunities(users: User[]): Promise<Community[]> {
  const communityRepo = AppDataSource.getRepository(Community);
  const communities: Community[] = Array.from({ length: 8 }).map(() => {
    const community = communityFactory();
    community.owner = users[Math.floor(Math.random() * users.length)];
    community.ownerId = community.owner.id;
    return community;
  });

  await communityRepo.save(communities);
  console.log(`Seeded ${communities.length} communities ‚úÖ`);
  return communities;
}

if (require.main === module) {
  AppDataSource.initialize().then(async () => {
    const userRepo = AppDataSource.getRepository(User);
    const users = await userRepo.find();
    await seedCommunities(users);
  }).catch(error => console.error('Seeding failed ‚ùå', error));
}

---


### FILE: backend/src/database/seeds/index.ts ###
import { seedUsers } from './user.seed';
import { seedProfiles } from './profile.seed'; // NEW IMPORT
import { seedPosts } from './post.seed';
import { seedComments } from './comment.seed';
import { seedReactions } from './reaction.seed';
import { seedCommunities } from './community.seed';
import { seedCommunityMemberships } from './community-memberships.seed';
import { seedCommunityMembershipRequests } from './community-membership-request.seed';
import { seedCommunityRestrictions } from './community-restriction.seed';
import { AppDataSource } from '../../data-source';

async function main() {
  try {
    await AppDataSource.initialize();
    // Seed users
    const users = await seedUsers();

    // Seed profiles
    await seedProfiles();

    // Seed communities
    const communities = await seedCommunities(users);

    // Seed posts
    const posts = await seedPosts(users, communities);

    // Seed comments
    const comments = await seedComments(users, posts);

    // Seed reactions (optional)
    await seedReactions(posts, comments, users);

    // Seed community memberships
    await seedCommunityMemberships(users, communities);

    // Seed community membership requests
    await seedCommunityMembershipRequests(users, communities);

    // Seed community restrictions
    await seedCommunityRestrictions(users, communities);

    console.log('Database seeding complete ‚úÖ');
  } catch (error) {
    console.error('Seeding failed ‚ùå', error);
  } finally {
    // Optional: ensure datasource is destroyed if needed
    // await AppDataSource.destroy();
  }
}

main();

---


### FILE: backend/src/database/seeds/profile.seed.ts ###
import { AppDataSource } from '../../data-source';
import { User } from '../../users/entities/user.entity';
import { Profile } from '../../profile/entities/profile.entity';
import { profileFactory } from '../factories/profile.factory';

export async function seedProfiles() {
  const userRepo = AppDataSource.getRepository(User);
  const profileRepo = AppDataSource.getRepository(Profile);

  const usersWithoutProfiles = await userRepo
    .createQueryBuilder('user')
    .leftJoinAndSelect('user.profile', 'profile')
    .where('profile.id IS NULL')
    .getMany();

  const profiles: Profile[] = [];

  for (const user of usersWithoutProfiles) {
    const newProfile = profileFactory(user);
    profiles.push(newProfile);
  }

  await profileRepo.save(profiles);

  console.log(`Seeded ${profiles.length} profiles ‚úÖ`);

  return profiles;
}



if (require.main === module) seedProfiles();

---


### FILE: backend/src/database/factories/community-membership-request.factory.ts ###
import {
  CommunityMembershipRequest,
  CommunityMembershipRequestStatus,
} from '../../community-membership-requests/entities/community-membership-request.entity';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';
import { faker } from '@faker-js/faker';

export function communityMembershipRequestFactory(
  user: User,
  community: Community,
): CommunityMembershipRequest {
  const request = new CommunityMembershipRequest();
  request.userId = user.id;
  request.communityId = community.id;
  request.user = user;
  request.community = community;
  request.status = faker.helpers.arrayElement(Object.values(CommunityMembershipRequestStatus));
  // createdAt is auto-generated by CreateDateColumn

  return request;
}

---


### FILE: backend/src/database/factories/community-restriction.factory.ts ###
import { CommunityRestriction } from '../../community-restrictions/entities/community-restriction.entity';
import { CommunityRestrictionType } from '../../community-restrictions/community-restrictions.types';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';
import { AppDataSource } from '../../data-source';
import { Repository } from 'typeorm';
import { faker } from '@faker-js/faker';

export function communityRestrictionFactory(
  user: User,
  community: Community,
  createdBy: User,
): CommunityRestriction {
  const communityRestrictionRepository: Repository<CommunityRestriction> =
    AppDataSource.getRepository(CommunityRestriction);

  return communityRestrictionRepository.create({
    restrictionType: faker.helpers.arrayElement([
      CommunityRestrictionType.BAN,
      CommunityRestrictionType.MUTE,
    ]),
    reason: faker.lorem.sentence(),
    expiresAt: faker.date.future(),
    user: user,
    community: community,
    createdBy: createdBy,
    createdById: createdBy.id,
  });
}

---


### FILE: backend/src/database/factories/community-memberships.factory.ts ###
import { faker } from '@faker-js/faker';
import { CommunityMembership } from '../../community-memberships/entities/community-memberships.entity';

export function communityMembershipFactory(): CommunityMembership {
  const membership = new CommunityMembership();
  // userId and communityId will be set when seeding, as they are foreign keys
  // For now, we can just return the basic membership object.
  return membership;
}

---


### FILE: backend/src/database/factories/user.factory.ts ###
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';
import * as bcrypt from 'bcrypt';

export function userFactory(): User {
  const user = new User();

  user.username = faker.internet.username();
  user.email = faker.internet.email();

  // --- Add bcrypt password ---
  const plainPassword = 'password1'; // or faker.internet.password();
  const saltRounds = 10;

  user.password = bcrypt.hashSync(plainPassword, saltRounds);

  return user;
}

---


### FILE: backend/src/database/factories/profile.factory.ts ###
import { Profile } from '../../profile/entities/profile.entity';
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';

export function profileFactory(user: User): Profile {
  const profile = new Profile();
  profile.displayName = faker.person.fullName();
  profile.bio = faker.lorem.sentence();
  profile.picture = faker.image.avatar();
  profile.user = user; // Link profile to the provided user
  return profile;
}

---


### FILE: backend/src/database/factories/comment-reaction.factory.ts ###
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';
import { ReactionType } from '../../reactions/reactions.types';

/**
 * Creates a CommentReaction object.
 */
export function commentReactionFactory(
  user: User,
  comment: Comment,
): CommentReaction {
  const reaction = new CommentReaction();

  reaction.user = user;
  reaction.comment = comment;

  const types = Object.values(ReactionType);
  reaction.type = faker.helpers.arrayElement(types);

  return reaction;
}

---


### FILE: backend/src/database/factories/post.factory.ts ###
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity'; // Import Community entity
import { faker } from '@faker-js/faker';

export function postFactory(author: User, community: Community): Post {
  const post = new Post();
  post.title = faker.lorem.sentence();
  post.content = faker.lorem.paragraph();
  post.author = author;
  post.community = community; // Assign community
  return post;
}

---


### FILE: backend/src/database/factories/comment.factory.ts ###
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';
import { faker } from '@faker-js/faker';

export function commentFactory(author: User, post: Post, parentId?: number): Comment {
  const comment = new Comment();
  comment.content = faker.lorem.sentence();
  comment.author = author;
  comment.post = post;
  comment.repliesCount = 0;
  if (parentId) {
    comment.parentId = parentId;
  }
  return comment;
}

---


### FILE: backend/src/database/factories/post-reaction.factory.ts ###
import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';
import { ReactionType } from '../../reactions/reactions.types';

/**
 * Creates a PostReaction object.
 */
export function postReactionFactory(user: User, post: Post): PostReaction {
  const reaction = new PostReaction();

  reaction.user = user;
  reaction.post = post;

  const types = Object.values(ReactionType);
  reaction.type = faker.helpers.arrayElement(types);

  return reaction;
}

---


### FILE: backend/src/database/factories/community.factory.ts ###
import { faker } from '@faker-js/faker';
import { Community } from '../../communities/entities/community.entity';
import { CommunityType } from '../../communities/types';

export function communityFactory(): Community {
  const community = new Community();
  community.name = faker.internet.username();
  community.displayName = faker.company.name();
  community.description = faker.lorem.paragraph();
  community.communityType = faker.helpers.arrayElement(Object.values(CommunityType));
  community.membersCount = faker.number.int({ min: 0, max: 1000 });
  return community;
}

---


### FILE: backend/src/database/migrations/1766849789902-AddReasonToRestricttions.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddReasonToRestricttions1766849789902 implements MigrationInterface {
    name = 'AddReasonToRestricttions1766849789902'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_community_restrictions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "restrictionType" varchar CHECK( "restrictionType" IN ('ban','mute') ) NOT NULL, "createdById" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityId" integer, "userId" integer, "reason" text, "expiresAt" datetime, CONSTRAINT "FK_6b3370beb21ea2316b1e3c444ad" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_7399cce662943e126a61f635e5c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_066c4afe6f1ba3f2178159967cc" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_community_restrictions"("id", "restrictionType", "createdById", "createdAt", "communityId", "userId") SELECT "id", "restrictionType", "createdById", "createdAt", "communityId", "userId" FROM "community_restrictions"`);
        await queryRunner.query(`DROP TABLE "community_restrictions"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_restrictions" RENAME TO "community_restrictions"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('moderator','member') ) NOT NULL DEFAULT ('member'), "rank" integer, CONSTRAINT "FK_6ea82875cc58f4b1b14ebe49717" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_488d1ca96e355e11d83480a8f2c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "role", "rank") SELECT "userId", "communityId", "createdAt", "role", "rank" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('owner','admin','moderator','member') ) NOT NULL DEFAULT ('member'), "rank" integer, CONSTRAINT "FK_6ea82875cc58f4b1b14ebe49717" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_488d1ca96e355e11d83480a8f2c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "role", "rank") SELECT "userId", "communityId", "createdAt", "role", "rank" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "community_restrictions" RENAME TO "temporary_community_restrictions"`);
        await queryRunner.query(`CREATE TABLE "community_restrictions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "restrictionType" varchar CHECK( "restrictionType" IN ('ban','mute') ) NOT NULL, "createdById" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityId" integer, "userId" integer, CONSTRAINT "FK_6b3370beb21ea2316b1e3c444ad" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_7399cce662943e126a61f635e5c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_066c4afe6f1ba3f2178159967cc" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "community_restrictions"("id", "restrictionType", "createdById", "createdAt", "communityId", "userId") SELECT "id", "restrictionType", "createdById", "createdAt", "communityId", "userId" FROM "temporary_community_restrictions"`);
        await queryRunner.query(`DROP TABLE "temporary_community_restrictions"`);
    }

}

---


### FILE: backend/src/database/migrations/1765931083722-MakePostCommunityMandatory.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class MakePostCommunityMandatory1765931083722 implements MigrationInterface {
    name = 'MakePostCommunityMandatory1765931083722'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
    }

}

---


### FILE: backend/src/database/migrations/1765627185088-AddPictureFieldToUser.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddPictureFieldToUser1765627185088 implements MigrationInterface {
    name = 'AddPictureFieldToUser1765627185088'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "picture" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
        await queryRunner.query(`CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`);
        await queryRunner.query(`DROP TABLE "temporary_users"`);
    }

}

---


### FILE: backend/src/database/migrations/1766966515318-AddExplicitPostIdToComments.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddExplicitPostIdToComments1766966515318 implements MigrationInterface {
    name = 'AddExplicitPostIdToComments1766966515318'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer NOT NULL, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer NOT NULL, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer NOT NULL, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
    }

}

---


### FILE: backend/src/database/migrations/1766443444048-AddCommentsLockedToPost.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommentsLockedToPost1766443444048 implements MigrationInterface {
    name = 'AddCommentsLockedToPost1766443444048'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "commentsLocked" boolean NOT NULL DEFAULT (0), "isApproved" boolean NOT NULL DEFAULT (0), "approvedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, CONSTRAINT "FK_d6947c03c05fca0fa035b19e73d" FOREIGN KEY ("moderatorId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_4927687e8f8ed1b2e4c849ddc82" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_moderators"("moderatorId", "communityId") SELECT "moderatorId", "communityId" FROM "community_moderators"`);
        await queryRunner.query(`DROP TABLE "community_moderators"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_moderators" RENAME TO "community_moderators"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_2d9086cef1ffd5148f90a9fab5d" FOREIGN KEY ("ownerId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "community_moderators" RENAME TO "temporary_community_moderators"`);
        await queryRunner.query(`CREATE TABLE "community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_moderators"("moderatorId", "communityId") SELECT "moderatorId", "communityId" FROM "temporary_community_moderators"`);
        await queryRunner.query(`DROP TABLE "temporary_community_moderators"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "community_moderators"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
    }

}

---


### FILE: backend/src/database/migrations/1766917664292-AddPublishedAtToPosts.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddPublishedAtToPosts1766917664292 implements MigrationInterface {
    name = 'AddPublishedAtToPosts1766917664292'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "commentsLocked" boolean NOT NULL DEFAULT (0), "status" varchar CHECK( "status" IN ('pending','approved','rejected') ) NOT NULL DEFAULT ('pending'), "publishedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked", "status") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked", "status" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "commentsLocked" boolean NOT NULL DEFAULT (0), "status" varchar CHECK( "status" IN ('pending','approved','rejected') ) NOT NULL DEFAULT ('pending'), CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked", "status") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked", "status" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
    }

}

---


### FILE: backend/src/database/migrations/1765490375370-refactor-reactions.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class RefactorReactions1765490375370 implements MigrationInterface {
  name = 'RefactorReactions1765490375370';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `,
    );
    await queryRunner.query(
      `CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b8f6756d160de241ea96a768254" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "post_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "post_reactions"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_post_reactions" RENAME TO "post_reactions"`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_ab02238d3deb62cba37aa8047dd" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "comment_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "comment_reactions"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment_reactions" RENAME TO "comment_reactions"`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
    await queryRunner.query(
      `ALTER TABLE "comment_reactions" RENAME TO "temporary_comment_reactions"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `INSERT INTO "comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "temporary_comment_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment_reactions"`);
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
    await queryRunner.query(
      `ALTER TABLE "post_reactions" RENAME TO "temporary_post_reactions"`,
    );
    await queryRunner.query(
      `CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `INSERT INTO "post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "temporary_post_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post_reactions"`);
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
    await queryRunner.query(`DROP TABLE "comment_reactions"`);
    await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
    await queryRunner.query(`DROP TABLE "post_reactions"`);
  }
}

---


### FILE: backend/src/database/migrations/1767215182662-AddEmailChangeTokensTable.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddEmailChangeTokensTable1767215182662 implements MigrationInterface {
    name = 'AddEmailChangeTokensTable1767215182662'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "email_change_tokens" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "newEmail" varchar(100) NOT NULL, "token" varchar NOT NULL, "expiresAt" datetime NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (CURRENT_TIMESTAMP), CONSTRAINT "UQ_04e0f8c19f839970ea29cfebc40" UNIQUE ("token"))`);
        await queryRunner.query(`CREATE TABLE "temporary_email_change_tokens" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "newEmail" varchar(100) NOT NULL, "token" varchar NOT NULL, "expiresAt" datetime NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (CURRENT_TIMESTAMP), CONSTRAINT "UQ_04e0f8c19f839970ea29cfebc40" UNIQUE ("token"), CONSTRAINT "FK_5079c637bc96fe23c8aa4ccd7da" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_email_change_tokens"("id", "newEmail", "token", "expiresAt", "userId", "createdAt") SELECT "id", "newEmail", "token", "expiresAt", "userId", "createdAt" FROM "email_change_tokens"`);
        await queryRunner.query(`DROP TABLE "email_change_tokens"`);
        await queryRunner.query(`ALTER TABLE "temporary_email_change_tokens" RENAME TO "email_change_tokens"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "email_change_tokens" RENAME TO "temporary_email_change_tokens"`);
        await queryRunner.query(`CREATE TABLE "email_change_tokens" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "newEmail" varchar(100) NOT NULL, "token" varchar NOT NULL, "expiresAt" datetime NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (CURRENT_TIMESTAMP), CONSTRAINT "UQ_04e0f8c19f839970ea29cfebc40" UNIQUE ("token"))`);
        await queryRunner.query(`INSERT INTO "email_change_tokens"("id", "newEmail", "token", "expiresAt", "userId", "createdAt") SELECT "id", "newEmail", "token", "expiresAt", "userId", "createdAt" FROM "temporary_email_change_tokens"`);
        await queryRunner.query(`DROP TABLE "temporary_email_change_tokens"`);
        await queryRunner.query(`DROP TABLE "email_change_tokens"`);
    }

}

---


### FILE: backend/src/database/migrations/1766879712347-StatusToPosts.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class StatusToPosts1766879712347 implements MigrationInterface {
    name = 'StatusToPosts1766879712347'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "commentsLocked" boolean NOT NULL DEFAULT (0), CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "commentsLocked" boolean NOT NULL DEFAULT (0), "status" varchar CHECK( "status" IN ('pending','approved','rejected') ) NOT NULL DEFAULT ('pending'), CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "commentsLocked" boolean NOT NULL DEFAULT (0), CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "commentsLocked" boolean NOT NULL DEFAULT (0), "isApproved" boolean NOT NULL DEFAULT (0), "approvedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "commentsLocked" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
    }

}

---


### FILE: backend/src/database/migrations/1765821272324-AddLikesDislikesToPostsComments.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddLikesDislikesToPostsComments1765821272324 implements MigrationInterface {
    name = 'AddLikesDislikesToPostsComments1765821272324'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`);
        await queryRunner.query(`DROP TABLE "comment"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment" RENAME TO "comment"`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`ALTER TABLE "comment" RENAME TO "temporary_comment"`);
        await queryRunner.query(`CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`);
        await queryRunner.query(`DROP TABLE "temporary_comment"`);
    }

}

---


### FILE: backend/src/database/migrations/1765628559552-RefactorProfileEntity.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class RefactorProfileEntity1765628559552 implements MigrationInterface {
    name = 'RefactorProfileEntity1765628559552'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"))`);
        await queryRunner.query(`CREATE TABLE "temporary_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_profiles" RENAME TO "profiles"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "profiles" RENAME TO "temporary_profiles"`);
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"))`);
        await queryRunner.query(`INSERT INTO "profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
    }

}

---


### FILE: backend/src/database/migrations/1764720178421-inital.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class Inital1764720178421 implements MigrationInterface {
  name = 'Inital1764720178421';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "user" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar NOT NULL, "email" varchar NOT NULL, CONSTRAINT "UQ_e12875dfb3b1d92d7d7c5377e22" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(`DROP TABLE "user"`);
  }
}

---


### FILE: backend/src/database/migrations/1766932368690-AddUsernameAndDisplayName.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddUsernameAndDisplayName1766932368690 implements MigrationInterface {
    name = 'AddUsernameAndDisplayName1766932368690'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "displayName" varchar NOT NULL, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_963eb0a3184ae150f3346445bac" UNIQUE ("displayName"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_profiles"("id", "displayName", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_profiles" RENAME TO "profiles"`);
        await queryRunner.query(`CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "role" varchar CHECK( "role" IN ('0','1','2') ) NOT NULL DEFAULT (2), CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "temporary_users"("id", "username", "email", "password", "emailVerifiedAt", "provider", "providerId", "role") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId", "role" FROM "users"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
        await queryRunner.query(`CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "role" varchar CHECK( "role" IN ('0','1','2') ) NOT NULL DEFAULT (2), CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"), CONSTRAINT "UQ_4baf95322bd69fe419c26c5430c" UNIQUE ("username"))`);
        await queryRunner.query(`INSERT INTO "temporary_users"("id", "username", "email", "password", "emailVerifiedAt", "provider", "providerId", "role") SELECT "id", "username", "email", "password", "emailVerifiedAt", "provider", "providerId", "role" FROM "users"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
        await queryRunner.query(`CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "role" varchar CHECK( "role" IN ('0','1','2') ) NOT NULL DEFAULT (2), CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "users"("id", "username", "email", "password", "emailVerifiedAt", "provider", "providerId", "role") SELECT "id", "username", "email", "password", "emailVerifiedAt", "provider", "providerId", "role" FROM "temporary_users"`);
        await queryRunner.query(`DROP TABLE "temporary_users"`);
        await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
        await queryRunner.query(`CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "role" varchar CHECK( "role" IN ('0','1','2') ) NOT NULL DEFAULT (2), CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId", "role") SELECT "id", "username", "email", "password", "emailVerifiedAt", "provider", "providerId", "role" FROM "temporary_users"`);
        await queryRunner.query(`DROP TABLE "temporary_users"`);
        await queryRunner.query(`ALTER TABLE "profiles" RENAME TO "temporary_profiles"`);
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar NOT NULL, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "displayName", "bio", "picture", "userId" FROM "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_profiles"`);
    }

}

---


### FILE: backend/src/database/migrations/1766792244031-AddCreatedByToCommunityRestrictions.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCreatedByToCommunityRestrictions1766792244031 implements MigrationInterface {
    name = 'AddCreatedByToCommunityRestrictions1766792244031'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "community_restrictions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "restrictionType" varchar CHECK( "restrictionType" IN ('ban','mute') ) NOT NULL, "createdById" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityId" integer, "userId" integer)`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('owner','admin','moderator','member') ) NOT NULL DEFAULT ('member'), "rank" integer, CONSTRAINT "FK_488d1ca96e355e11d83480a8f2c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_6ea82875cc58f4b1b14ebe49717" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_restrictions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "restrictionType" varchar CHECK( "restrictionType" IN ('ban','mute') ) NOT NULL, "createdById" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityId" integer, "userId" integer, CONSTRAINT "FK_066c4afe6f1ba3f2178159967cc" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_7399cce662943e126a61f635e5c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_6b3370beb21ea2316b1e3c444ad" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_community_restrictions"("id", "restrictionType", "createdById", "createdAt", "communityId", "userId") SELECT "id", "restrictionType", "createdById", "createdAt", "communityId", "userId" FROM "community_restrictions"`);
        await queryRunner.query(`DROP TABLE "community_restrictions"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_restrictions" RENAME TO "community_restrictions"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "community_restrictions" RENAME TO "temporary_community_restrictions"`);
        await queryRunner.query(`CREATE TABLE "community_restrictions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "restrictionType" varchar CHECK( "restrictionType" IN ('ban','mute') ) NOT NULL, "createdById" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityId" integer, "userId" integer)`);
        await queryRunner.query(`INSERT INTO "community_restrictions"("id", "restrictionType", "createdById", "createdAt", "communityId", "userId") SELECT "id", "restrictionType", "createdById", "createdAt", "communityId", "userId" FROM "temporary_community_restrictions"`);
        await queryRunner.query(`DROP TABLE "temporary_community_restrictions"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('owner','admin','moderator','member') ) NOT NULL DEFAULT ('member'), CONSTRAINT "FK_488d1ca96e355e11d83480a8f2c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_6ea82875cc58f4b1b14ebe49717" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_restrictions"`);
    }

}

---


### FILE: backend/src/database/migrations/1766320141300-AddStatusToCommunitySubscription.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddStatusToCommunityMembership1766320141300 implements MigrationInterface {
    name = 'AddStatusToCommunityMembership1766320141300'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "status" varchar CHECK( "status" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
    }

}

---


### FILE: backend/src/database/migrations/1766412136598-AddApprovedAtToPosts.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddApprovedAtToPosts1766412136598 implements MigrationInterface {
    name = 'AddApprovedAtToPosts1766412136598'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "isApproved" boolean NOT NULL DEFAULT (0), "approvedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_2d9086cef1ffd5148f90a9fab5d" FOREIGN KEY ("ownerId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
    }

}

---


### FILE: backend/src/database/migrations/1765671180328-AddCommunitiesAndSubscriptions.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommunitiesAndMemberships1765671180328 implements MigrationInterface {
    name = 'AddCommunitiesAndMemberships1765671180328'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
    }

}

---


### FILE: backend/src/database/migrations/1765630608057-MakeUsernameNonNullable.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class MakeUsernameNonNullable1765630608057 implements MigrationInterface {
    name = 'MakeUsernameNonNullable1765630608057'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_profiles" RENAME TO "profiles"`);
        await queryRunner.query(`CREATE TABLE "temporary_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar NOT NULL, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_profiles" RENAME TO "profiles"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "profiles" RENAME TO "temporary_profiles"`);
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_profiles"`);
        await queryRunner.query(`ALTER TABLE "profiles" RENAME TO "temporary_profiles"`);
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_profiles"`);
    }

}

---


### FILE: backend/src/database/migrations/1766168966958-MakeParentIdNullable.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class MakeParentIdNullable1766168966958 implements MigrationInterface {
    name = 'MakeParentIdNullable1766168966958'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
    }

}

---


### FILE: backend/src/database/migrations/1764783033004-AddReactions.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddReactions1764783033004 implements MigrationInterface {
  name = 'AddReactions1764783033004';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_e58a09ab17e3ce4c47a1a330ae1" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "reaction"`,
    );
    await queryRunner.query(`DROP TABLE "reaction"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_reaction" RENAME TO "reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(
      `ALTER TABLE "reaction" RENAME TO "temporary_reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `INSERT INTO "reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "temporary_reaction"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_reaction"`);
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(`DROP TABLE "reaction"`);
  }
}

---


### FILE: backend/src/database/migrations/1766168720979-AddRepliesCountToComment.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddRepliesCountToComment1766168720979 implements MigrationInterface {
    name = 'AddRepliesCountToComment1766168720979'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
    }

}

---


### FILE: backend/src/database/migrations/1766319450404-AddCommunityTypeToCommunity.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommunityTypeToCommunity1766319450404 implements MigrationInterface {
    name = 'AddCommunityTypeToCommunity1766319450404'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
    }

}

---


### FILE: backend/src/database/migrations/1766668524447-AddReportEntity.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddReportEntity1766668524447 implements MigrationInterface {
    name = 'AddReportEntity1766668524447'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "status" varchar CHECK( "status" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "status") SELECT "userId", "communityId", "createdAt", "status" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "status" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`CREATE TABLE "post_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`CREATE TABLE "comment_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "commentId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`CREATE TABLE "user_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "reportedUserId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "role" varchar CHECK( "role" IN ('0','1','2') ) NOT NULL DEFAULT (2), CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('admin','moderator','member') ) NOT NULL DEFAULT ('member'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('admin','moderator','member') ) NOT NULL DEFAULT ('member'), CONSTRAINT "FK_488d1ca96e355e11d83480a8f2c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_6ea82875cc58f4b1b14ebe49717" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("id", "userId", "communityId", "status", "createdAt") SELECT "id", "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_post_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0), CONSTRAINT "FK_4f4c3c25aa849390b9cb7fd6fa1" FOREIGN KEY ("reporterId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b9b9977c4da06492b2491cea20a" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "postId", "communityId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "postId", "communityId", "isPlatformComplaint" FROM "post_reports"`);
        await queryRunner.query(`DROP TABLE "post_reports"`);
        await queryRunner.query(`ALTER TABLE "temporary_post_reports" RENAME TO "post_reports"`);
        await queryRunner.query(`CREATE TABLE "temporary_comment_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "commentId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0), CONSTRAINT "FK_36ab772754faebab9c812565988" FOREIGN KEY ("reporterId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_14ce729bcc2ec2f7c16b11b2d9e" FOREIGN KEY ("commentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "commentId", "communityId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "commentId", "communityId", "isPlatformComplaint" FROM "comment_reports"`);
        await queryRunner.query(`DROP TABLE "comment_reports"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment_reports" RENAME TO "comment_reports"`);
        await queryRunner.query(`CREATE TABLE "temporary_user_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "reportedUserId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0), CONSTRAINT "FK_4c8ff913a6d53469649f6941ece" FOREIGN KEY ("reporterId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_85aa921a0dfd2b7d58cd4cd9450" FOREIGN KEY ("reportedUserId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_user_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "reportedUserId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "reportedUserId", "isPlatformComplaint" FROM "user_reports"`);
        await queryRunner.query(`DROP TABLE "user_reports"`);
        await queryRunner.query(`ALTER TABLE "temporary_user_reports" RENAME TO "user_reports"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "user_reports" RENAME TO "temporary_user_reports"`);
        await queryRunner.query(`CREATE TABLE "user_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "reportedUserId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "user_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "reportedUserId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "reportedUserId", "isPlatformComplaint" FROM "temporary_user_reports"`);
        await queryRunner.query(`DROP TABLE "temporary_user_reports"`);
        await queryRunner.query(`ALTER TABLE "comment_reports" RENAME TO "temporary_comment_reports"`);
        await queryRunner.query(`CREATE TABLE "comment_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "commentId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comment_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "commentId", "communityId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "commentId", "communityId", "isPlatformComplaint" FROM "temporary_comment_reports"`);
        await queryRunner.query(`DROP TABLE "temporary_comment_reports"`);
        await queryRunner.query(`ALTER TABLE "post_reports" RENAME TO "temporary_post_reports"`);
        await queryRunner.query(`CREATE TABLE "post_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "post_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "postId", "communityId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "postId", "communityId", "isPlatformComplaint" FROM "temporary_post_reports"`);
        await queryRunner.query(`DROP TABLE "temporary_post_reports"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("id", "userId", "communityId", "status", "createdAt") SELECT "id", "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('admin','moderator','member') ) NOT NULL DEFAULT ('member'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
        await queryRunner.query(`CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`);
        await queryRunner.query(`DROP TABLE "temporary_users"`);
        await queryRunner.query(`DROP TABLE "user_reports"`);
        await queryRunner.query(`DROP TABLE "comment_reports"`);
        await queryRunner.query(`DROP TABLE "post_reports"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "status" varchar CHECK( "status" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "status") SELECT "userId", "communityId", "createdAt", "role" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "status" varchar CHECK( "status" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "status") SELECT "userId", "communityId", "createdAt", "status" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
    }

}

---


### FILE: backend/src/database/migrations/1765214825123-addVerifrokesTable.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddVerifrokesTable1765214825123 implements MigrationInterface {
  name = 'AddVerifrokesTable1765214825123';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "email_verification_tokens" ("id" varchar PRIMARY KEY NOT NULL, "token" varchar NOT NULL, "userId" integer NOT NULL, "expiresAt" datetime NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "UQ_3d1613f95c6a564a3b588d161ae" UNIQUE ("token"))`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE "email_verification_tokens"`);
  }
}

---


### FILE: backend/src/database/migrations/1765927724937-AddCommentsCountToPost.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommentsCountToPost1765927724937 implements MigrationInterface {
    name = 'AddCommentsCountToPost1765927724937'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "commentsCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
    }

}

---


### FILE: backend/src/database/migrations/1765377593735-AddOauthcols.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddOauthcols1765377593735 implements MigrationInterface {
  name = 'AddOauthcols1765377593735';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt") SELECT "id", "name", "email", "password", "emailVerifiedAt" FROM "users"`,
    );
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`,
    );
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_users"`);
    await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt") SELECT "id", "name", "email", "password", "emailVerifiedAt" FROM "temporary_users"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_users"`);
  }
}

---


### FILE: backend/src/database/migrations/1767010619445-AddCheckConstraintToCommentsParentId.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCheckConstraintToCommentsParentId1767010619445 implements MigrationInterface {
    name = 'AddCheckConstraintToCommentsParentId1767010619445'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer NOT NULL, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "CHK_b9e7bfe596d4bac99091a838cf" CHECK (id <> parentId), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer NOT NULL, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
    }

}

---


### FILE: backend/src/database/migrations/1765457240708-addResetPasswordTokenTable.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddResetPasswordTokenTable1765457240708 implements MigrationInterface {
  name = 'AddResetPasswordTokenTable1765457240708';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "password_reset_tokens" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "token" varchar NOT NULL, "expiresAt" datetime NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_d6a19d4b4f6c62dcd29daa497e" ON "password_reset_tokens" ("userId") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_ab673f0e63eac966762155508e" ON "password_reset_tokens" ("token") `,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP INDEX "IDX_ab673f0e63eac966762155508e"`);
    await queryRunner.query(`DROP INDEX "IDX_d6a19d4b4f6c62dcd29daa497e"`);
    await queryRunner.query(`DROP TABLE "password_reset_tokens"`);
  }
}

---


### FILE: backend/src/database/migrations/1766756846428-AddOwnerRoleToMemeberships.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddOwnerRoleToMemeberships1766756846428 implements MigrationInterface {
    name = 'AddOwnerRoleToMemeberships1766756846428'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('owner','admin','moderator','member') ) NOT NULL DEFAULT ('member'), CONSTRAINT "FK_6ea82875cc58f4b1b14ebe49717" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_488d1ca96e355e11d83480a8f2c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('admin','moderator','member') ) NOT NULL DEFAULT ('member'), CONSTRAINT "FK_6ea82875cc58f4b1b14ebe49717" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_488d1ca96e355e11d83480a8f2c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
    }

}

---


### FILE: backend/src/database/migrations/1764871406438-addingColsToUser.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddingColsToUser1764871406438 implements MigrationInterface {
  name = 'AddingColsToUser1764871406438';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "temporary_reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "reaction"`,
    );
    await queryRunner.query(`DROP TABLE "reaction"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_reaction" RENAME TO "reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_e58a09ab17e3ce4c47a1a330ae1" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "reaction"`,
    );
    await queryRunner.query(`DROP TABLE "reaction"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_reaction" RENAME TO "reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(
      `ALTER TABLE "reaction" RENAME TO "temporary_reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "temporary_reaction"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_reaction"`);
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(
      `ALTER TABLE "reaction" RENAME TO "temporary_reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_e58a09ab17e3ce4c47a1a330ae1" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "temporary_reaction"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_reaction"`);
  }
}

---


### FILE: backend/src/database/migrations/1765209236854-AddEmailVerifiedColumn.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddEmailVerifiedColumn1765209236854 implements MigrationInterface {
  name = 'AddEmailVerifiedColumn1765209236854';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_users"("id", "name", "email", "password") SELECT "id", "name", "email", "password" FROM "users"`,
    );
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "users"("id", "name", "email", "password") SELECT "id", "name", "email", "password" FROM "temporary_users"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_users"`);
  }
}

---


### FILE: backend/src/database/migrations/1765929661449-RenameTablesToPlural.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class RenameTablesToPlural1765929661449 implements MigrationInterface {
    name = 'RenameTablesToPlural1765929661449'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`CREATE TABLE "temporary_post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "post_reactions"`);
        await queryRunner.query(`DROP TABLE "post_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_post_reactions" RENAME TO "post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`CREATE TABLE "temporary_comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "comment_reactions"`);
        await queryRunner.query(`DROP TABLE "comment_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment_reactions" RENAME TO "comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer)`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`);
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`CREATE TABLE "temporary_post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b8f6756d160de241ea96a768254" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "post_reactions"`);
        await queryRunner.query(`DROP TABLE "post_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_post_reactions" RENAME TO "post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`CREATE TABLE "temporary_comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_ab02238d3deb62cba37aa8047dd" FOREIGN KEY ("commentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "comment_reactions"`);
        await queryRunner.query(`DROP TABLE "comment_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment_reactions" RENAME TO "comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`ALTER TABLE "comment_reactions" RENAME TO "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "temporary_comment_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`ALTER TABLE "post_reactions" RENAME TO "temporary_post_reactions"`);
        await queryRunner.query(`CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "temporary_post_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`ALTER TABLE "comment_reactions" RENAME TO "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_ab02238d3deb62cba37aa8047dd" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "temporary_comment_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`ALTER TABLE "post_reactions" RENAME TO "temporary_post_reactions"`);
        await queryRunner.query(`CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b8f6756d160de241ea96a768254" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "temporary_post_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
    }

}

---


### FILE: backend/src/database/migrations/1765628229160-CreateUserProfileAndLinkToUser.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateUserProfileAndLinkToUser1765628229160 implements MigrationInterface {
    name = 'CreateUserProfileAndLinkToUser1765628229160'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "user_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_7bdaa0714f4c1087a926a2d8369" UNIQUE ("username"), CONSTRAINT "REL_8481388d6325e752cd4d7e26c6" UNIQUE ("userId"))`);
        await queryRunner.query(`CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
        await queryRunner.query(`CREATE TABLE "temporary_user_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_7bdaa0714f4c1087a926a2d8369" UNIQUE ("username"), CONSTRAINT "REL_8481388d6325e752cd4d7e26c6" UNIQUE ("userId"), CONSTRAINT "FK_8481388d6325e752cd4d7e26c6d" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_user_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "user_profiles"`);
        await queryRunner.query(`DROP TABLE "user_profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_user_profiles" RENAME TO "user_profiles"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "user_profiles" RENAME TO "temporary_user_profiles"`);
        await queryRunner.query(`CREATE TABLE "user_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_7bdaa0714f4c1087a926a2d8369" UNIQUE ("username"), CONSTRAINT "REL_8481388d6325e752cd4d7e26c6" UNIQUE ("userId"))`);
        await queryRunner.query(`INSERT INTO "user_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_user_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_user_profiles"`);
        await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
        await queryRunner.query(`CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "picture" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`);
        await queryRunner.query(`DROP TABLE "temporary_users"`);
        await queryRunner.query(`DROP TABLE "user_profiles"`);
    }

}

---


### FILE: backend/src/database/migrations/1766761884496-RemoveIdFromMembRequests.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class RemoveIdFromMembRequests1766761884496 implements MigrationInterface {
    name = 'RemoveIdFromMembRequests1766761884496'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
    }

}

---


### FILE: backend/src/community-memberships/types.ts ###
export enum CommunityMembershipRole {
   MODERATOR = 'moderator',
  MEMBER = 'member',
}

---


### FILE: backend/src/community-memberships/community-memberships.controller.ts ###
import {
  Controller,
  Post,
  Param,
  ParseIntPipe,
  Delete,
  UseGuards,
  Get,
  Query,
  Body,
} from '@nestjs/common';
import { CommunityMembershipsService } from './community-memberships.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { User } from '../users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { CommunityMembershipQueryDto } from './dto/community-memberships-query.dto';
import { CommunityMembershipResponseDto } from './dto/community-memberships-response.dto';



@Controller()
export class CommunityMembershipsController {
  constructor(
    private readonly communityMembershipsService: CommunityMembershipsService,
  ) {}

  // -----------------------------
  // GET memberships (paginated)
  // -----------------------------
  @UseGuards(JwtAuthGuard)
  @Get('community-memberships')
  async findMemberships(
    @Query() query: CommunityMembershipQueryDto,
  ): Promise<PaginatedResponseDto<CommunityMembershipResponseDto>> {
    const { data, count } = await this.communityMembershipsService.findMemberships({
      userId: query.userId,
      communityId: query.communityId,
      page: query.page,
      limit: query.limit,
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(
      data.map(CommunityMembershipResponseDto.fromEntity),
      paginationMeta,
    );
  }

  // -----------------------------
  // DELETE /users/me/communities/:communityId/memberships
  // Self-leave
  // -----------------------------
  @UseGuards(JwtAuthGuard)
  @Delete('users/me/communities/:communityId/memberships')
  async leaveCommunity(
    @Param('communityId', ParseIntPipe) communityId: number,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    await this.communityMembershipsService.leaveCommunity(user.id, communityId);
    return new ResponseDto(true);
  }

  // -----------------------------
  // DELETE /communities/:communityId/members/:targetUserId
  // Moderator removes a member
  // -----------------------------
  @UseGuards(JwtAuthGuard)
  @Delete('communities/:communityId/members/:targetUserId')
  async removeMember(
    @Param('communityId', ParseIntPipe) communityId: number,
    @Param('targetUserId', ParseIntPipe) targetUserId: number,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    await this.communityMembershipsService.removeMember(user.id, targetUserId, communityId);
    return new ResponseDto(true);
  }
}

---


### FILE: backend/src/community-memberships/community-memberships.service.ts ###
import {
  ConflictException,
  ForbiddenException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm'; // Added DataSource
import { User } from '../users/entities/user.entity';
// import { CommunitiesService } from '../communities/communities.service'; // This import is removed
import { Community } from '../communities/entities/community.entity'; // Added Community entity

import { CommunityMembership } from './entities/community-memberships.entity';
import { CommunityMembershipRole } from './types';

interface MembershipQuery {
  userId?: number;
  communityId?: number;
  page?: number;
  limit?: number;
}

@Injectable()
export class CommunityMembershipsService {
  constructor(
    @InjectRepository(CommunityMembership)
    private readonly membershipsRepository: Repository<CommunityMembership>,
    // private readonly communitiesService: CommunitiesService, // This is removed
    @InjectRepository(User)
    private readonly usersRepository: Repository<User>,
    @InjectRepository(Community) // Injected Community repository
    private readonly communityRepository: Repository<Community>,
    private dataSource: DataSource, // Injected DataSource
  ) { }


  async findMemberships(query: MembershipQuery): Promise<{ data: CommunityMembership[]; count: number }> {
    const where: any = {};
    const relations: string[] = ['user']; // Always push 'user' relation

    if (query.userId) {
      where.userId = query.userId;
      relations.push('community'); 
    }

    if (query.communityId) {
      where.communityId = query.communityId;
    }

    const options: any = { where, relations };

    // Pagination
    if (query.page !== undefined && query.limit !== undefined) {
      const page = Math.max(1, query.page);
      const limit = Math.max(1, query.limit);
      options.skip = (page - 1) * limit;
      options.take = limit;
    }

    const [data, count] = await this.membershipsRepository.findAndCount(options);
    return { data, count };
  }

  async findOne(userId: number, communityId: number): Promise<CommunityMembership | null> {
    return this.membershipsRepository.findOne({
      where: { userId, communityId },
    });
  }
  // -----------------------------
  // 1Ô∏è‚É£ Self-leave
  // -----------------------------
  async leaveCommunity(userId: number, communityId: number) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const community = await queryRunner.manager.findOne(Community, { where: { id: communityId } });
      if (!community) throw new NotFoundException(`Community ${communityId} not found`);

      const membership = await queryRunner.manager.findOne(CommunityMembership, {
        where: { userId, communityId },
      });
      if (!membership) throw new NotFoundException(`You are not a member of community ${communityId}`);

      await queryRunner.manager.remove(membership);
      await queryRunner.manager.decrement(Community, { id: communityId }, 'membersCount', 1);

      await queryRunner.commitTransaction();
      return { message: 'Left community successfully' };
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }

  // -----------------------------
  // 2Ô∏è‚É£ Moderator removal
  // -----------------------------
  async removeMember(actorUserId: number, targetUserId: number, communityId: number) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const community = await queryRunner.manager.findOne(Community, { where: { id: communityId } });
      if (!community) throw new NotFoundException(`Community ${communityId} not found`);

      const actorMembership = await queryRunner.manager.findOne(CommunityMembership, {
        where: { userId: actorUserId, communityId },
      });
      if (!actorMembership || actorMembership.role !== CommunityMembershipRole.MODERATOR) {
        throw new ForbiddenException('Only moderators can remove members.');
      }

      const targetMembership = await queryRunner.manager.findOne(CommunityMembership, {
        where: { userId: targetUserId, communityId },
      });
      if (!targetMembership) throw new NotFoundException(`Target user is not a member of this community`);

      // --- Rank check: lower number = higher rank ---
      if (actorMembership.userId !== targetMembership.userId &&
        targetMembership.role === CommunityMembershipRole.MODERATOR &&
        actorMembership.rank && targetMembership.rank && actorMembership.rank >= targetMembership.rank // actor.rank higher or equal number = lower/equal authority
      ) {
        throw new ForbiddenException('Cannot remove a moderator with equal or higher rank.');
      }

      await queryRunner.manager.remove(targetMembership);
      await queryRunner.manager.decrement(Community, { id: communityId }, 'membersCount', 1);

      await queryRunner.commitTransaction();
      return { message: 'Member removed successfully' };
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }

}

---


### FILE: backend/src/community-memberships/entities/community-memberships.entity.ts ###
import {
  Column,
  CreateDateColumn,
  Entity,
  ManyToOne,
  PrimaryColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';
import { CommunityMembershipRole } from '../types';

@Entity('community_memberships')
export class CommunityMembership {
  @PrimaryColumn()
  userId: number;

  @PrimaryColumn()
  communityId: number;

  @ManyToOne(() => User, (user) => user.communityMemberships)
  user: User;

  @ManyToOne(() => Community, (community) => community.memberships)
  community: Community;

  @Column({
    type: 'simple-enum',
    enum: CommunityMembershipRole,
    default: CommunityMembershipRole.MEMBER,
  })
  role: CommunityMembershipRole;

  @Column({ type: 'integer', nullable: true })
  rank: number | null;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: backend/src/community-memberships/community-memberships.module.ts ###
import { Module } from '@nestjs/common';
import { CommunityMembershipsService } from './community-memberships.service';
import { CommunityMembershipsController } from './community-memberships.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CommunitiesModule } from '../communities/communities.module';
import { UsersModule } from 'src/users/users.module';
import { User } from 'src/users/entities/user.entity';
import { Community } from '../communities/entities/community.entity';
import { CommunityMembership } from './entities/community-memberships.entity';

@Module({
  imports: [TypeOrmModule.forFeature([CommunityMembership, User, Community]), 
  CommunitiesModule],
  controllers: [CommunityMembershipsController],
  providers: [CommunityMembershipsService],
  exports: [CommunityMembershipsService],
})
export class CommunityMembershipsModule {}

---


### FILE: backend/src/community-memberships/dto/community-memberships-query.dto.ts ###
import { IsBoolean, IsNumber, IsOptional, IsString } from 'class-validator';
import { PaginationDto } from '../../common/dto/pagination.dto';
import { Transform } from 'class-transformer';

export class CommunityMembershipQueryDto extends PaginationDto {
  @IsOptional()
  @IsNumber()
  userId?: number;

  @IsOptional()
  @IsNumber()
  communityId?: number;

 
}

---


### FILE: backend/src/community-memberships/dto/community-memberships-response.dto.ts ###
import { Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { CommunityResponseDto } from '../../communities/dto/community-response.dto';
import { CommunityMembership } from '../entities/community-memberships.entity';
import { CommunityMembershipRole } from '../types';

export class CommunityMembershipResponseDto {
  @Expose()
  userId: number;

  @Expose()
  communityId: number;

  @Expose()
  @Type(() => UserResponseDto)
  user: UserResponseDto;

  @Expose()
  @Type(() => CommunityResponseDto)
  community: CommunityResponseDto;

 @Expose()
  role: CommunityMembershipRole;

  @Expose()
  rank: number; // Add this line

  @Expose()
  createdAt: Date;

  static fromEntity(
    entity: CommunityMembership,
  ): CommunityMembershipResponseDto {
    return plainToInstance(CommunityMembershipResponseDto, entity);
  }
}

---


### FILE: backend/src/main.ts ###
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { useContainer } from 'class-validator';
import { NestExpressApplication } from '@nestjs/platform-express';
import { join } from 'path';

import cookieParser from 'cookie-parser';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  app.use(cookieParser());

  // Use validation pipe globally
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true, // auto-convert types
      transformOptions: {
        enableImplicitConversion: true, // allows automatic type conversion
      },
    }),
  );
  app.setGlobalPrefix('api'); // all routes will now start with /api

  app.enableCors({
    origin: 'http://localhost:5173', // Change this to your frontend URL  
    credentials: true,
  });

  // Get ConfigService instance
  const configService = app.get(ConfigService);
  const port = configService.get<number>('PORT') ?? 3000;

  // Serve static files from the 'uploads' directory
  app.useStaticAssets(join(__dirname, '..', 'uploads'), {
    prefix: '/uploads/',
  });

  await app.listen(port);
  console.log(`Application is running on: http://localhost:${port}`);
}
bootstrap();

---


### FILE: backend/src/users/pipes/user.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { UsersService } from '../users.service';
import { User } from '../entities/user.entity';

@Injectable()
export class UserPipe implements PipeTransform<string, Promise<User>> {
  constructor(private readonly usersService: UsersService) {}

  async transform(value: string): Promise<User> {
    return this.usersService.findOneById(+value);
  }
}

---


### FILE: backend/src/users/users.service.ts ###
// src/users/users.service.ts
import { BadRequestException, ConflictException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Brackets, Not, Repository } from 'typeorm';
import * as bcrypt from 'bcrypt';
import { User } from './entities/user.entity';
import { ProfileService } from '../profile/profile.service'; // Import ProfileService

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private readonly repo: Repository<User>,
  ) {}

  async findAll(
    page = 1,
    limit = 10,
    search?: string,
    provider?: 'google' | 'github',
  ): Promise<{ data: User[]; count: number }> {
    const query = this.repo.createQueryBuilder('user').leftJoinAndSelect('user.profile', 'profile'); // Eagerly load profile

    if (search) {
      query.where(
        new Brackets((qb) => {
          qb.where('user.username LIKE :search', {
            search: `%${search}%`,
          }).orWhere('user.email LIKE :search', { search: `%${search}%` })
          .orWhere('profile.displayName LIKE :search', { search: `%${search}%` }); // Search in profile display name
        }),
      );
    }

    if (provider) {
      query.andWhere('user.provider = :provider', { provider });
    }

    query.orderBy('user.createdAt', 'DESC');

    const [data, count] = await query
      .take(limit)
      .skip((page - 1) * limit)
      .getManyAndCount();

    return { data, count };
  }


  private async find(where: any, message: string): Promise<User> {
    const user = await this.repo.findOne({ where, relations: ['profile'] }); // Eagerly load profile
    if (!user) throw new NotFoundException(message);
    return user;
  }


  async findOneById(id: number): Promise<User> {
    return this.find({ id }, `User with ID ${id} not found.`);
  }

  async findByEmail(email: string): Promise<User> {
    return this.find({ email }, `User with email ${email} not found.`);
  }


async createUser({
  username,
  email,
  password,
  provider,
  providerId,
  emailVerifiedAt,
}: {
  username: string;
  email: string;
  password?: string | null;
  provider?: 'google' | 'github' | null;
  providerId?: string | null;
  emailVerifiedAt?: Date | null;
}): Promise<User> {

  const emailExists = await this.repo.exists({ where: { email } });
  if (emailExists) {
    throw new ConflictException('Email already in use');
  }

  if (provider && password) {
    throw new BadRequestException(
      'Password-based accounts cannot have a provider',
    );
  }

  if (provider && !providerId) {
    throw new BadRequestException('providerId is required when provider is set');
  }

  const user = this.repo.create({
    username,
    email,
    provider: provider ?? null,
    providerId: providerId ?? null,
    emailVerifiedAt:
      emailVerifiedAt ?? (password ? null : new Date()),
    password: password
      ? await bcrypt.hash(password, 10)
      : null,
  });

  return this.repo.save(user);
}
 async updateUser({
  user,
  username,
  email,
  password,
  provider,
  providerId,
  emailVerifiedAt,
}: {
  user: User;
  username?: string;
  email?: string;
  password?: string | null;
  provider?: 'google' | 'github' | null;
  providerId?: string | null;
  emailVerifiedAt?: Date | null;
}): Promise<User> {
  
  if (email !== undefined && email !== user.email) {
    const emailExists = await this.repo.exists({
      where: {
        email,
        id: Not(user.id),
      },
    });

    if (emailExists) {
      throw new ConflictException('Email already in use');
    }
  }

  if (provider !== undefined && password !== undefined) {
    throw new BadRequestException(
      'Cannot update provider and password together',
    );
  }

  if (provider !== undefined && provider && !providerId) {
    throw new BadRequestException(
      'providerId is required when provider is set',
    );
  }

  Object.assign(user, {
    ...(username !== undefined && { username }),
    ...(email !== undefined && { email }),
    ...(provider !== undefined && { provider }),
    ...(providerId !== undefined && { providerId }),
    ...(emailVerifiedAt !== undefined && { emailVerifiedAt }),
  });

  if (password !== undefined) {
    user.password = password
      ? await bcrypt.hash(password, 10)
      : null;
  }

  return this.repo.save(user);
}
 async updateEmail(userId: number, email: string): Promise<User> {
    const user = await this.findOneById(userId);
    if (email === user.email) {
      return user; // No change
    }

    const emailExists = await this.repo.exists({
      where: {
        email,
        id: Not(user.id),
      },
    });

    if (emailExists) {
      throw new ConflictException('Email already in use');
    }

    user.email = email;
    user.emailVerifiedAt = null; // Email needs re-verification
    return this.repo.save(user);
  }

  async updatePassword(userId: number, currentPassword, newPassword): Promise<User> {
    const user = await this.findOneById(userId);

    if (!user.password) {
      throw new BadRequestException('User does not have a password set.');
    }

    const isPasswordMatching = await bcrypt.compare(
      currentPassword,
      user.password,
    );

    if (!isPasswordMatching) {
      throw new BadRequestException('Incorrect current password');
    }

    user.password = await bcrypt.hash(newPassword, 10);
    return this.repo.save(user);
  }


  async markEmailAsVerified(id: number): Promise<void> {
    const user = await this.findOneById(id);

    if (!user.emailVerifiedAt) {
      user.emailVerifiedAt = new Date();
      await this.repo.save(user);
    }
  }
}
---


### FILE: backend/src/users/dtos/update-password.dto.ts ###
import { IsNotEmpty, IsString, MinLength } from 'class-validator';

export class UpdatePasswordDto {
  @IsString()
  @IsNotEmpty()
  currentPassword: string;

  @IsString()
  @IsNotEmpty()
  @MinLength(8, { message: 'Password must be at least 8 characters long' })
  newPassword: string;
}

---


### FILE: backend/src/users/dtos/update-email.dto.ts ###
import { IsEmail, IsNotEmpty } from 'class-validator';

export class UpdateEmailDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;
}

---


### FILE: backend/src/users/dtos/user-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsString, IsEnum } from 'class-validator';

export class UserQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  search?: string; // Filter by name or email

  @IsOptional()
  @IsEnum(['google', 'github'])
  provider?: 'google' | 'github';
}

---


### FILE: backend/src/users/dtos/user-response.dto.ts ###
import { Exclude, Expose, plainToInstance } from 'class-transformer';
import { User } from '../entities/user.entity';

@Exclude()
export class UserResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly username: string;
  @Expose() readonly email: string;
  @Expose() readonly emailVerifiedAt: Date | null;
  @Expose() readonly provider: string | null;

  static fromEntity(entity: User): UserResponseDto {
    return plainToInstance(UserResponseDto, entity, {
      excludeExtraneousValues: true,
    });
  }
}

---


### FILE: backend/src/users/users.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  imports: [TypeOrmModule.forFeature([User])], // Add ProfileModule here
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService], // Export the service so it can be injected elsewhere
})
export class UsersModule {}

---


### FILE: backend/src/users/entities/user.entity.ts ###
// src/users/entities/user.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToMany,
  OneToOne,
  JoinColumn,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { Profile } from '../../profile/entities/profile.entity'; // Import Profile
import { Community } from '../../communities/entities/community.entity';
import { CommunityMembership } from '../../community-memberships/entities/community-memberships.entity';
import { CommunityMembershipRequest } from '../../community-membership-requests/entities/community-membership-request.entity';
import { PostReport } from '../../reports/entities/post-report.entity';
import { CommunityRestriction } from '../../community-restrictions/entities/community-restriction.entity';
import { CommentReport } from '../../reports/entities/comment-report.entity'; // NEW IMPORT
import { UserReport } from '../../reports/entities/user-report.entity'; // NEW IMPORT


export enum UserRole {
  SUPER_ADMIN,
  ADMIN,
  USER
}

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 100, unique: true })
  username: string;

  @Column({ type: 'varchar', length: 100, unique: true })
  email: string;

  @Column({ type: 'varchar', nullable: true })
  password: string | null;

  @Column({ type: 'datetime', nullable: true, default: null })
  emailVerifiedAt: Date | null; // üëà NEW FIELD

  @Column({
    type: 'simple-enum',
    enum: ['google', 'github'],
    nullable: true,
    default: null,
  })
  provider: 'google' | 'github' | null;

  @Column({ type: 'varchar', nullable: true })
  providerId: string | null; // Google's profile.id

  // One-to-one relation with Profile
  @OneToOne(() => Profile, (profile) => profile.user)
  profile: Profile;

  @Column({
    type: 'simple-enum', // sqlite compatible
    enum: UserRole,
    default: UserRole.USER,
  })
  role: UserRole;

  // Relations
  @OneToMany(() => Post, (post) => post.author)
  posts: Post[];

  @OneToMany(() => Comment, (comment) => comment.author)
  comments: Comment[];

  @OneToMany(() => PostReaction, (reaction) => reaction.user)
  postReactions: PostReaction[];

  @OneToMany(() => CommentReaction, (reaction) => reaction.user)
  commentReactions: CommentReaction[];

  @OneToMany(() => Community, (community) => community.owner)
  createdCommunities: Community[];

  @OneToMany(
    () => CommunityMembership,
    (communityMembership) => communityMembership.user,
  )
  communityMemberships: CommunityMembership[];

  @OneToMany(
    () => CommunityMembershipRequest,
    (request) => request.user,
  )
  communityMembershipRequests: CommunityMembershipRequest[];

  @OneToMany(() => PostReport, (postReport) => postReport.reporter)
  postReports: PostReport[];

  @OneToMany(() => CommentReport, (commentReport) => commentReport.reporter) // NEW RELATION
  commentReports: CommentReport[];

  @OneToMany(() => UserReport, (userReport) => userReport.reporter)
  reportedUserReports: UserReport[];

  @OneToMany(() => UserReport, (userReport) => userReport.reportedUser)
  userReports: UserReport[];

  @OneToMany(
    () => CommunityRestriction,
    (restriction) => restriction.user,
  )
  communityRestrictions: CommunityRestriction[];
}
---


### FILE: backend/src/users/users.controller.ts ###
import { Controller, Get, Query } from '@nestjs/common';
import { UsersService } from './users.service';
import { UserQueryDto } from './dtos/user-query.dto';
import { UserResponseDto } from './dtos/user-response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  async findAll(@Query() query: UserQueryDto): Promise<PaginatedResponseDto<UserResponseDto>> {
    const { data, count } = await this.usersService.findAll(
      query.page,
      query.limit,
      query.search,
      query.provider,
    );

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(UserResponseDto.fromEntity), paginationMeta);
  }
}

---


### FILE: backend/src/community-membership-requests/community-membership-requests.controller.ts ###
import {
  Controller,
  Post,
  Param,
  ParseIntPipe,
  UseGuards,
  Delete,
  Get,
  Query,
} from '@nestjs/common';
import { CommunityMembershipRequestsService } from './community-membership-requests.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { GetUser } from '../decorators/user.decorator';
import { User } from '../users/entities/user.entity';
import { ResponseDto } from 'src/common/dto/response.dto';
import { CommunityMembershipRequestResponseDto } from './dto/community-membership-request-response.dto';
import { CommunityMembershipRequestQueryDto } from './dto/community-membership-request-query.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';

@UseGuards(JwtAuthGuard)
@Controller('communities/:communityId/membership-requests')
export class CommunityMembershipRequestsController {
  constructor(
    private readonly requestsService: CommunityMembershipRequestsService,
  ) {}

  /** List all pending requests for a community (for admins/mods) */
  @Get()
  async listRequests(
    @Param('communityId', ParseIntPipe) communityId: number,
    @Query() query: CommunityMembershipRequestQueryDto,
  ): Promise<PaginatedResponseDto<CommunityMembershipRequestResponseDto>> {
    const { data, count } = await this.requestsService.findMany({
      ...query,
      communityId,
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(
      data.map(CommunityMembershipRequestResponseDto.fromEntity),
      paginationMeta,
    );
  }

  /** Create a join request (or auto-join if public) for the logged-in user */
  @Post()
  async createRequest(
    @Param('communityId', ParseIntPipe) communityId: number,
    @GetUser() user: User,
  ) {
    return this.requestsService.createMembershipRequest(user.id, communityId);
  }
  /** Accept a membership request (for moderators) */
  @Post(':userId/accept')
  async acceptRequest(
    @Param('communityId', ParseIntPipe) communityId: number,
    @Param('userId', ParseIntPipe) userId: number,
    @GetUser() actor: User,
  ): Promise<ResponseDto<boolean>> {
    await this.requestsService.acceptMembershipRequest(
      actor.id,
      userId,
      communityId,
    );
    return new ResponseDto(true);
  }


@Delete('me')
removeOwnRequest(
  @Param('communityId', ParseIntPipe) communityId: number,
  @GetUser() user: User,
) {
  return this.requestsService.removeOwnRequest(user.id, communityId);
}

@Delete(':userId')
removeRequest(
  @Param('communityId', ParseIntPipe) communityId: number,
  @Param('userId', ParseIntPipe) userId: number,
  @GetUser() actor: User,
) {
  return this.requestsService.removeMembershipRequest(
    actor.id,
    userId,
    communityId,
  );
}

}

---


### FILE: backend/src/community-membership-requests/community-membership-requests.module.ts ###
import { Module } from '@nestjs/common';
import { CommunityMembershipRequestsService } from './community-membership-requests.service';
import { CommunityMembershipRequestsController } from './community-membership-requests.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CommunityMembershipRequest } from './entities/community-membership-request.entity';
import { CommunityMembership } from '../community-memberships/entities/community-memberships.entity';
import { User } from '../users/entities/user.entity';
import { Community } from '../communities/entities/community.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      CommunityMembershipRequest,
      CommunityMembership,
      User,
      Community,
    ]),
  ],
  controllers: [CommunityMembershipRequestsController],
  providers: [CommunityMembershipRequestsService],
})
export class CommunityMembershipRequestsModule {}

---


### FILE: backend/src/community-membership-requests/community-membership-requests.service.ts ###
import {
  BadRequestException,
  ForbiddenException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  CommunityMembershipRequest,
  CommunityMembershipRequestStatus,
} from './entities/community-membership-request.entity';
import { Brackets, DataSource, In, Repository } from 'typeorm';
import { CommunityMembership } from '../community-memberships/entities/community-memberships.entity';
import { User } from '../users/entities/user.entity';
import { Community } from '../communities/entities/community.entity';
import { CommunityMembershipRole } from '../community-memberships/types';
import { CommunityType } from '../communities/types';
import {
  CommunityMembershipRequestQueryDto,
  CommunityMembershipRequestSort,
} from './dto/community-membership-request-query.dto';

@Injectable()
export class CommunityMembershipRequestsService {
  constructor(
    @InjectRepository(CommunityMembershipRequest)
    private readonly requestRepository: Repository<CommunityMembershipRequest>,
    @InjectRepository(CommunityMembership)
    private readonly membershipRepository: Repository<CommunityMembership>,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(Community)
    private readonly communityRepository: Repository<Community>,
    private dataSource: DataSource,
  ) {}

  async findMany(
    queryDto: CommunityMembershipRequestQueryDto,
  ): Promise<{ data: CommunityMembershipRequest[]; count: number }> {
    const { page, limit, userId, communityId, status, sort } = queryDto;

    const queryBuilder = this.requestRepository
      .createQueryBuilder('request')
      .leftJoinAndSelect('request.user', 'user')
      .leftJoinAndSelect('request.community', 'community');

    if (userId) {
      queryBuilder.andWhere('request.userId = :userId', { userId });
    }

    if (communityId) {
      queryBuilder.andWhere('request.communityId = :communityId', { communityId });
    }

    if (status) {
      queryBuilder.andWhere('request.status = :status', { status });
    }

    if (sort === CommunityMembershipRequestSort.NEWEST) {
      queryBuilder.orderBy('request.createdAt', 'DESC');
    } else if (sort === CommunityMembershipRequestSort.OLDEST) {
      queryBuilder.orderBy('request.createdAt', 'ASC');
    } else {
      queryBuilder.orderBy('request.createdAt', 'DESC'); // Default sort
    }

    const [data, count] = await queryBuilder
      .take(limit)
      .skip((page - 1) * limit)
      .getManyAndCount();

    return { data, count };
  }

  async createMembershipRequest(userId: number, communityId: number) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const user = await queryRunner.manager.findOne(User, { where: { id: userId } });
      if (!user) {
        throw new NotFoundException('User not found');
      }

      const community = await queryRunner.manager.findOne(Community, {
        where: { id: communityId },
        select: ['id', 'ownerId', 'communityType'], // Select communityType
      });
      if (!community) {
        throw new NotFoundException('Community not found');
      }

      const existingMembership = await queryRunner.manager.findOne(CommunityMembership, {
        where: { userId, communityId },
      });
      if (existingMembership) {
        throw new BadRequestException('User is already a member of this community');
      }

      // If community is public, create membership directly
      if (community.communityType === CommunityType.PUBLIC) {
        const membership = queryRunner.manager.create(CommunityMembership, {
          userId,
          communityId,
          role: CommunityMembershipRole.MEMBER, // Default role for auto-membership
        });
        await queryRunner.manager.save(membership);
        await queryRunner.manager.increment(Community, { id: community.id }, 'membersCount', 1);
        await queryRunner.commitTransaction();
        return membership;
      } else {
        // For restricted or private communities, create a pending request
        const existingRequest = await queryRunner.manager.findOne(CommunityMembershipRequest, {
          where: { userId, communityId, status: CommunityMembershipRequestStatus.PENDING },
        });
        if (existingRequest) {
          throw new BadRequestException('Pending request already exists');
        }

        const request = queryRunner.manager.create(CommunityMembershipRequest, {
          userId,
          communityId,
        });
        await queryRunner.manager.save(request);
        await queryRunner.commitTransaction();
        return request;
      }
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }
async acceptMembershipRequest(
  actorId: number,
  userId: number,
  communityId: number,
) {
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();
  console.log(actorId,userId,communityId);
  

  try {
    // 1. Fetch pending request
    const request = await queryRunner.manager.findOne(
      CommunityMembershipRequest,
      {
        where: {
          userId,
          communityId,
          status: CommunityMembershipRequestStatus.PENDING,
        },
      },
    );

    if (!request) {
      throw new NotFoundException('Pending membership request not found');
    }

    // 2. Authorization: 
  await this.canManageMembershipRequests(actorId,communityId)


    // 3. Create membership (idempotent-safe)
    await queryRunner.manager.insert(CommunityMembership, {
      userId,
      communityId,
      role: CommunityMembershipRole.MEMBER,
    });

    // 4. Mark request accepted
    await queryRunner.manager.update(
      CommunityMembershipRequest,
      { userId, communityId },
      { status: CommunityMembershipRequestStatus.ACCEPTED },
    );

    // 5. Increment members count
    await queryRunner.manager.increment(
      Community,
      { id: communityId },
      'membersCount',
      1,
    );

    await queryRunner.commitTransaction();
    return true;
  } catch (err) {
    await queryRunner.rollbackTransaction();
    throw err;
  } finally {
    await queryRunner.release();
  }
}

async removeMembershipRequest(
  actorId: number,
  userId: number,
  communityId: number,
) {
  // 1Ô∏è‚É£ Check pending request exists
  const request = await this.requestRepository.findOne({
    where: {
      userId,
      communityId,
      status: CommunityMembershipRequestStatus.PENDING,
    },
  });

  if (!request) {
    throw new NotFoundException('Pending membership request not found');
  }

  // 2Ô∏è‚É£ Check actor role in THIS community
 await this.canManageMembershipRequests(actorId,communityId)

  // 3Ô∏è‚É£ Delete request
   await this.requestRepository.delete({ userId: request.userId,communityId:communityId });

  return true;
}
async removeOwnRequest(
  userId: number,
  communityId: number,
): Promise<boolean> {
  const request = await this.requestRepository.findOne({
    where: {
      userId,
      communityId,
      status: CommunityMembershipRequestStatus.PENDING,
    },
  });

  if (!request) {
    throw new NotFoundException('Pending membership request not found');
  }

  await this.requestRepository.delete({
    userId,
    communityId,
    status: CommunityMembershipRequestStatus.PENDING,
  });

  return true;
}
  private async canManageMembershipRequests(actorId: number, communityId: number) {
    const membership = await this.membershipRepository.findOne({
      where: {
        userId: actorId,
        communityId,
        role: In([CommunityMembershipRole.MODERATOR]),
      },
    });

    if (!membership) {
      throw new ForbiddenException('You are not allowed to manage membership requests for this community');
    }

    return membership; // optional, in case you want actor info
  }
 }

---


### FILE: backend/src/community-membership-requests/entities/community-membership-request.entity.ts ###
import {
  CreateDateColumn,
  Entity,
  ManyToOne,
  Column,
  PrimaryColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';

export enum CommunityMembershipRequestStatus {
  PENDING = 'pending',
  ACCEPTED = 'accepted',
  REJECTED = 'rejected',
}

@Entity('community_membership_requests')
export class CommunityMembershipRequest {
  // Composite primary key: userId + communityId
  @PrimaryColumn()
  userId: number;

  @PrimaryColumn()
  communityId: number;

  @ManyToOne(() => User, (user) => user.communityMembershipRequests)
  user: User;

  @ManyToOne(() => Community, (community) => community.membershipRequests)
  community: Community;

  @Column({
    type: 'simple-enum',
    enum: CommunityMembershipRequestStatus,
    default: CommunityMembershipRequestStatus.PENDING,
  })
  status: CommunityMembershipRequestStatus;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: backend/src/community-membership-requests/dto/community-membership-request-response.dto.ts ###
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { CommunityResponseDto } from '../../communities/dto/community-response.dto';
import { CommunityMembershipRequest, CommunityMembershipRequestStatus } from '../entities/community-membership-request.entity';

@Exclude()
export class CommunityMembershipRequestResponseDto {
  @Expose() readonly id: number;

  @Expose() readonly userId: number;
  @Expose() readonly communityId: number;

  @Expose() @Type(() => UserResponseDto) readonly user: UserResponseDto;
  @Expose() @Type(() => CommunityResponseDto) readonly community: CommunityResponseDto;

  @Expose() readonly status: CommunityMembershipRequestStatus;
  @Expose() readonly createdAt: Date;

  static fromEntity(entity: CommunityMembershipRequest): CommunityMembershipRequestResponseDto {
    return plainToInstance(
      CommunityMembershipRequestResponseDto,
      {
        ...entity,
        user: entity.user ? UserResponseDto.fromEntity(entity.user) : null,
        community: entity.community ? CommunityResponseDto.fromEntity(entity.community) : null,
      },
      { excludeExtraneousValues: true },
    );
  }
}

---


### FILE: backend/src/community-membership-requests/dto/community-membership-request-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsInt, IsEnum } from 'class-validator';
import { Type } from 'class-transformer';
import { CommunityMembershipRequestStatus } from '../entities/community-membership-request.entity';

export enum CommunityMembershipRequestSort {
  NEWEST = 'newest',
  OLDEST = 'oldest',
}

export class CommunityMembershipRequestQueryDto extends PaginationDto {
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  userId?: number;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  communityId?: number;

  @IsOptional()
  @IsEnum(CommunityMembershipRequestStatus)
  status?: CommunityMembershipRequestStatus;

  @IsOptional()
  @IsEnum(CommunityMembershipRequestSort)
  sort?: CommunityMembershipRequestSort;
}

---


### FILE: backend/src/reactions/pipes/post-reaction.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { ReactionsService } from '../reactions.service';
import { PostReaction } from '../entities/post-reaction.entity';

@Injectable()
export class PostReactionPipe implements PipeTransform<
  string,
  Promise<PostReaction>
> {
  constructor(private readonly reactionsService: ReactionsService) {}

  async transform(value: string): Promise<PostReaction> {
    return this.reactionsService.findPostReactionById(+value);
  }
}

---


### FILE: backend/src/reactions/pipes/comment-reaction.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { ReactionsService } from '../reactions.service';
import { CommentReaction } from '../entities/comment-reaction.entity';

@Injectable()
export class CommentReactionPipe implements PipeTransform<
  string,
  Promise<CommentReaction>
> {
  constructor(private readonly reactionsService: ReactionsService) {}

  async transform(value: string): Promise<CommentReaction> {
    return this.reactionsService.findCommentReactionById(+value);
  }
}

---


### FILE: backend/src/reactions/reactions.controller.ts ###
import {
  Controller,
  Post,
  Get,
  Body,
  Param,
  Delete,
  UseGuards,
  NotFoundException,
  Query,
  Patch,
} from '@nestjs/common';
import { ReactionsService } from './reactions.service';
import { CreateReactionDto } from './dto/create-reaction.dto';
import { UpdateReactionDto } from './dto/update-reaction.dto';
import { User } from 'src/users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { Action } from 'src/casl/casl.types';
import { PostReaction } from './entities/post-reaction.entity';
import { CommentReaction } from './entities/comment-reaction.entity';
import { Post as PostEntity } from '../posts/entities/post.entity';
import { Comment as CommentEntity } from '../comments/entities/comment.entity';
import { CaslService } from 'src/casl/casl.service';
import { ReactionResponseDto } from './dto/reaction-response.dto';
import { PostReactionPipe } from './pipes/post-reaction.pipe';
import { CommentReactionPipe } from './pipes/comment-reaction.pipe';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { ReactionQueryDto } from './dto/reaction-query.dto';
import { CommentPipe } from 'src/comments/pipes/comment.pipe';
import { PostPipe } from 'src/posts/pipes/post.pipe';


@Controller()
export class ReactionsController {
  constructor(
    private readonly reactionsService: ReactionsService,
    private readonly caslService: CaslService,
  ) {}

  @Post('posts/:postId/reactions')
  @UseGuards(JwtAuthGuard)
  async createPostReaction(
    @Param('postId', PostPipe) post: PostEntity,
    @Body() dto: CreateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Create, PostReaction);
    const reaction = await this.reactionsService.create(
     {   type :dto.type,
      userId :user.id,
      postId: post.id,}
    );
    return new ResponseDto(ReactionResponseDto.fromEntity(reaction));
  }

  @Get('posts/:postId/reactions')
  async getPostReactions(
    @Param('postId', PostPipe) post: PostEntity,
    @Query() query: ReactionQueryDto,
  ): Promise<PaginatedResponseDto<ReactionResponseDto>> {
    const { data, count } = await this.reactionsService.findByPost({ postId: post.id, page: query.page, limit: query.limit });
    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );
    return new PaginatedResponseDto(data.map(ReactionResponseDto.fromEntity), paginationMeta);
  }

  @Patch('posts/:postId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async updatePostReaction(
    @Param('reactionId', PostReactionPipe) reaction: PostReaction,
    @Body() dto: UpdateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Update, reaction);
    const updatedReaction = await this.reactionsService.updatePostReaction({
       id:reaction.id,
       type:dto.type});
    return new ResponseDto(ReactionResponseDto.fromEntity(updatedReaction));
  }

  @Post('comments/:commentId/reactions')
  @UseGuards(JwtAuthGuard)
  async createCommentReaction(
    @Param('commentId', CommentPipe) comment: CommentEntity,
    @Body() dto: CreateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Create, CommentReaction);
    const reaction = await this.reactionsService.create(
   {   type :dto.type,
      userId :user.id,
      commentId: comment.id,}
    );
    return new ResponseDto(ReactionResponseDto.fromEntity(reaction));
  }

  @Get('comments/:commentId/reactions')
  async getCommentReactions(
    @Param('commentId', CommentPipe) comment: CommentEntity,
    @Query() query: ReactionQueryDto,
  ): Promise<PaginatedResponseDto<ReactionResponseDto>> {
    const { data, count } = await this.reactionsService.findByComment({ commentId: comment.id, page: query.page, limit: query.limit });
    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );
    return new PaginatedResponseDto(data.map(ReactionResponseDto.fromEntity), paginationMeta);
  }

  @Patch('comments/:commentId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async updateCommentReaction(
    @Param('reactionId', CommentReactionPipe) reaction: CommentReaction,
    @Body() dto: UpdateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Update, reaction);
    const updatedReaction = await this.reactionsService.updateCommentReaction({ id:reaction.id,
      type: dto.type});
    return new ResponseDto(ReactionResponseDto.fromEntity(updatedReaction));
  }

  @Delete('posts/:postId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async deletePostReaction(
    @Param('reactionId', PostReactionPipe) reaction: PostReaction,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, reaction);
    await this.reactionsService.deletePostReaction(reaction.id);
    return new ResponseDto(true);
  }

  @Delete('comments/:commentId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async deleteCommentReaction(
    @Param('reactionId', CommentReactionPipe) reaction: CommentReaction,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, reaction);
    await this.reactionsService.deleteCommentReaction(reaction.id);
    return new ResponseDto(true);
  }
}

---


### FILE: backend/src/reactions/reactions.types.ts ###
export enum ReactionType {
  LIKE = 'like',
  DISLIKE = 'dislike',
}

---


### FILE: backend/src/reactions/reactions.service.ts ###
import {
  Injectable,
  BadRequestException,
  ForbiddenException,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm'; // Added DataSource

import { PostReaction } from './entities/post-reaction.entity';
import { CommentReaction } from './entities/comment-reaction.entity';
import { ReactionType } from './reactions.types';
// import { PostsService } from 'src/posts/posts.service'; // Removed
// import { CommentsService } from 'src/comments/comments.service'; // Removed
import { UpdateReactionDto } from './dto/update-reaction.dto';
import { Post } from 'src/posts/entities/post.entity'; // Added Post entity
import { Comment } from 'src/comments/entities/comment.entity'; // Added Comment entity

@Injectable()
export class ReactionsService {
  constructor(
    @InjectRepository(PostReaction)
    private readonly postReactionRepo: Repository<PostReaction>,

    @InjectRepository(CommentReaction)
    private readonly commentReactionRepo: Repository<CommentReaction>,

    // private readonly postsService: PostsService, // Removed
    // private readonly commentsService: CommentsService, // Removed
    @InjectRepository(Post) // Injected Post repository
    private readonly postRepo: Repository<Post>,
    @InjectRepository(Comment) // Injected Comment repository
    private readonly commentRepo: Repository<Comment>,
    private dataSource: DataSource, // Injected DataSource
  ) { }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // CREATE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async create({
    type,
    userId,
    postId,
    commentId,
  }: {
    type: ReactionType;
    userId: number;
    postId?: number;
    commentId?: number;
  }) {
    if (!Object.values(ReactionType).includes(type)) {
      throw new BadRequestException('Invalid reaction type');
    }

    if (!!postId === !!commentId) {
      throw new BadRequestException(
        'Reaction must target either a post or a comment (not both)',
      );
    }

    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      if (postId) {
        const post = await queryRunner.manager.findOne(Post, { where: { id: postId } });
        if (!post) throw new NotFoundException(`Post with ID ${postId} not found`);

        const existing = await queryRunner.manager.findOne(PostReaction, {
          where: { userId, postId },
        });
        
        if (existing) {
          throw new ForbiddenException(
            'You already reacted to this post',
          );
        }

        const newReaction = queryRunner.manager.create(PostReaction, { type, userId, postId });
        await queryRunner.manager.save(newReaction);

        if (newReaction.type === ReactionType.LIKE) {
          await queryRunner.manager.increment(Post, { id: postId }, 'likesCount', 1);
        } else {
          await queryRunner.manager.increment(Post, { id: postId }, 'dislikesCount', 1);
        }
        await queryRunner.commitTransaction();
        return newReaction;
      }
      else if (commentId) {
        const comment = await queryRunner.manager.findOne(Comment, { where: { id: commentId } });
        if (!comment) throw new NotFoundException(`Comment with ID ${commentId} not found`);

        const existing = await queryRunner.manager.findOne(CommentReaction, {
          where: { userId, commentId },
        });

        if (existing) {
          throw new ForbiddenException(
            'You already reacted to this comment',
          );
        }

        const newReaction = queryRunner.manager.create(CommentReaction, { type, userId, commentId });
        await queryRunner.manager.save(newReaction);

        if (newReaction.type === ReactionType.LIKE) {
          await queryRunner.manager.increment(Comment, { id: commentId }, 'likesCount', 1);
        } else {
          await queryRunner.manager.increment(Comment, { id: commentId }, 'dislikesCount', 1);
        }
        await queryRunner.commitTransaction();
        return newReaction;
      }
      throw new BadRequestException(
        'Reaction must target either a post or a comment',
      );
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }  async findByPost({
    postId,
    page = 1,
    limit = 10,
  }: {
    postId: number;
    page?: number;
    limit?: number;
  }): Promise<{ data: PostReaction[]; count: number }> {
    const skip = (page - 1) * limit;

    const [data, count] = await this.postReactionRepo.findAndCount({
      where: { postId },
      relations: ['user'],
      select: {
        id: true,
        type: true,
        createdAt: true,
        user: { id: true, username: true },
      },
      skip,
      take: limit,
    });

    return { data, count };
  }

  async findByComment({
    commentId,
    page = 1,
    limit = 10,
  }: {
    commentId: number;
    page?: number;
    limit?: number;
  }): Promise<{ data: CommentReaction[]; count: number }> {
    const skip = (page - 1) * limit;

    const [data, count] = await this.commentReactionRepo.findAndCount({
      where: { commentId },
      relations: ['user'],
      select: {
        id: true,
        type: true,
        createdAt: true,
        user: { id: true, username: true },
      },
      skip,
      take: limit,
    });

    return { data, count };
  }

  async getUserReactionOnPost(
    userId: number,
    postId: number,
  ) {
    return this.postReactionRepo.findOne({ where: { userId, postId } });
  }

  async findPostReactionById(id: number): Promise<PostReaction> {
    const reaction = await this.postReactionRepo.findOne({ where: { id } });
    if (!reaction) {
      throw new NotFoundException('Post reaction not found');
    }
    return reaction;
  }

  async findCommentReactionById(id: number): Promise<CommentReaction> {
    const reaction = await this.commentReactionRepo.findOne({ where: { id } });
    if (!reaction) {
      throw new NotFoundException('Comment reaction not found');
    }
    return reaction;
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // UPDATE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 async updatePostReaction({
  id,
  type
}: {
  id: number;
  type: ReactionType;
}) {
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();

  try {
    const reaction = await queryRunner.manager.findOne(PostReaction, { where: { id } });
    if (!reaction) throw new NotFoundException('Post reaction not found');
    
    // Return early if no change
    if (reaction.type === type) {
      await queryRunner.commitTransaction();
      return reaction;
    }

    const oldType = reaction.type;
    const newType = type;
    const postId = reaction.postId;

    // Update counters based on change
    if (oldType === ReactionType.LIKE) {
      await queryRunner.manager.decrement(Post, { id: postId }, 'likesCount', 1);
    } else if (oldType === ReactionType.DISLIKE) {
      await queryRunner.manager.decrement(Post, { id: postId }, 'dislikesCount', 1);
    }

    if (newType === ReactionType.LIKE) {
      await queryRunner.manager.increment(Post, { id: postId }, 'likesCount', 1);
    } else if (newType === ReactionType.DISLIKE) {
      await queryRunner.manager.increment(Post, { id: postId }, 'dislikesCount', 1);
    }

    // Update reaction type
    reaction.type = newType;
    await queryRunner.manager.save(reaction);

    await queryRunner.commitTransaction();
    return reaction;
  } catch (err) {
    await queryRunner.rollbackTransaction();
    throw err;
  } finally {
    await queryRunner.release();
  }
}

async updateCommentReaction({
  id,
  type
}: {
  id: number;
  type: ReactionType;
}) {
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();

  try {
    const reaction = await queryRunner.manager.findOne(CommentReaction, { where: { id } });
    if (!reaction) throw new NotFoundException('Comment reaction not found');

    // Return early if no change
    if (reaction.type === type) {
      await queryRunner.commitTransaction();
      return reaction;
    }

    const oldType = reaction.type;
    const newType = type;
    const commentId = reaction.commentId;

    // Update counters based on change
    if (oldType === ReactionType.LIKE) {
      await queryRunner.manager.decrement(Comment, { id: commentId }, 'likesCount', 1);
    } else if (oldType === ReactionType.DISLIKE) {
      await queryRunner.manager.decrement(Comment, { id: commentId }, 'dislikesCount', 1);
    }

    if (newType === ReactionType.LIKE) {
      await queryRunner.manager.increment(Comment, { id: commentId }, 'likesCount', 1);
    } else if (newType === ReactionType.DISLIKE) {
      await queryRunner.manager.increment(Comment, { id: commentId }, 'dislikesCount', 1);
    }

    // Update reaction type
    reaction.type = newType;
    await queryRunner.manager.save(reaction);

    await queryRunner.commitTransaction();
    return reaction;
  } catch (err) {
    await queryRunner.rollbackTransaction();
    throw err;
  } finally {
    await queryRunner.release();
  }
}
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // DELETE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async deletePostReaction(id: number) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const reaction = await queryRunner.manager.findOne(PostReaction, { where: { id } });
      if (!reaction) {
        throw new NotFoundException('Post reaction not found');
      }

      const result = await queryRunner.manager.delete(PostReaction, id);
      if (result.affected) {
        // No need to fetch post explicitly, can directly decrement
        if (reaction.type === ReactionType.LIKE) {
          await queryRunner.manager.decrement(Post, { id: reaction.postId }, 'likesCount', 1);
        } else {
          await queryRunner.manager.decrement(Post, { id: reaction.postId }, 'dislikesCount', 1);
        }
      }
      await queryRunner.commitTransaction();
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }
  async deleteCommentReaction(id: number) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const reaction = await queryRunner.manager.findOne(CommentReaction, { where: { id } });
      if (!reaction) {
        throw new NotFoundException('Comment reaction not found');
      }

      const result = await queryRunner.manager.delete(CommentReaction, id);
      if (result.affected) {
        // No need to fetch comment explicitly, can directly decrement
        if (reaction.type === ReactionType.LIKE) {
          await queryRunner.manager.decrement(Comment, { id: reaction.commentId }, 'likesCount', 1);
        } else {
          await queryRunner.manager.decrement(Comment, { id: reaction.commentId }, 'dislikesCount', 1);
        }
      }
      await queryRunner.commitTransaction();
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }}

---


### FILE: backend/src/reactions/reactions.module.ts ###
import { Module } from '@nestjs/common';
import { ReactionsService } from './reactions.service';
import { ReactionsController } from './reactions.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PostReaction } from './entities/post-reaction.entity';
import { CommentReaction } from './entities/comment-reaction.entity';
import { CaslModule } from 'src/casl/casl.module';
import { PostsModule } from 'src/posts/posts.module';
import { CommentsModule } from 'src/comments/comments.module';

import { Post } from 'src/posts/entities/post.entity';
import { Comment } from 'src/comments/entities/comment.entity';

@Module({
  providers: [ReactionsService],
  controllers: [ReactionsController],
  imports: [
    TypeOrmModule.forFeature([PostReaction, CommentReaction, Post, Comment]),
    CaslModule,
    PostsModule,
    CommentsModule,
  ],
  exports: [ReactionsService],
})
export class ReactionsModule {}

---


### FILE: backend/src/reactions/entities/post-reaction.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  Index,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { ReactionType } from '../../reactions/reactions.types'; // Assuming ReactionType is still needed and will be moved or re-defined

@Entity('post_reactions')
@Index(['postId', 'userId'], { unique: true }) // Ensure a user can only react once to a post
export class PostReaction {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'simple-enum',
    enum: ReactionType,
  })
  type: ReactionType;

  @ManyToOne(() => Post, (post) => post.reactions, { onDelete: 'CASCADE' })
  post: Post;

  @Column()
  postId: number;

  @ManyToOne(() => User, (user) => user.postReactions, { onDelete: 'CASCADE' })
  user: User;

  @Column()
  userId: number;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

---


### FILE: backend/src/reactions/entities/comment-reaction.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  Index,
} from 'typeorm';
import { Comment } from '../../comments/entities/comment.entity'; // Corrected path
import { User } from '../../users/entities/user.entity';
import { ReactionType } from '../../reactions/reactions.types'; // Assuming ReactionType is still needed and will be moved or re-defined

@Entity('comment_reactions')
@Index(['commentId', 'userId'], { unique: true }) // Ensure a user can only react once to a comment
export class CommentReaction {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'simple-enum',
    enum: ReactionType,
  })
  type: ReactionType;

  @ManyToOne(() => Comment, (comment) => comment.reactions, {
    onDelete: 'CASCADE',
  })
  comment: Comment;

  @Column()
  commentId: number;

  @ManyToOne(() => User, (user) => user.commentReactions, {
    onDelete: 'CASCADE',
  })
  user: User;

  @Column()
  userId: number;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

---


### FILE: backend/src/reactions/dto/reaction-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsEnum, IsInt } from 'class-validator';
import { Type } from 'class-transformer';
import { ReactionType } from '../reactions.types';

export class ReactionQueryDto extends PaginationDto {
  @IsOptional()
  @IsEnum(ReactionType)
  type?: ReactionType;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  userId?: number;
}

---


### FILE: backend/src/reactions/dto/reaction-response.dto.ts ###
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { PostReaction } from '../entities/post-reaction.entity';
import { CommentReaction } from '../entities/comment-reaction.entity';
import { ReactionType } from '../reactions.types';

@Exclude()
export class ReactionResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly type: ReactionType;
  @Expose() @Type(() => UserResponseDto) readonly user: UserResponseDto;
  @Expose() postId?: number;
  @Expose() commentId?: number;
  @Expose() readonly createdAt: Date;

  static fromEntity(
    entity: PostReaction | CommentReaction,
  ): ReactionResponseDto {
    const dto = plainToInstance(
      ReactionResponseDto,
      {
        ...entity,
        user: entity.user ? UserResponseDto.fromEntity(entity.user) : null,
      },
      { excludeExtraneousValues: true },
    );

    if ('postId' in entity) {
      dto.postId = entity.postId;
      dto.commentId = undefined; // Ensure commentId is not set if it's a post reaction
    } else if ('commentId' in entity) {
      dto.commentId = entity.commentId;
      dto.postId = undefined; // Ensure postId is not set if it's a comment reaction
    }

    return dto;
  }
}

---


### FILE: backend/src/reactions/dto/update-reaction.dto.ts ###
import { IsEnum } from 'class-validator';
import { ReactionType } from '../reactions.types';

export class UpdateReactionDto {
  @IsEnum(ReactionType)
  type: ReactionType;
}
---


### FILE: backend/src/reactions/dto/create-reaction.dto.ts ###
import { IsEnum } from 'class-validator';
import { ReactionType } from '../reactions.types';

export class CreateReactionDto {
  @IsEnum(ReactionType)
  type: ReactionType;
}

---


### FILE: backend/src/common/dto/pagination-meta.dto.ts ###

export class PaginationMetaDto {
  page: number;

  limit: number;

  totalItems: number;

  totalPages: number;

  itemCount: number;

  constructor(page: number, limit: number, totalItems: number, itemCount: number) {
    this.page = page;
    this.limit = limit;
    this.totalItems = totalItems;
    this.itemCount = itemCount;
    this.totalPages = Math.ceil(this.totalItems / this.limit);
  }
}

---


### FILE: backend/src/common/dto/response.dto.ts ###

export class ResponseDto<T> {
  data: T;

  message?: string;

  meta?: {
    count?: number;
    total?: number;
    [key: string]: any;
  };

  constructor(data: T, message?: string, meta?: { count?: number; total?: number; [key: string]: any }) {
    this.data = data;
    this.message = message;
    this.meta = meta;
  }
}

---


### FILE: backend/src/common/dto/pagination.dto.ts ###
import { Type } from 'class-transformer';
import { IsInt, Min, IsOptional } from 'class-validator';

export class PaginationDto {
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page: number = 1; // default 1

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  limit: number = 10; // default 10
}

---


### FILE: backend/src/common/dto/paginated-response.dto.ts ###
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { PaginationMetaDto } from './pagination-meta.dto';
import { ResponseDto } from './response.dto';

export class PaginatedResponseDto<T> extends ResponseDto<T[]> {
  data: T[];

  @Type(() => PaginationMetaDto)
  @ValidateNested()
  meta: PaginationMetaDto;

  constructor(data: T[], meta: PaginationMetaDto) {
    super(data,undefined, meta);
    this.data = data;
    this.meta = meta;
  }
}

---


### FILE: backend/src/reports/reports.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ReportsService } from './reports.service';
import { ReportsController } from './reports.controller';
import { CommentReport } from './entities/comment-report.entity';
import { PostReport } from './entities/post-report.entity';
import { UserReport } from './entities/user-report.entity';
import { Post } from 'src/posts/entities/post.entity';
import { User } from 'src/users/entities/user.entity';
import { Comment } from 'src/comments/entities/comment.entity';
import { CaslModule } from 'src/casl/casl.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([
      CommentReport,
      PostReport,
      UserReport,
      Post,
      User,
      Comment,
    ]),
    CaslModule,
  ],
  controllers: [ReportsController],
  providers: [ReportsService],
})
export class ReportsModule {}

---


### FILE: backend/src/reports/reports.controller.ts ###
import { Controller, Post, Body, UseGuards, Patch, Param, Get, Query } from '@nestjs/common';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';
import { ReportsService } from './reports.service';
import { ReportQueryDto } from './dto/report-query.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { ReportResponseDto } from './dto/report-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { ResponseDto } from 'src/common/dto/response.dto';

@Controller('reports')
@UseGuards(JwtAuthGuard)
export class ReportsController {
  constructor(private readonly reportsService: ReportsService) {}

  @Post()
  async createReport(
    @Body() createReportDto: CreateReportDto,
    @GetUser() user: User,
  ) {
    return this.reportsService.create(createReportDto, user);
  }

  @Get()
  async findAll(
    @Query() query: ReportQueryDto & { communityId?: number },
    @GetUser() user: User,
  ): Promise<PaginatedResponseDto<ReportResponseDto>> {
    const { data, count } = await this.reportsService.findAll({
      ...query,
      userId: user.id,
    });
    const paginationMeta = new PaginationMetaDto(query.page, query.limit, count, data.length); // Use defaulted values
    return new PaginatedResponseDto(data.map(ReportResponseDto.fromEntity), paginationMeta);
  }

  @Get(':id')
  async findOne(@Param('id') id: number, @Query('entityType') entityType: 'comment' | 'post' | 'user'): Promise<ResponseDto<ReportResponseDto>> {
    const report = await this.reportsService.findOne(id, entityType);
    return new ResponseDto(ReportResponseDto.fromEntity(report));
  }

  @Patch(':id')
  async updateReportStatus(
    @Param('id') id: number,
    @Body() updateReportDto: UpdateReportDto,
  ) {
    // TODO: Add authorization check for moderators
    return this.reportsService.updateStatus(id, updateReportDto.status, updateReportDto.entityType);
  }
}

---


### FILE: backend/src/reports/entities/comment-report.entity.ts ###
import {
  Entity,
  Column,
  ManyToOne,
} from 'typeorm';
import { Comment } from '../../comments/entities/comment.entity';
import { BaseReport } from './base-report.entity';
import { User } from '../../users/entities/user.entity';

@Entity('comment_reports')
export class CommentReport extends BaseReport {
  @ManyToOne(() => User, (user) => user.commentReports, { onDelete: 'CASCADE' })
  reporter: User;

  @Column()
  commentId: number;

    @Column()
  communityId: number;

  @ManyToOne(() => Comment, (comment) => comment.reports, { onDelete: 'CASCADE' })
  comment: Comment;

  @Column({ default: false })
  isPlatformComplaint: boolean;
}
---


### FILE: backend/src/reports/entities/post-report.entity.ts ###
import {
  Entity,
  Column,
  ManyToOne,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { BaseReport } from './base-report.entity';
import { User } from '../../users/entities/user.entity'; // User import not needed here as reporter is inherited

@Entity('post_reports')
export class PostReport extends BaseReport {

 @ManyToOne(() => User, (user) => user.postReports, { onDelete: 'CASCADE' })
  reporter: User;

  @Column()
  postId: number;


  @Column()
  communityId: number;

  @ManyToOne(() => Post, (post) => post.reports, { onDelete: 'CASCADE' })
  post: Post;

  @Column({ default: false })
  isPlatformComplaint: boolean;
}
---


### FILE: backend/src/reports/entities/user-report.entity.ts ###
import {
  Entity,
  Column,
  ManyToOne,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { BaseReport } from './base-report.entity';

@Entity('user_reports')
export class UserReport extends BaseReport {
  @ManyToOne(() => User, (user) => user.reportedUserReports, { onDelete: 'CASCADE' })
  reporter: User;

  @Column()
  reportedUserId: number;

  @ManyToOne(() => User, (user) => user.userReports, { onDelete: 'CASCADE' })
  reportedUser: User;

  @Column({ default: false })
  isPlatformComplaint: boolean;
}
---


### FILE: backend/src/reports/entities/base-report.entity.ts ###
import {
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';

export enum ReportStatus {
  PENDING = 'pending',
  RESOLVED = 'resolved',
  DISMISSED = 'dismissed',
}

export abstract class BaseReport {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  reporterId: number;
/*
  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  reporter: User;
*/
  @Column()
  reason: string;

  @Column({ type: 'text', nullable: true })
  description: string;

  @Column({
    type: 'simple-enum',
    enum: ReportStatus,
    default: ReportStatus.PENDING,
  })
  status: ReportStatus;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

}

---


### FILE: backend/src/reports/reports.service.ts ###
import {
  Injectable,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User, UserRole } from 'src/users/entities/user.entity';
import { Comment } from 'src/comments/entities/comment.entity';
import { Post } from 'src/posts/entities/post.entity';
import { CommentReport } from './entities/comment-report.entity';
import { PostReport } from './entities/post-report.entity';
import { UserReport } from './entities/user-report.entity';
import { ReportStatus } from './entities/base-report.entity';


const PLATFORM_COMPLAINT_REASONS = [
  'HARASSMENT',
  'VIOLENCE',
  'HATE_CONTENT',
  'MINOR_ABUSE_OR_SEXUALIZATION',
  'PII',
  'INVOLUNTARY_PORN',
  'PROHIBITED_SALES',
  'IMPERSONATION',
  'MANIPULATED_CONTENT',
  'COPYRIGHT',
  'TRADEMARK',
  'SELF_HARM',
  'SPAM',
  'CONTRIBUTOR_PROGRAM',
];

@Injectable()
export class ReportsService {
  constructor(
    @InjectRepository(CommentReport)
    private readonly commentReportRepository: Repository<CommentReport>,

    @InjectRepository(PostReport)
    private readonly postReportRepository: Repository<PostReport>,

    @InjectRepository(UserReport)
    private readonly userReportRepository: Repository<UserReport>,

    @InjectRepository(Comment)
    private readonly commentsRepository: Repository<Comment>,

    @InjectRepository(Post)
    private readonly postsRepository: Repository<Post>,

    @InjectRepository(User)
    private readonly usersRepository: Repository<User>,


  ) { }

  async create(
    {
      entityType,
      entityId,
      reason,
      description,
    }: {
      entityType: 'comment' | 'post' | 'user';
      entityId: number;
      reason: string;
      description?: string;
    },
    reporter: User,
  ) {
    const isPlatformComplaint = PLATFORM_COMPLAINT_REASONS.includes(
      reason.toUpperCase(),
    );

    if (entityType === 'comment') {
      const entity = await this.commentsRepository.findOne({
        where: { id: entityId },
      });
      if (!entity) throw new NotFoundException('Comment not found');

      const existingReport = await this.commentReportRepository.findOne({
        where: { commentId: entityId, reporterId: reporter.id },
      });
      if (existingReport) {
        throw new ConflictException('You have already reported this comment');
      }

      const report = this.commentReportRepository.create({
        reporterId: reporter.id,
        commentId: entityId,
        reason,
        description,
        isPlatformComplaint,
      });
      return this.commentReportRepository.save(report);
    }

    if (entityType === 'post') {
      const entity = await this.postsRepository.findOne({
        where: { id: entityId },
      });
      if (!entity) throw new NotFoundException('Post not found');

      const existingReport = await this.postReportRepository.findOne({
        where: { postId: entityId, reporterId: reporter.id },
      });
      if (existingReport) {
        throw new ConflictException('You have already reported this post');
      }

      const report = this.postReportRepository.create({
        reporterId: reporter.id,
        postId: entityId,
        reason,
        description,
        isPlatformComplaint,
        communityId: (entity as Post).communityId,
      });
      return this.postReportRepository.save(report);
    }

    if (entityType === 'user') {
      const entity = await this.usersRepository.findOne({
        where: { id: entityId },
      });
      if (!entity) throw new NotFoundException('User not found');

      if (entity.id === reporter.id) {
        throw new ConflictException('You cannot report yourself');
      }

      const existingReport = await this.userReportRepository.findOne({
        where: { reportedUserId: entityId, reporterId: reporter.id },
      });
      if (existingReport) {
        throw new ConflictException('You have already reported this user');
      }

      const report = this.userReportRepository.create({
        reporterId: reporter.id,
        reportedUserId: entityId,
        reason,
        description,
        isPlatformComplaint,
      });
      return this.userReportRepository.save(report);
    }
  }

  async findAll({
    page = 1,
    limit = 10,
    status,
    entityType,
    reporterId,
    userId,
    communityId,
  }: {
    page?: number;
    limit?: number;
    status?: ReportStatus;
    entityType?: 'comment' | 'post' | 'user';
    reporterId?: number;
    userId: number;
    communityId?: number;
  }): Promise<{ data: (CommentReport | PostReport | UserReport)[]; count: number }> {
    const offset = (page - 1) * limit;


    const user = await this.usersRepository.findOne({
      where: { id: userId },
    });

    if (!user) {
      throw new NotFoundException(`User ${userId} not found`);
    }


    const parameters: any[] = [];
    let paramIndex = 1;

    const buildSelectQuery = (
      tableName: string,
      type: string,
      specificIdColumn: string,
    ) => {
      const whereClauses: string[] = [];

      if (status) {
        whereClauses.push(`status = $${paramIndex++}`);
        parameters.push(status);
      }

      if (reporterId) {
        whereClauses.push(`"reporterId" = $${paramIndex++}`);
        parameters.push(reporterId);
      }

      if (user.role == UserRole.ADMIN) {
        whereClauses.push(`"isPlatformComplaint" = TRUE`);
      } else {
        whereClauses.push(`"isPlatformComplaint" = FALSE`);
      }

      if (entityType && entityType !== type) return null;

      const where =
        whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';

      return `
        SELECT
          id,
          "reporterId",
          reason,
          description,
          status,
          "createdAt",
          "updatedAt",
          "isPlatformComplaint",
          "communityId",
          ${specificIdColumn} AS "entitySpecificId",
          '${type}' AS "entityType"
        FROM ${tableName}
        ${where}
      `;
    };

    const unionQueries = [
      buildSelectQuery('comment_reports', 'comment', 'commentId'),
      buildSelectQuery('post_reports', 'post', 'postId'),
      buildSelectQuery('user_reports', 'user', 'reportedUserId'),
    ].filter(Boolean);

    if (!unionQueries.length) {
      return { data: [], count: 0 };
    }

    const unionAllQuery = unionQueries.join(' UNION ALL ');

    const countQuery = `SELECT COUNT(*) FROM (${unionAllQuery}) AS union_counts`;
    const countResult = await this.commentReportRepository.query(
      countQuery,
      parameters,
    );
    const count = parseInt(countResult[0].count, 10);

    const dataQuery = `
      ${unionAllQuery}
      ORDER BY "createdAt" DESC
      LIMIT $${paramIndex++} OFFSET $${paramIndex++}
    `;
    parameters.push(limit, offset);

    const raw = await this.commentReportRepository.query(
      dataQuery,
      parameters,
    );

    const data = raw.map(item => ({
      id: item.id,
      reporterId: item.reporterId,
      reason: item.reason,
      description: item.description,
      status: item.status,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
      isPlatformComplaint: item.isPlatformComplaint,
      communityId: item.communityId,
      entityType: item.entityType,
      commentId: item.entityType === 'comment' ? item.entitySpecificId : undefined,
      postId: item.entityType === 'post' ? item.entitySpecificId : undefined,
      reportedUserId:
        item.entityType === 'user' ? item.entitySpecificId : undefined,
    }));

    return { data, count };
  }

  async findOne(
    id: number,
    entityType: 'comment' | 'post' | 'user',
  ): Promise<CommentReport | PostReport | UserReport> {
    let repository: Repository<any>;

    if (entityType === 'comment') repository = this.commentReportRepository;
    else if (entityType === 'post') repository = this.postReportRepository;
    else repository = this.userReportRepository;

    const report = await repository.findOne({ where: { id } });
    if (!report) {
      throw new NotFoundException(`Report ${id} not found`);
    }
    return report;
  }

  async updateStatus(
    id: number,
    status: ReportStatus,
    entityType: 'comment' | 'post' | 'user',
  ) {
    const report = await this.findOne(id, entityType);

    if (report.status === status) {
      throw new ConflictException(
        `Report is already with status "${status}"`,
      );
    }

    report.status = status;

    if (entityType === 'comment') {
      return this.commentReportRepository.save(report);
    }
    if (entityType === 'post') {
      return this.postReportRepository.save(report);
    }
    return this.userReportRepository.save(report);
  }
}

---


### FILE: backend/src/reports/dto/create-report.dto.ts ###
import { IsString, IsIn, IsNumber, IsOptional } from 'class-validator';

export class CreateReportDto {
  @IsString()
  reason: string;

  @IsIn(['comment', 'post', 'user'])
  entityType: 'comment' | 'post' | 'user';

  @IsNumber()
  entityId: number;

  @IsString()
  @IsOptional()
  description?: string;
}

---


### FILE: backend/src/reports/dto/report-response.dto.ts ###
import { ReportStatus } from '../entities/base-report.entity';
import { CommentReport } from '../entities/comment-report.entity';
import { PostReport } from '../entities/post-report.entity';
import { UserReport } from '../entities/user-report.entity';

export class ReportResponseDto {
  id: number;
  reason: string;
  description: string | null;
  status: ReportStatus;
  reporterId: number;
  createdAt: Date;
  updatedAt: Date;
  entityType: 'comment' | 'post' | 'user';
  commentId?: number;
  postId?: number;
  reportedUserId?: number;

  static fromEntity(
    report: CommentReport | PostReport | UserReport,
  ): ReportResponseDto {
    const dto = new ReportResponseDto();
    dto.id = report.id;
    dto.reason = report.reason;
    dto.description = report.description;
    dto.status = report.status;
    dto.reporterId = report.reporterId;
    dto.createdAt = report.createdAt;
    dto.updatedAt = report.updatedAt;

    if (report instanceof CommentReport) {
      dto.entityType = 'comment';
      dto.commentId = report.commentId;
    } else if (report instanceof PostReport) {
      dto.entityType = 'post';
      dto.postId = report.postId;
    } else if (report instanceof UserReport) {
      dto.entityType = 'user';
      dto.reportedUserId = report.reportedUserId;
    }

    return dto;
  }
}

---


### FILE: backend/src/reports/dto/report-query.dto.ts ###
import { IsOptional, IsIn, IsNumber, IsEnum } from 'class-validator';
import { ReportStatus } from '../entities/base-report.entity';
import { Transform } from 'class-transformer';
import { PaginationDto } from 'src/common/dto/pagination.dto';

export class ReportQueryDto extends PaginationDto {

  @IsOptional()
  @IsEnum(ReportStatus)
  status?: ReportStatus;

  @IsOptional()
  @IsIn(['comment', 'post', 'user'])
  entityType?: 'comment' | 'post' | 'user';

  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  @IsNumber()
  reporterId?: number;

  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  @IsNumber()
  communityId?: number;
}

---


### FILE: backend/src/reports/dto/update-report.dto.ts ###
import { IsEnum, IsIn } from 'class-validator';
import { ReportStatus } from '../entities/base-report.entity';

export class UpdateReportDto {
  @IsEnum(ReportStatus)
  status: ReportStatus;

  @IsIn(['comment', 'post', 'user'])
  entityType: 'comment' | 'post' | 'user';
}

---


### FILE: backend/src/decorators/user.decorator.ts ###
// src/decorators/current-user.decorator.ts
import {
  createParamDecorator,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { User } from 'src/users/entities/user.entity';

export const GetUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): User => {
    const request = ctx.switchToHttp().getRequest();

    // This comes from JwtStrategy.validate() ‚Üí req.user
    const user: User | undefined = request.user;

    if (!user) {
      throw new UnauthorizedException(
        'No authenticated user found. Token ff may be missing or invalid.',
      );
    }

    return user;
  },
);

---


### FILE: backend/src/email-verification/email-verification.controller.ts ###
import {
  Controller,
  Post,
  Body,
  BadRequestException,
  Query,
  Get,
  Res,
} from '@nestjs/common';
import { EmailVerificationService } from './email-verification.service';
import { SendVerificationDto } from './dto/send-verification.dto';
import { UsersService } from '../users/users.service';
import { ResponseDto } from 'src/common/dto/response.dto';
import type { Response } from 'express';
import { ConfigService } from '@nestjs/config';

@Controller('email')
export class EmailVerificationController {
  constructor(
    private readonly service: EmailVerificationService,
    private readonly usersService: UsersService,
    private readonly configService: ConfigService,
  ) { }

  @Post('resend')
  async resend(@Body() dto: SendVerificationDto): Promise<ResponseDto<null>> {
    const user = await this.usersService.findByEmail(dto.email);
    if (user && !user.emailVerifiedAt) {
      await this.service.sendVerificationEmail(user);
    }
    return new ResponseDto(null, 'If the email exists and is not verified, a new verification link has been sent.');
  }

  @Get('verify')
  async verify(
    @Query('token') token: string,
    @Res() res: Response,
  ): Promise<void> {
    const frontendUrl = this.configService.getOrThrow<string>(
      'FRONTEND_URL');
    const redirectUrl = new URL(`${frontendUrl}/verify-email`);

    if (!token) {
      redirectUrl.searchParams.set('error', 'Token is required');
      return res.redirect(redirectUrl.toString());
    }

    try {
      const userId = await this.service.verifyToken(token);
      await this.usersService.markEmailAsVerified(userId);

      redirectUrl.searchParams.set('success', '1');
      redirectUrl.searchParams.set( 'message',
        'Email verified successfully',
      );
    } catch (err) {
      const message =
        err instanceof BadRequestException
          ? err.message
          : 'Invalid or expired verification token';
      redirectUrl.searchParams.set('error', '1');
      redirectUrl.searchParams.set('message', message);
    }

    return res.redirect(redirectUrl.toString());
  }

}

---


### FILE: backend/src/email-verification/entities/email-verification-token.entity.ts ###
// src/email-verification/entities/email-verification-token.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
} from 'typeorm';

@Entity('email_verification_tokens')
export class EmailVerificationToken {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  token: string;

  @Column()
  userId: number;

  @Column()
  expiresAt: Date;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: backend/src/email-verification/email-verification.service.ts ###
import {
  Injectable,
  BadRequestException,
  InternalServerErrorException,
  Inject,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { randomUUID } from 'crypto';
import { EmailVerificationToken } from './entities/email-verification-token.entity';
import { User } from 'src/users/entities/user.entity';
import type { IMailService } from 'src/mail/interfaces/mail-service.interface';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class EmailVerificationService {
  constructor(
    @InjectRepository(EmailVerificationToken)
    private readonly tokenRepo: Repository<EmailVerificationToken>,
    private readonly configService: ConfigService,
    @Inject('IMailService')
    private readonly mailService: IMailService,
  ) {
    this.EXPIRATION_MS = this.configService.get<number>(
      'EMAIL_VERIFICATION_TOKEN_EXPIRATION',
      15 * 60 * 1000,
    );
  }
  EXPIRATION_MS: number;

  private async deleteExistingTokens(userId: number): Promise<void> {
    await this.tokenRepo.delete({ userId });
  }

  async generateToken(userId: number): Promise<string> {
    await this.deleteExistingTokens(userId);

    const token = randomUUID();
    const record = this.tokenRepo.create({
      token,
      userId,
      expiresAt: new Date(Date.now() + this.EXPIRATION_MS),
    });

    await this.tokenRepo.save(record);
    return token;
  }

  private generateVerificationLink(token: string): string {
    // You can move APP_DOMAIN to ConfigService if needed
    const domain = this.configService.get<string>('APP_DOMAIN'); // e.g. https://myapp.com
    const path = '/api/email/verify';
    return `${domain}${path}?token=${token}`;
  }

  async sendVerificationEmail(user: User): Promise<void> {
    const token = await this.generateToken(user.id);
    const verifyUrl = this.generateVerificationLink(token);

    try {
      await this.mailService.sendEmail(
        user.email,
        'Verify Your Email',
        'verify-email', // templateName (templates/verify-email.hbs)
        { username: user.username, verifyUrl }, // context for the template
      );
    } catch (err) {
      console.error('Error sending verification email:', err);
      throw new InternalServerErrorException(
        'Failed to send verification email',
      );
    }
  }

  async verifyToken(token: string): Promise<number> {
    const record = await this.tokenRepo.findOne({ where: { token } });

    if (!record) throw new BadRequestException('Invalid token');
    if (record.expiresAt < new Date()) {
      await this.tokenRepo.delete({ token });
      throw new BadRequestException('Token expired');
    }

    await this.tokenRepo.delete({ token });
    return record.userId;
  }
}

---


### FILE: backend/src/email-verification/dto/verify-email.dto.ts ###
export class VerifyEmailDto {
  token: string;
}

---


### FILE: backend/src/email-verification/dto/send-verification.dto.ts ###
import { IsEmail, IsNotEmpty } from 'class-validator';

export class SendVerificationDto {
  @IsNotEmpty()
  @IsEmail()
  email: string; // ‚úÖ Use email, a public identifier
}

---


### FILE: backend/src/email-verification/email-verification.module.ts ###
// src/email-verification/email-verification.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { EmailVerificationService } from './email-verification.service';
import { EmailVerificationController } from './email-verification.controller';
import { EmailVerificationToken } from './entities/email-verification-token.entity';
import { UsersModule } from 'src/users/users.module';
import { MailModule } from 'src/mail/mail.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([EmailVerificationToken]),
    UsersModule,
    MailModule,
  ],
  controllers: [EmailVerificationController],
  providers: [EmailVerificationService],
  exports: [EmailVerificationService],
})
export class EmailVerificationModule {}

---


### FILE: backend/src/casl/casl.types.ts ###
export enum Action {
  Manage = 'manage',
  Create = 'create',
  Read = 'read',
  Update = 'update',
  Delete = 'delete',
}

---


### FILE: backend/src/casl/casl.service.ts ###
import { Injectable, ForbiddenException } from '@nestjs/common';
// 1. Import 'Subjects' from your CASL ability factory
import {
  CaslAbilityFactory,
  AppAbility,
  Subjects,
} from './casl-ability.factory';
import { Action } from './casl.types';

@Injectable()
export class CaslService {
  constructor(private readonly caslAbilityFactory: CaslAbilityFactory) {}

  /**
   * Private helper method to create the ability object.
   */
  private getAbility(user: any): AppAbility {
    return this.caslAbilityFactory.createForUser(user);
  }

  /**
   * Checks if user can perform an action on a specific resource.
   * Throws ForbiddenException if not allowed.
   */
  // 2. Add 'extends Subjects' constraint to generic type T
  enforce<T extends Subjects>(user: any, action: Action, resource: T): void {
    const ability = this.getAbility(user);

    if (!ability.can(action, resource)) {
      throw new ForbiddenException(
        'You are not allowed to perform this action',
      );
    }
  }

  /**
   * Returns true/false without throwing.
   */
  // 3. Add 'extends Subjects' constraint to generic type T
  can<T extends Subjects>(user: any, action: Action, resource: T): boolean {
    const ability = this.getAbility(user);

    return ability.can(action, resource);
  }
}

---


### FILE: backend/src/casl/policies.guard.ts ###
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { CaslAbilityFactory, AppAbility } from './casl-ability.factory';
import { CHECK_POLICIES_KEY } from './check-policies.decorator';
import { PolicyHandler } from './policy-handler.interface';

@Injectable()
export class PoliciesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private caslAbilityFactory: CaslAbilityFactory,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const policyHandlers =
      this.reflector.get<PolicyHandler[]>(
        CHECK_POLICIES_KEY,
        context.getHandler(),
      ) || [];

    const { user } = context.switchToHttp().getRequest();

    const ability = this.caslAbilityFactory.createForUser(user);

    return policyHandlers.every((handler) =>
      this.execPolicyHandler(handler, ability),
    );
  }

  private execPolicyHandler(handler: PolicyHandler, ability: AppAbility) {
    if (typeof handler === 'function') {
      return handler(ability);
    }
    return handler.handle(ability);
  }
}

---


### FILE: backend/src/casl/casl-ability.factory.ts ###
import {
  AbilityBuilder,
  createMongoAbility,
  MongoAbility,
  InferSubjects,
  ExtractSubjectType,
} from '@casl/ability';
import { Injectable } from '@nestjs/common';
import { User } from '../users/entities/user.entity';
import { Post } from '../posts/entities/post.entity';
import { Comment } from '../comments/entities/comment.entity';
import { PostReaction } from '../reactions/entities/post-reaction.entity';
import { CommentReaction } from '../reactions/entities/comment-reaction.entity';
import { Action } from './casl.types';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembershipRole } from 'src/community-memberships/types';
import { CommunityType } from 'src/communities/types';

export type Subjects =
  | InferSubjects<
    | typeof Post
    | typeof Comment
    | typeof PostReaction
    | typeof CommentReaction
    | typeof User
    | typeof Community
  >
  | 'all';

export type AppAbility = MongoAbility<[Action, Subjects]>;

@Injectable()
export class CaslAbilityFactory {
  createForUser(user: User) {
    const { can, cannot, build } = new AbilityBuilder<AppAbility>(
      createMongoAbility,
    );

    // ---- Post Permissions ----
    can(Action.Read, Post); // any post
    can(Action.Create, Post);
    can(Action.Update, Post, { authorId: user.id }); // only own
    can(Action.Delete, Post, { authorId: user.id });

    // ---- Comment Permissions ----
    can(Action.Read, Comment);
    can(Action.Create, Comment);
    can(Action.Update, Comment, { authorId: user.id });
    can(Action.Delete, Comment, { authorId: user.id });

    // ---- Reaction Permissions ----
    // PostReaction
    can(Action.Create, PostReaction);
    can(Action.Delete, PostReaction, { userId: user.id });
    can(Action.Update, PostReaction, { userId: user.id });


    // CommentReaction
    can(Action.Create, CommentReaction);
    can(Action.Delete, CommentReaction, { userId: user.id });
    can(Action.Update, CommentReaction, { userId: user.id });

    can(Action.Delete, Community, { ownerId: user.id });
    can(Action.Update, Community, { ownerId: user.id });



    return build({
      detectSubjectType: (item) =>
        item.constructor as ExtractSubjectType<Subjects>,
    });
  }
}

---


### FILE: backend/src/casl/casl.module.ts ###
import { Module } from '@nestjs/common';
import { CaslAbilityFactory } from './casl-ability.factory';
import { CaslService } from './casl.service';

@Module({
  providers: [CaslAbilityFactory, CaslService],
  exports: [CaslAbilityFactory, CaslService],
})
export class CaslModule {}

---


### FILE: backend/src/casl/policy-handler.interface.ts ###
import { AppAbility } from '../casl/casl-ability.factory';

interface IPolicyHandler {
  handle(ability: AppAbility): boolean;
}

type PolicyHandlerCallback = (ability: AppAbility) => boolean;

export type PolicyHandler = IPolicyHandler | PolicyHandlerCallback;

---


### FILE: backend/src/casl/check-policies.decorator.ts ###
import { SetMetadata } from '@nestjs/common';
import { PolicyHandler } from './policy-handler.interface';

export const CHECK_POLICIES_KEY = 'check_policy';
export const CheckPolicies = (...handlers: PolicyHandler[]) =>
  SetMetadata(CHECK_POLICIES_KEY, handlers);

---


### FILE: backend/src/casl/index.ts ###
export * from './casl.types';
export * from './casl-ability.factory';
export * from './policy-handler.interface';
export * from './check-policies.decorator';
export * from './policies.guard';
export * from './casl.module';

---


### FILE: backend/src/posts/pipes/post.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { PostsService } from '../posts.service';
import { Post } from '../entities/post.entity';

@Injectable()
export class PostPipe implements PipeTransform<string, Promise<Post>> {
  constructor(private readonly postsService: PostsService) {}

  async transform(value: string): Promise<Post> {
    const post = await this.postsService.findOne(+value);

    if (!post) {
      throw new NotFoundException('Post not found');
    }

    return post;
  }
}

---


### FILE: backend/src/posts/posts.module.ts ###
import { Module } from '@nestjs/common';
import { PostsService } from './posts.service';
import { PostsController } from './posts.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Post } from './entities/post.entity';
import { CaslModule } from 'src/casl/casl.module';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';

@Module({
  imports: [TypeOrmModule.forFeature(
    [Post, Community, CommunityMembership]),
    CaslModule,

  ],
  providers: [PostsService],
  controllers: [PostsController],
  exports: [PostsService],
})
export class PostsModule { }

---


### FILE: backend/src/posts/posts.service.ts ###
import { BadRequestException, ForbiddenException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Brackets, Repository } from 'typeorm';
import { Post, PostStatus } from './entities/post.entity';
import { PostSort } from './dto/post-query.dto';
import { CommunityType } from 'src/communities/types';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';
import { CommunityMembershipRole } from 'src/community-memberships/types';

@Injectable()
export class PostsService {
  constructor(
    @InjectRepository(Post)
    private postsRepository: Repository<Post>,
    @InjectRepository(Community)
    private readonly communityRepository: Repository<Community>,

    @InjectRepository(CommunityMembership)
    private readonly membershipRepository: Repository<CommunityMembership>) { }
  async findAll(
    options: {
      page?: number;
      limit?: number;
      search?: string;
      authorId?: number;
      sort?: PostSort;
      startDate?: Date;
      endDate?: Date;
      currentUserId?: number;
      communityId?: number;
      status?: PostStatus;
    },
  ): Promise<{
    data: Post[];
    count: number;
  }> {
    const {
      page = 1,
      limit = 10,
      search,
      authorId,
      sort,
      startDate,
      endDate,
      currentUserId,
      communityId,
      status = PostStatus.APPROVED,
    } = options;
    const query = this.postsRepository
      .createQueryBuilder('post')
      .leftJoinAndSelect('post.author', 'author')
      .leftJoinAndSelect('post.community', 'community');

    // Handle status filtering and authorization
    if (status === PostStatus.PENDING || status === PostStatus.REJECTED) {
      if (!currentUserId) {
        throw new ForbiddenException('You must be logged in to view pending or rejected posts.');
      }
      if (!communityId) {
        throw new BadRequestException('Cannot query for pending or rejected posts without a community ID.');
      }
      const isCommunityModerator = await this.isModerator(currentUserId, communityId);
      const isAuthor = authorId === currentUserId; // Assuming authorId is passed if filtering by author

      if (!isCommunityModerator && !isAuthor) {
        throw new ForbiddenException('You do not have permission to view this type of post in this community.');
      }

      // If user is author, they can see their own pending/rejected posts
      // If user is moderator, they can see all pending/rejected posts in their community
      if (status === PostStatus.PENDING) {
        query.andWhere('post.status = :status', { status: PostStatus.PENDING });
      } else if (status === PostStatus.REJECTED) {
        query.andWhere('post.status = :status', { status: PostStatus.REJECTED });
      }
    } else { // status === PostStatus.APPROVED
      query.andWhere('post.status = :status', { status: PostStatus.APPROVED });
    }

    if (currentUserId) {
      query.leftJoinAndMapOne(
        'post.userReaction',
        'post.reactions',
        'userReaction',
        'userReaction.userId = :currentUserId',
        { currentUserId },
      );
    }

    if (search) {
      query.andWhere(
        new Brackets((qb) => {
          qb.where('post.title LIKE :search', {
            search: `%${search}%`,
          }).orWhere('post.content LIKE :search', { search: `%${search}%` });
        }),
      );
    }

    if (authorId) {
      query.andWhere('post.author.id = :authorId', { authorId });
    }

    if (communityId) {
      query.andWhere('post.community.id = :communityId', { communityId });
    }

    if (startDate) {
      query.andWhere('post.createdAt >= :startDate', { startDate });
    }


    if (endDate) {
      query.andWhere('post.createdAt <= :endDate', { endDate });
    }

    if (sort === PostSort.POPULAR) {
      query
        .leftJoin('post.reactions', 'allReactions') // Join all reactions for the post
        .addSelect('COUNT(allReactions.id)', 'reactionCount')
        .groupBy('post.id')
        .orderBy('reactionCount', 'DESC');
    } else if (sort === PostSort.NEWEST) {
      query.orderBy('post.createdAt', 'DESC');
    } else if (sort === PostSort.OLDEST) {
      query.orderBy('post.createdAt', 'ASC');
    } else if (sort === PostSort.PUBLISHED_AT) {
      query.orderBy('post.publishedAt', 'DESC');
    } else {
      query.orderBy('post.createdAt', 'DESC');
    }

    // Community visibility rules for APPROVED posts
    if (status === PostStatus.APPROVED && !currentUserId) {
      // Not logged in ‚Üí hide PRIVATE communities
      query.andWhere('community.communityType != :privateType', {
        privateType: 'private',
      });
    } else if (status === PostStatus.APPROVED && currentUserId) {
      query.andWhere(
        new Brackets((qb) => {
          qb.where('community.communityType != :privateType', {
            privateType: 'private',
          }).orWhere(
            `EXISTS (
          SELECT 1
          FROM community_memberships cs
          WHERE cs.communityId = community.id
          AND cs.userId = :currentUserId
        )`,
          );
        }),
      ).setParameter('privateType', 'private')
        .setParameter('currentUserId', currentUserId);
    }

    const [data, count] = await query
      .take(limit)
      .skip((page - 1) * limit)
      .getManyAndCount();

    return { data: data, count };
  }


  async findOne(id: number, currentUserId?: number): Promise<Post | null> {
    // Start building query
    const query = this.postsRepository.createQueryBuilder('post')
      .leftJoinAndSelect('post.author', 'author')
      .leftJoinAndSelect('post.comments', 'comments')
      .leftJoinAndSelect('post.community', 'community');

    // Optionally join user's reaction if currentUserId is provided
    if (currentUserId) {
      query.leftJoinAndMapOne(
        'post.userReaction',
        'post.reactions',
        'userReaction',
        'userReaction.userId = :currentUserId',
        { currentUserId },
      );
    }

    // Filter by post ID
    query.where('post.id = :id', { id });

    const post = await query.getOne();

    if (!post) {
      return null;
    }

    // Authorization for PENDING/REJECTED posts in findOne
    if (post.status === PostStatus.PENDING || post.status === PostStatus.REJECTED) {
      if (!currentUserId) {
        throw new ForbiddenException('You must be logged in to view this post.');
      }
      const isCommunityModerator = post.communityId ? await this.isModerator(currentUserId, post.communityId) : false;
      const isAuthor = post.authorId === currentUserId;

      if (!isCommunityModerator && !isAuthor) {
        throw new ForbiddenException('You do not have permission to view this post.');
      }
    }


    // Community visibility rules for APPROVED posts
    if (post.status === PostStatus.APPROVED && !currentUserId) {
      // Not logged in and post is in a private community
      if (post.community?.communityType === CommunityType.PRIVATE) {
        return null; // Hide private community posts
      }
    } else if (post.status === PostStatus.APPROVED && currentUserId && post.community?.communityType === CommunityType.PRIVATE) {
      const isMember = await this.membershipRepository.exist({
        where: { communityId: post.communityId, userId: currentUserId },
      });
      if (!isMember) {
        throw new ForbiddenException('You are not a member of this private community.');
      }
    }


    return post;
  }

  async create(
    { title, content, authorId, communityId }: { title: string; content: string; authorId: number; communityId: number },
  ): Promise<Post> {
    const community = await this.communityRepository.findOneBy({ id: communityId });
    if (!community) {
      throw new NotFoundException(`Community with ID ${communityId} not found`);
    }
    // Check if user can contribute based on community rules
    await this.assertUserCanPostToCommunity(authorId, community);
    const membership = await this.membershipRepository.findOne({
      where: { userId: authorId, communityId },
    });

    const isModerator = membership?.role === CommunityMembershipRole.MODERATOR;
    const shouldAutoApprove =
      isModerator || community.communityType === CommunityType.PUBLIC;

    const post = this.postsRepository.create({
      title,
      content,
      authorId,
      community,
      status: shouldAutoApprove ? PostStatus.APPROVED : PostStatus.PENDING,
      publishedAt: shouldAutoApprove ? new Date() : null,
    });

    return this.postsRepository.save(post);
  }
  async update(
    postUpdateData: {
      id: number;
      title?: string;
      content?: string;
    },
  ): Promise<Post> {
    const post = await this.postsRepository.findOneBy({ id: postUpdateData.id });
    if (!post) {
      throw new NotFoundException('Post not found');
    }

    if (postUpdateData.title !== undefined) post.title = postUpdateData.title;
    if (postUpdateData.content !== undefined) post.content = postUpdateData.content;

    return this.postsRepository.save(post);
  }

  async remove(id: number): Promise<boolean> {
    const post = await this.postsRepository.findOneBy({ id });
    if (!post) {
      throw new NotFoundException('Post not found'); // TODO: Use a more specific NestJS exception
    }
    const res = await this.postsRepository.remove(post);
    return !!res;
  }


  async updatePostStatus(postId: number, newStatus: PostStatus, userId: number): Promise<Post> {
    const post = await this.postsRepository.findOne({ where: { id: postId }, relations: ['community'] });
    if (!post) {
      throw new NotFoundException('Post not found');
    }

    // Only allow owner/moderator to change status
    await this.canManagePosts(userId, post.community.id);

    post.status = newStatus;
    if (newStatus === PostStatus.APPROVED) {
      post.publishedAt = new Date();
    }
    return this.postsRepository.save(post);
  }

  async updateCommentsLockedStatus(postId: number, commentsLocked: boolean): Promise<Post> {
    const post = await this.postsRepository.findOneBy({ id: postId });
    if (!post) {
      throw new NotFoundException('Post not found');
    }
    post.commentsLocked = commentsLocked;
    return this.postsRepository.save(post);
  }

  private async isModerator(userId: number, communityId: number): Promise<boolean> {
    const community = await this.communityRepository.findOne({ where: { id: communityId } });
    if (!community) {
      return false;
    }
    if (community.ownerId === userId) {
      return true;
    }

    const membership = await this.membershipRepository.findOne({
      where: { communityId, userId },
    });

    if (membership && membership.role === CommunityMembershipRole.MODERATOR) {
      return true;
    }

    return false;
  }

  private async canManagePosts(userId: number, communityId: number) {
    const community = await this.communityRepository.findOne({ where: { id: communityId } });
    if (!community) {
      throw new NotFoundException('Community not found');
    }
    if (community.ownerId === userId) {
      return true;
    }

    const membership = await this.membershipRepository.findOne({
      where: { communityId, userId },
    });

    if (membership && membership.role === CommunityMembershipRole.MODERATOR) {
      return true;
    }

    throw new ForbiddenException('You do not have permission to manage posts in this community.');
  }

  async incrementViews(postId: number): Promise<void> {
    await this.postsRepository.increment({ id: postId }, 'views', 1);
  }

  async assertUserCanPostToCommunity(
    userId: number,
    community: Community,
  ): Promise<void> {
    switch (community.communityType) {
      case CommunityType.PUBLIC:
        return;

      case CommunityType.RESTRICTED:
      case CommunityType.PRIVATE:
        const isMember = await this.membershipRepository.exist({
          where: {
            userId,
            communityId: community.id,
          },
        });

        if (!isMember) {
          throw new ForbiddenException('You cannot post in this community');
        }
        return;

      default:
        throw new ForbiddenException('Posting not allowed');
    }
  }


}

---


### FILE: backend/src/posts/entities/post.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToMany,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
} from 'typeorm';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { Community } from '../../communities/entities/community.entity';
import { ReactionType } from 'src/reactions/reactions.types';
import { PostReport } from '../../reports/entities/post-report.entity';

export enum PostStatus {
  PENDING = 'pending',
  APPROVED = 'approved',
  REJECTED = 'rejected',
}

@Entity('posts')
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @Column()
  content: string;

  @ManyToOne(() => User, (user) => user.posts, {
    nullable: false,
    onDelete: 'CASCADE',
  })
  author: User;
  // FK explicite
  @Column()
  authorId: number;

  @ManyToOne(() => Community, (community) => community.posts, {
    nullable: false,
    onDelete: 'RESTRICT',
  })
  community: Community;

  @Column({ nullable: false })
  communityId: number;

  @Column({ default: 0 })
  commentsCount: number;

  @OneToMany(() => Comment, (comment) => comment.post)
  comments: Comment[];

  @Column({ default: 0 })
  views: number;

  @OneToMany(() => PostReaction, (reaction) => reaction.post)
  reactions: PostReaction[];

  @Column({ default: 0 })
  likesCount: number;

  @Column({ default: 0 })
  dislikesCount: number;

  @Column({ default: false })
  commentsLocked: boolean;

  @Column({
    type: 'simple-enum',
    enum: PostStatus,
    default: PostStatus.PENDING,
  })
  status: PostStatus;

  @OneToMany(() => PostReport, (postReport) => postReport.post)
  reports: PostReport[];

  userReaction?: { id: number; type: ReactionType };
  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @DeleteDateColumn()
  deletedAt: Date;

  @Column({ type: 'datetime', nullable: true })
  publishedAt: Date | null;
}

---


### FILE: backend/src/posts/posts.controller.ts ###
import {
  Controller,
  Get,
  Post as HttpPost,
  Body,
  Param,
  Patch,
  Delete,
  UseGuards,
  Query,
  Req,
  NotFoundException,
  ParseIntPipe,
} from '@nestjs/common';
import { PostsService } from './posts.service';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';
import { UpdatePostStatusDto } from './dto/update-post-status.dto';
import { UpdateCommentsLockedDto } from './dto/update-comments-locked.dto';
import { Post as PostEntity } from './entities/post.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { PostPipe } from 'src/posts/pipes/post.pipe';
import { Action } from 'src/casl/casl.types';
import { CaslService } from 'src/casl/casl.service';
import { PostResponseDto } from './dto/post-response.dto';
import { PostQueryDto } from './dto/post-query.dto';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { OptionalJwtAuthGuard } from 'src/auth/guards/optional-jwt-auth.guard';
import type { Request } from 'express';

@Controller('posts')
export class PostsController {
  constructor(
    private readonly postsService: PostsService,
    private readonly caslService: CaslService,
  ) { }

  @Get()
  @UseGuards(JwtAuthGuard)
  async findAll(@Query() query: PostQueryDto,
    @Req() req: any
  ): Promise<PaginatedResponseDto<PostResponseDto>> {

    const { data, count } = await this.postsService.findAll({
      page: query.page,
      limit: query.limit,
      search: query.search,
      authorId: query.authorId,
      sort: query.sort,
      startDate: query.startDate,
      endDate: query.endDate,
      currentUserId: req.user?.id ?? undefined,
      communityId: query.communityId,
      status: query.status,
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(PostResponseDto.fromEntity), paginationMeta);
  }


  @HttpPost()
  @UseGuards(JwtAuthGuard)
  async create(
    @Body() dto: CreatePostDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<PostResponseDto>> {
    this.caslService.enforce(user, Action.Create, PostEntity);
    const post = await this.postsService.create({
      title: dto.title,
      content: dto.content,
      authorId: user.id,
      communityId: dto.communityId,
    });
    return new ResponseDto(PostResponseDto.fromEntity(post));
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', PostPipe) post: PostEntity,
    @Body() dto: UpdatePostDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<PostResponseDto>> {
    this.caslService.enforce(user, Action.Update, post);
    const updatedPost = await this.postsService.update({
      id: post.id,
      title: dto.title,
      content: dto.content,
    });
    return new ResponseDto(PostResponseDto.fromEntity(updatedPost));
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  async remove(@Param('id', PostPipe) post: PostEntity, @GetUser() user: User): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, post);
    const success = await this.postsService.remove(post.id);
    return new ResponseDto(success);
  }

  @Patch(':id/status')
  @UseGuards(JwtAuthGuard)
  async updatePostStatus(
@Param('id', ParseIntPipe) id: number, // Use ParseIntPipe instead of PostPipe   
 @Body() dto: UpdatePostStatusDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<PostResponseDto>> {
    const updatedPost = await this.postsService.updatePostStatus(id, dto.status,user.id);
    return new ResponseDto(PostResponseDto.fromEntity(updatedPost));
  }

  @Patch(':id/comments-locked')
  @UseGuards(JwtAuthGuard)
  // TODO: Add proper authorization using caslService.enforce
  async updateCommentsLockedStatus(
    @Param('id', PostPipe) post: PostEntity,
    @Body() dto: UpdateCommentsLockedDto,
    @GetUser() user: User, // For authorization check
  ): Promise<ResponseDto<PostResponseDto>> {
    this.caslService.enforce(user, Action.Update, post); // Enforce update on commentsLocked field
    const updatedPost = await this.postsService.updateCommentsLockedStatus(post.id, dto.commentsLocked);
    return new ResponseDto(PostResponseDto.fromEntity(updatedPost));
  }

  @Get(':id')
  @UseGuards(OptionalJwtAuthGuard)
  async findOne(
    @Param('id') id: string,
    @GetUser() user?: User, // Get user if authenticated
  ): Promise<ResponseDto<PostResponseDto>> {
    const postId = +id;
    const post = await this.postsService.findOne(postId, user?.id); // Pass currentUserId

    if (!post) {
      throw new NotFoundException(`Post not found`);
    }

    this.postsService.incrementViews(postId);
    return new ResponseDto(PostResponseDto.fromEntity(post));
  }

  }

---


### FILE: backend/src/posts/dto/update-post.dto.ts ###
// src/posts/dto/update-post.dto.ts

import { PartialType } from '@nestjs/mapped-types'; // <-- 1. Make sure this is imported
import { CreatePostDto } from './create-post.dto'; // <-- 2. Make sure you import CreatePostDto

// 3. Extend PartialType of your base DTO
export class UpdatePostDto extends PartialType(CreatePostDto) {
  // If you need to add custom validation or properties, they go here.
  // Otherwise, leave the body empty.
}

---


### FILE: backend/src/posts/dto/update-post-status.dto.ts ###
import { IsEnum } from 'class-validator';
import { PostStatus } from '../entities/post.entity';

export class UpdatePostStatusDto {
  @IsEnum(PostStatus)
  status: PostStatus;
}

---


### FILE: backend/src/posts/dto/update-comments-locked.dto.ts ###
import { IsBoolean } from 'class-validator';

export class UpdateCommentsLockedDto {
  @IsBoolean()
  commentsLocked: boolean;
}

---


### FILE: backend/src/posts/dto/post-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsString, IsInt, IsEnum, IsISO8601 } from 'class-validator';
import { Type } from 'class-transformer';
import { PostStatus } from '../entities/post.entity';

export enum PostSort {
  NEWEST = 'newest',
  POPULAR = 'popular',
  OLDEST = 'oldest',
  PUBLISHED_AT = 'published_at',
}

export { PostStatus };

export class PostQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  search?: string; // Filter by title or content

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  authorId?: number;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  communityId?: number;

  @IsOptional()
  @IsEnum(PostSort)
  sort?: PostSort;

  @IsOptional()
  @IsISO8601()
  @Type(() => Date)
  startDate?: Date;

  @IsOptional()
  @IsISO8601()
  @Type(() => Date)
  endDate?: Date;

  @IsOptional()
  @IsEnum(PostStatus)
  status?: PostStatus;
}

---


### FILE: backend/src/posts/dto/post-response.dto.ts ###
// src/posts/dto/post-response.dto.ts
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { Post } from '../entities/post.entity';
import { ReactionResponseDto } from 'src/reactions/dto/reaction-response.dto';
import { CommunityResponseDto } from 'src/communities/dto/community-response.dto';

@Exclude()
export class PostResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly title: string;
  @Expose() readonly content: string;
  @Expose() readonly views: number;
  @Expose() readonly createdAt: Date;
  @Expose() readonly updatedAt: Date;
  @Expose() readonly publishedAt: Date;


  @Expose() @Type(() => UserResponseDto) readonly author: UserResponseDto;
  
  @Expose() @Type(() => CommunityResponseDto) readonly community?: CommunityResponseDto;

  @Expose() readonly commentsCount: number;
  @Expose() readonly likesCount: number;
  @Expose() readonly dislikesCount: number;
  
  @Expose() @Type(() => ReactionResponseDto) 
  readonly userReaction?: ReactionResponseDto | null;

  static fromEntity(entity: Post & { userReaction?: any }): PostResponseDto {
    return plainToInstance(
      PostResponseDto,
      {
        ...entity,
        author: entity.author ? UserResponseDto.fromEntity(entity.author) : null,
        community: entity.community ? CommunityResponseDto.fromEntity(entity.community) : null,
        commentsCount: entity.commentsCount,
        userReaction: entity.userReaction ? ReactionResponseDto.fromEntity(entity.userReaction) : null,
      },
      { excludeExtraneousValues: true },
    );
  }
}
---


### FILE: backend/src/posts/dto/create-post.dto.ts ###
import { IsString, IsNotEmpty, IsInt } from 'class-validator';
import { Type } from 'class-transformer';

export class CreatePostDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  @IsNotEmpty()
  content: string;

  @IsInt()
  @IsNotEmpty()
  @Type(() => Number)
  communityId: number;
}

---


### FILE: backend/src/auth/auth.service.ts ###
// src/auth/auth.service.ts
import {
  BadRequestException,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService } from '../users/users.service';
import * as bcrypt from 'bcrypt';
import { User } from 'src/users/entities/user.entity';

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UsersService,
    private readonly jwt: JwtService,
    private readonly config: ConfigService,
  ) {}

  // -------------------------------------------------------------------------
  // Register (local account)
  // -------------------------------------------------------------------------
  async register(username: string, email: string, password: string): Promise<User> {
    return this.userService.createUser(
     { username,
      email,
      password, }
    );
  }

  // -------------------------------------------------------------------------
  // Validate credentials (used by LocalStrategy)
  // -------------------------------------------------------------------------
 // In auth.service.ts, update the validateUser method:
async validateUser(email: string, password: string): Promise<User> {
  const user = await this.userService.findByEmail(email);
  
  // If user doesn't exist or has no password (social-only account)
  if (!user || !user.password) {
    throw new UnauthorizedException('Invalid credentials');
  }
  
  const isMatch = await bcrypt.compare(password, user.password);
  
  if (!isMatch) {
    throw new UnauthorizedException('Invalid credentials');
  }
  
  return user;
}

  // -------------------------------------------------------------------------
  // Sign in (called after successful local or refresh validation)
  // -------------------------------------------------------------------------
  async signIn(user: User) {
    return this.generateTokens(user);
  }

  // -------------------------------------------------------------------------
  // Google OAuth login / link
  // -------------------------------------------------------------------------
  async googleLogin(oauthUser: {
    email: string;
    fullName?: string;
    id: string;
    picture?: string;
  }): Promise<User> {
    if (!oauthUser?.email) {
      throw new BadRequestException('Google account has no accessible email');
    }

    let user: User | null = null;

    try {
      user = await this.userService.findByEmail(oauthUser.email);
    } catch {
      user = null; // not found
    }

    if (!user) {
      // First time ‚Üí create new user
     return this.userService.createUser({
  username: oauthUser.fullName ?? oauthUser.email.split('@')[0],
  email: oauthUser.email,
  password: undefined, // no password
  provider: 'google',
  providerId: oauthUser.id,
  emailVerifiedAt: new Date(), // email already verified by Google
});

    }

    // Existing user ‚Üí make sure provider data is up-to-date
    return this.userService.updateUser({user ,
      username: oauthUser.fullName ?? user.username,
      provider: 'google',
      providerId: oauthUser.id,
      emailVerifiedAt: user.emailVerifiedAt ?? new Date(),
    });
  }

  // -------------------------------------------------------------------------
  // Refresh token flow
  // -------------------------------------------------------------------------
  async renewTokens(user: User): Promise<string> {
    const payload = { sub: user.id, email: user.email };
    return this.jwt.sign(payload, {
      secret: this.config.get<string>('JWT_ACCESS_SECRET'),
      expiresIn: this.config.getOrThrow('JWT_ACCESS_EXPIRES_IN'),
    });
  }

  // -------------------------------------------------------------------------
  // Token generation (shared)
  // -------------------------------------------------------------------------
  private generateTokens(user: User) {
    const payload = { sub: user.id, email: user.email };

    const accessToken = this.jwt.sign(payload, {
      secret: this.config.get<string>('JWT_ACCESS_SECRET'),
      expiresIn: this.config.getOrThrow('JWT_ACCESS_EXPIRES_IN'),
    });

    const refreshToken = this.jwt.sign(payload, {
      secret: this.config.get<string>('JWT_REFRESH_SECRET'),
      expiresIn: this.config.getOrThrow('JWT_REFRESH_EXPIRES_IN'),
    });

    return { accessToken, refreshToken };
  }
}
---


### FILE: backend/src/auth/utils/time.util.ts ###
// src/auth/util/time.util.ts

/**
 * Parses a JWT expiresIn string (e.g., "30d", "1h") into milliseconds.
 * @param expiresIn The string to parse.
 * @returns The equivalent duration in milliseconds.
 */
export function parseExpiresInToMs(expiresIn: string): number {
  const value = parseInt(expiresIn.slice(0, -1));
  const unit = expiresIn.slice(-1);

  if (isNaN(value)) {
    return parseInt(expiresIn); // Assume it's already in ms if parsing fails
  }

  switch (unit) {
    case 's': return value * 1000;
    case 'm': return value * 60 * 1000;
    case 'h': return value * 60 * 60 * 1000;
    case 'd': return value * 24 * 60 * 60 * 1000;
    default: return parseInt(expiresIn); // Fallback for plain numbers
  }
}

---


### FILE: backend/src/auth/dtos/register.dto.ts ###
import { IsEmail, IsString, MinLength } from 'class-validator';

export class RegisterDto {
  
  @IsEmail()
  email: string;

  @IsString()
   name: string;

  @IsString()
  @MinLength(6)
  password: string;
}

---


### FILE: backend/src/auth/dtos/login.dto.ts ###
import { IsEmail, IsString, MinLength } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(6)
  password: string;
}

---


### FILE: backend/src/auth/dtos/refresh.dto.ts ###
import { IsString, IsNotEmpty } from 'class-validator';

export class RefreshDto {
  @IsString()
  @IsNotEmpty()
  refreshToken: string;
}

---


### FILE: backend/src/auth/auth.controller.ts ###
import {
  Controller,
  Post,
  Body,
  UseGuards,
  Get,
  Req,
  Res,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto } from './dtos/register.dto';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { JwtRefreshGuard } from './guards/jwt-refresh.guard';
import { EmailVerificationService } from 'src/email-verification/email-verification.service';
import { AuthGuard } from '@nestjs/passport';
import { UserResponseDto } from 'src/users/dtos/user-response.dto';
import { User } from 'src/users/entities/user.entity';
import { ResponseDto } from 'src/common/dto/response.dto';
import type { Response } from 'express';
import { parseExpiresInToMs } from './utils/time.util';
import { ConfigService } from '@nestjs/config';
import { JwtAuthGuard } from './guards/jwt-auth.guard'; // Import JwtAuthGuard

@Controller('auth')
export class AuthController {
  constructor(
    private readonly authService: AuthService,
    private readonly emailVerificationService: EmailVerificationService,
    private readonly configService: ConfigService,
  ) {}

  @Post('register')
  async register(@Body() dto: RegisterDto): Promise<ResponseDto<UserResponseDto>> {
    const user = await this.authService.register(
      dto.name,
      dto.email,
      dto.password,
    );
    await this.emailVerificationService.sendVerificationEmail(user);
    return new ResponseDto(UserResponseDto.fromEntity(user), 'Registration successful. Please verify your email.');
  }

  @UseGuards(LocalAuthGuard)
  @Post('login')
  async login(
    @Req() req: { user: User },
    @Res({ passthrough: true }) res: Response,
  ): Promise<ResponseDto<{ user: UserResponseDto; accessToken: string }>> {
    if (!req.user.emailVerifiedAt) {
      await this.emailVerificationService.sendVerificationEmail(req.user);

      throw new UnauthorizedException(
        'Email not verified. Verification email sent.',
      );
    }
    const { accessToken, refreshToken } = await this.authService.signIn(req.user);

    const refreshTokenExpiresIn = this.configService.getOrThrow<string>('JWT_REFRESH_EXPIRES_IN');
    const maxAgeMs = parseExpiresInToMs(refreshTokenExpiresIn);

    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV !== 'development', // Use secure cookies in production
      sameSite: 'strict',
      maxAge: maxAgeMs, // Use dynamic maxAge
    });

    return new ResponseDto({
      user: UserResponseDto.fromEntity(req.user),
      accessToken,
    });
  }

  @Post('logout')
  async logout(@Res({ passthrough: true }) res: Response): Promise<ResponseDto<null>> {
    res.clearCookie('refreshToken');
    return new ResponseDto(null, 'Logged out successfully.');
  }

  @UseGuards(JwtRefreshGuard)
  @Get('refresh')
  async refresh(@Req() req: { user: User }): Promise<ResponseDto<{ user: UserResponseDto; accessToken: string }>> {
    const accessToken = await this.authService.renewTokens(req.user);
    return new ResponseDto({
      user: UserResponseDto.fromEntity(req.user),
      accessToken,
    });
  }

  @Get('me') // Add this endpoint
  @UseGuards(JwtAuthGuard)
  async getMe(@Req() req: { user: User }): Promise<ResponseDto<UserResponseDto>> {
    return new ResponseDto(UserResponseDto.fromEntity(req.user));
  }

  @Get('google')
  @UseGuards(AuthGuard('google'))
  async googleAuth() {
    // Passport automatically redirects to Google
  }

  @Get('google/callback')
  @UseGuards(AuthGuard('google'))
  async googleCallback(
    @Req() req: { user: any },
    @Res({ passthrough: true }) res: Response,
  ): Promise<ResponseDto<{ user: UserResponseDto; accessToken: string }>> {
    const user = await this.authService.googleLogin(req.user);
    const { accessToken, refreshToken } = await this.authService.signIn(user);

    const refreshTokenExpiresIn = this.configService.getOrThrow<string>('JWT_REFRESH_EXPIRES_IN');
    const maxAgeMs = parseExpiresInToMs(refreshTokenExpiresIn);

    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV !== 'development',
      sameSite: 'strict',
      maxAge: maxAgeMs, // Use dynamic maxAge
    });

    return new ResponseDto({
      user: UserResponseDto.fromEntity(user),
      accessToken,
    });
  }
}
---


### FILE: backend/src/auth/auth.module.ts ###
import { Module } from '@nestjs/common';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';

import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';

import { UsersModule } from '../users/users.module';
import { JwtStrategy } from './strategies/jwt.strategy';
import { JwtRefreshStrategy } from './strategies/jwt-refresh.strategy';
import { LocalStrategy } from './strategies/local.strategy';
import { EmailVerificationModule } from 'src/email-verification/email-verification.module';
import { GoogleStrategy } from './strategies/google.strategy';
import { ConfigService } from '@nestjs/config';

@Module({
  imports: [
    UsersModule,
    PassportModule,
 JwtModule.registerAsync({
  inject: [ConfigService],
  useFactory: (config: ConfigService) => {
    const secret = config.getOrThrow<string>('JWT_ACCESS_SECRET');
    const expiresIn = config.getOrThrow('JWT_ACCESS_EXPIRES_IN');

    return {
      secret,
      signOptions: { expiresIn },
    };
  },
})
 ,
    EmailVerificationModule,
  ],
  controllers: [AuthController],
  providers: [
    AuthService,
    LocalStrategy,
    JwtStrategy,
    JwtRefreshStrategy,
    GoogleStrategy,
  ],
  exports: [AuthService],
})
export class AuthModule {}

---


### FILE: backend/src/auth/guards/optional-jwt-auth.guard.ts ###
import { Injectable, ExecutionContext } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class OptionalJwtAuthGuard extends AuthGuard('jwt') {
  // Only run passport when there's an Authorization header (or cookie extractor)
  canActivate(context: ExecutionContext) {
    const req = context.switchToHttp().getRequest();
    const authHeader = req.headers?.authorization;

    // If no auth header, allow anonymously
    if (!authHeader) {
      return true;
    }

    // If header exists, run the normal jwt guard which will call validate()
    return super.canActivate(context) as boolean | Promise<boolean>;
  }

  // handleRequest receives (err, user, info)
  handleRequest(err: any, user: any, info: any) {
    // log details to debug why authentication failed
    if (info) {
      console.log('OptionalJwtAuthGuard - passport info:', info);
    }
    if (err) {
      // real error (e.g. DB lookup failed) ‚Äî rethrow
      throw err;
    }

    // If passport failed to authenticate it may pass `false` or `undefined` here.
    // We want to silence that and allow anonymous access, so return null in that case.
    if (!user) {
      return null;
    }

    // Auth succeeded
    return user;
  }
}

---


### FILE: backend/src/auth/guards/jwt-refresh.guard.ts ###
import { AuthGuard } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtRefreshGuard extends AuthGuard('jwt-refresh') {}

---


### FILE: backend/src/auth/guards/jwt-auth.guard.ts ###
import { AuthGuard } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

---


### FILE: backend/src/auth/guards/local-auth.guard.ts ###
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

---


### FILE: backend/src/auth/strategies/local.strategy.ts ###
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { AuthService } from '../auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy, 'local') {
  constructor(private readonly authService: AuthService) {
    super({ usernameField: 'email' });
  }

  async validate(email: string, password: string) {
  try {
      const user = await this.authService.validateUser(email, password);
   
      return user;
    } catch (exception) {
      // Optional: log the original error for debugging
      console.error('Auth validation error:', exception);

      // Throw generic message to client
      throw new UnauthorizedException('Invalid credentials');
    }
  
  }
}

---


### FILE: backend/src/auth/strategies/google.strategy.ts ###
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, VerifyCallback } from 'passport-google-oauth20';
import { AuthService } from '../auth.service';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  constructor(
    private readonly authService: AuthService,
    private readonly config: ConfigService,
  ) {
    super({
      clientID: config.get<string>('GOOGLE_CLIENT_ID'),
      clientSecret: config.get<string>('GOOGLE_CLIENT_SECRET'),
      callbackURL: config.get<string>('GOOGLE_CALLBACK_URL'),
      scope: ['email', 'profile'],
      passReqToCallback: false,
    });
  }

  // profile comes from Google; map to our OAuthUser shape
  async validate(
    accessToken: string,
    refreshToken: string,
    profile: any,
    done: VerifyCallback,
  ): Promise<any> {
    try {
      const emailObj = (profile.emails && profile.emails[0]) || {
        value: undefined,
      };
      const oauthUser = {
        provider: 'google',
        providerId: profile.id,
        email: emailObj.value,
        name: profile.displayName,
      };

      // return the object that will be available as req.user
      return done(null, oauthUser);
    } catch (err) {
      return done(err as Error, false);
    }
  }
}

---


### FILE: backend/src/auth/strategies/jwt.strategy.ts ###
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService } from 'src/users/users.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy, 'jwt') {
  constructor(
    config: ConfigService,
    private readonly userService: UsersService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: config.getOrThrow<string>('JWT_ACCESS_SECRET'),
    });
  }

  // Hypothetical improvement
  async validate(payload: { sub: number; email: string }) {
    // 1. Check database for active user
    const user = await this.userService.findOneById(payload.sub);

    // 2. Reject if user doesn't exist (e.g., account was deleted)
    if (!user) {
      throw new UnauthorizedException();
    }

    // 3. Attach user object to req.user
    return user;
  }
}

---


### FILE: backend/src/auth/strategies/jwt-refresh.strategy.ts ###
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { UsersService } from 'src/users/users.service';

import { Request } from 'express';

// ... (other imports)

@Injectable()
export class JwtRefreshStrategy extends PassportStrategy(
  Strategy,
  'jwt-refresh',
) {
  constructor(
    config: ConfigService,
    private readonly userService: UsersService,
  ) {
    super({
      jwtFromRequest: (req: Request) => {
        if (req && req.cookies) {
          return req.cookies.refreshToken;
        }
        return null;
      },
      secretOrKey: config.getOrThrow<string>('JWT_REFRESH_SECRET'),
    });
  }

  async validate(payload: { sub: number; email: string }) {
    // 1. Check database for active user
    const user = await this.userService.findOneById(payload.sub);

    // 2. Reject if user doesn't exist (e.g., account was deleted)
    if (!user) {
      throw new UnauthorizedException();
    }

    // 3. Attach user object to req.user
    return user;
  }
}

---


### FILE: backend/src/reset-password/password-reset.controller.ts ###
import { Controller, Post, Body, Inject } from '@nestjs/common';
import { PasswordResetService } from './password-reset.service';
import { ForgotDto } from './dto/forgot.dto';
import { ResetDto } from './dto/reset.dto';
import { UsersService } from '../users/users.service';
import type { IMailService } from 'src/mail/interfaces/mail-service.interface';
import { ConfigService } from '@nestjs/config';

@Controller('reset-password')
export class PasswordResetController {
  constructor(
    private resetService: PasswordResetService,
    private usersService: UsersService,
    @Inject('IMailService') private mailService: IMailService,
    private config: ConfigService,
  ) {}

  @Post('forgot')
  async forgot(@Body() dto: ForgotDto) {
    try {
      const user = await this.usersService.findByEmail(dto.email);
      if (!user) return { message: 'Email sent if account exists' };

      const { token } = await this.resetService.generateToken(user.id);

      const resetLink = this.resetService.generateResetLink(token);
      await this.mailService.sendEmail(
        user.email,
        'Reset Your Password',
        'reset-password',
        { username: user.username, resetLink },
      );

      return { message: 'Email sent if account exists' };
    } catch (err) {
      console.log(err);

      return { message: 'Email sent if account exists' };
    }
  }

  @Post('reset')
  async reset(@Body() dto: ResetDto) {
    const userId = await this.resetService.validateToken(dto.token);
    const user = await this.usersService.findOneById(userId);

    await this.usersService.updateUser( 
      { user,
         password: dto.password });
    return { message: 'Password updated' };
  }
}

---


### FILE: backend/src/reset-password/reset-password.module.ts ###
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PasswordResetToken } from './entities/password-reset-token.entity';
import { PasswordResetService } from './password-reset.service';
import { PasswordResetController } from './password-reset.controller';
import { UsersModule } from '../users/users.module';
import { MailModule } from 'src/mail/mail.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([PasswordResetToken]),
    MailModule,
    UsersModule,
  ],
  controllers: [PasswordResetController],
  providers: [PasswordResetService],
  exports: [PasswordResetService],
})
export class ResetPasswordModule {}

---


### FILE: backend/src/reset-password/password-reset.service.ts ###
import { Injectable, BadRequestException } from '@nestjs/common';
import { PasswordResetToken } from './entities/password-reset-token.entity';
import { Repository, MoreThan } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { randomBytes } from 'crypto';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class PasswordResetService {
  private  TOKEN_EXPIRATION_MINUTES : number;

  constructor(
    @InjectRepository(PasswordResetToken)
    private repo: Repository<PasswordResetToken>,
    private config: ConfigService,
  ) {
    this.TOKEN_EXPIRATION_MINUTES=config.get<number>("TOKEN_EXPIRATION_MINUTES") ?? 15
  }

  /** Public API **/

  async generateToken(userId: number) {
    const token = this.generateTokenValue();
    const expiresAt = this.calculateExpiration();

    await this.saveToken(userId, token, expiresAt);

    return { token, expiresAt };
  }

  async validateToken(token: string) {
    const tokenRow = await this.findValidToken(token);

    if (!tokenRow) throw new BadRequestException('Invalid or expired token');

    await this.deleteToken(tokenRow.id);

    return tokenRow.userId;
  }

  public generateResetLink(token: string): string {
    const frontendUrl = this.config.get<string>(
      'APP_DOMAIN',
      'http://localhost:3000',
    );
    const resetPath = '/reset-password';
    return `${frontendUrl}${resetPath}?token=${token}`;
  }
  /** Private helpers **/

  private generateTokenValue(): string {
    return randomBytes(32).toString('hex');
  }

  private calculateExpiration(): Date {
    const now = new Date();
    return new Date(now.getTime() + this.TOKEN_EXPIRATION_MINUTES * 60_000);
  }

  private async saveToken(userId: number, token: string, expiresAt: Date) {
    const entity = this.repo.create({ userId, token, expiresAt });
    await this.repo.save(entity);
  }

  private async findValidToken(
    token: string,
  ): Promise<PasswordResetToken | null> {
    return this.repo.findOne({
      where: { token, expiresAt: MoreThan(new Date()) },
    });
  }

  private async deleteToken(id: number) {
    await this.repo.delete(id);
  }
}

---


### FILE: backend/src/reset-password/entities/password-reset-token.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  Index,
} from 'typeorm';

@Entity({ name: 'password_reset_tokens' })
export class PasswordResetToken {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  @Index()
  userId: number;

  @Column()
  @Index()
  token: string;

  @Column()
  expiresAt: Date;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: backend/src/reset-password/dto/reset.dto.ts ###
import { IsString, MinLength } from 'class-validator';

export class ResetDto {
  @IsString()
  token: string;

  @IsString()
  @MinLength(8)
  password: string;
}

---


### FILE: backend/src/reset-password/dto/forgot.dto.ts ###
import { IsEmail } from 'class-validator';

export class ForgotDto {
  @IsEmail()
  email: string;
}

---


### FILE: backend/src/communities/types.ts ###
export enum CommunityType {
  PUBLIC = 'public',
  RESTRICTED = 'restricted',
  PRIVATE = 'private',
}

---


### FILE: backend/src/communities/communities.service.ts ###
import {
  ConflictException,
  ForbiddenException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Not, Repository } from 'typeorm';
import { Community } from './entities/community.entity';
import { CommunityType } from './types';
import { User } from '../users/entities/user.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';
import { CommunityMembershipRole } from 'src/community-memberships/types';
import { CommunityMembershipRequest } from 'src/community-membership-requests/entities/community-membership-request.entity';
import { CommunityMembershipRequestStatus } from 'src/community-membership-requests/entities/community-membership-request.entity';
import { DataSource } from 'typeorm';

@Injectable()
export class CommunitiesService {
  constructor(    
    private dataSource: DataSource,
    @InjectRepository(Community)
    private readonly communitiesRepository: Repository<Community>,
    @InjectRepository(Community)
    private readonly communityRepository: Repository<Community>,
    @InjectRepository(CommunityMembership)
    private readonly membershipRepository: Repository<CommunityMembership>,
    @InjectRepository(CommunityMembershipRequest)
    private readonly membershipRequestRepository: Repository<CommunityMembershipRequest>,
  ) { }

  findAll(query: {
    limit?: number;
    page?: number;
    name?: string;
    displayName?: string;
    communityType?: CommunityType;
    sort?: string;
  }) {
    const { limit = 10, page = 1, name, displayName, communityType, sort } = query;
    const queryBuilder = this.communitiesRepository
      .createQueryBuilder('community')
      .leftJoinAndSelect('community.owner', 'owner')
      .take(limit)
      .skip((page - 1) * limit);

    if (name) queryBuilder.andWhere('community.name LIKE :name', { name: `%${name}%` });
    if (displayName) queryBuilder.andWhere('community.displayName LIKE :displayName', { displayName: `%${displayName}%` });
    if (communityType !== undefined) queryBuilder.andWhere('community.communityType = :communityType', { communityType });
    if (sort === 'popular') queryBuilder.orderBy('community.membersCount', 'DESC');

    return queryBuilder.getManyAndCount();
  }


  async create(data: {
    userId: number;
    name: string;
    displayName?: string;
    description?: string;
    communityType?: CommunityType;
  }) {
    return this.dataSource.transaction(async (manager) => {
      const existingCommunity = await manager.findOne(Community, {
        where: { name: data.name },
      });
      if (existingCommunity) {
        throw new ConflictException('Community with this name already exists.');
      }

      if (!data.displayName) data.displayName = data.name;

      const community = manager.create(Community, {
        ...data,
        owner: { id: data.userId },
      });
      const savedCommunity = await manager.save(community);

      const membership = manager.create(CommunityMembership, {
        userId: data.userId,
        communityId: savedCommunity.id,
        role: CommunityMembershipRole.MODERATOR,
        rank: 0,
      });
      await manager.save(membership);
    await manager.increment(
      Community,
      { id: savedCommunity.id },
      'membersCount',
      1,
    );
      return savedCommunity;
    });
  }

  async findOne(id: number, user?: User): Promise<Community> {
    const community = await this.communitiesRepository.findOne({
      where: { id },
      relations: ['owner'],
    });

    if (!community) throw new NotFoundException(`Community with ID ${id} not found.`);

    await this.assertUserCanViewCommunity(user?.id, community);

    if (user) {
      const isMember = await this.membershipRepository.exist({
        where: {
          userId: user.id,
          communityId: community.id,
        },
      });
      

      if (isMember) {
        community.userMembershipStatus = 'member';
      } else {
        const pendingRequest = await this.membershipRequestRepository.findOne({
          where: {
            userId: user.id,
            communityId: community.id,
            status: CommunityMembershipRequestStatus.PENDING,
          },
        });

        if (pendingRequest) {
          community.userMembershipStatus = 'pending';
        } else {
          community.userMembershipStatus = 'none';
        }
      }
    } else {
      community.userMembershipStatus = 'none';
    }

    return community;
  }


  async update(data: {
    id: number;
    name?: string;
    displayName?: string;
    description?: string;
    communityType?: CommunityType;
    membersCount?: number;
  }) {
    const { id, name } = data;

    if (name) {
      const existing = await this.communitiesRepository.findOne({
        where: { name, id: Not(id) },
      });
      if (existing) throw new ConflictException('Community name already exists.');
    }

    const community = await this.communitiesRepository.preload(data);
    if (!community) throw new NotFoundException(`Community with ID ${id} not found.`);

    return this.communitiesRepository.save(community);
  }

  async remove(id: number) {
    const community = await this.findOne(id);
    await this.communitiesRepository.remove(community);
  }


  async assertUserCanViewCommunity(
    userId: number | undefined,
    community: Community,
  ): Promise<void> {
    switch (community.communityType) {
      case CommunityType.PUBLIC:
      case CommunityType.RESTRICTED:
        return;

      case CommunityType.PRIVATE:
        if (!userId) {
          throw new ForbiddenException('Login required to view this community');
        }

        const isMember = await this.membershipRepository.exist({
          where: {
            userId,
            communityId: community.id,
          },
        });

        if (!isMember) {
          throw new ForbiddenException('You are not a member of this community');
        }
        return;

      default:
        throw new ForbiddenException('Community is not accessible');
    }
  }

}

---


### FILE: backend/src/communities/entities/community.entity.ts ###
import {
  Column,
  CreateDateColumn,
  Entity,
  ManyToOne,
  OneToMany,
  PrimaryGeneratedColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';
import { CommunityMembership } from '../../community-memberships/entities/community-memberships.entity';
import { CommunityMembershipRequest } from '../../community-membership-requests/entities/community-membership-request.entity';
import { CommunityRestriction } from '../../community-restrictions/entities/community-restriction.entity';
import { CommunityType } from '../types';

@Entity('communities')
export class Community {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 50, unique: true })
  name: string;

  @Column({ type: 'varchar', length: 100, nullable: true })
  displayName: string;

  @Column({ type: 'text', nullable: true })
  description: string;

  @ManyToOne(() => User, (user) => user.createdCommunities)
  owner: User;

  @Column({ nullable: true })
  ownerId: number;

  @CreateDateColumn()
  createdAt: Date;

  @Column({ type: 'simple-enum', enum : CommunityType, default: CommunityType.PUBLIC })
  communityType: CommunityType;

  @Column({ type: 'integer', default: 0 })
  membersCount: number;

  userMembershipStatus?: 'member' | 'pending' | 'none';

  @OneToMany(() => Post, (post) => post.community)
  posts: Post[];

  @OneToMany(
    () => CommunityMembership,
    (membership) => membership.community,
  )
  memberships: CommunityMembership[];

  @OneToMany(
    () => CommunityMembershipRequest,
    (request) => request.community,
  )
  membershipRequests: CommunityMembershipRequest[];

  @OneToMany(
    () => CommunityRestriction,
    (restriction) => restriction.community,
  )
  restrictions: CommunityRestriction[];
}

---


### FILE: backend/src/communities/communities.controller.ts ###
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  ParseIntPipe,
  UseGuards,
} from '@nestjs/common';
import { CommunitiesService } from './communities.service';
import { CreateCommunityDto } from './dto/create-community.dto';
import { UpdateCommunityDto } from './dto/update-community.dto';
import { CommunityQueryDto } from './dto/community-query.dto';
import { CommunityResponseDto } from './dto/community-response.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { User } from '../users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { OptionalJwtAuthGuard } from 'src/auth/guards/optional-jwt-auth.guard';

@Controller('communities')
export class CommunitiesController {
  constructor(private readonly communitiesService: CommunitiesService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  async create(
    @Body() createCommunityDto: CreateCommunityDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommunityResponseDto>> {
    const community = await this.communitiesService.create({
       userId :user.id ,
      name: createCommunityDto.name,
      displayName: createCommunityDto.displayName,
      description: createCommunityDto.description,
      communityType: createCommunityDto.communityType,
    });
    return new ResponseDto(CommunityResponseDto.fromEntity(community));
  }

  @Get()
  async findAll(@Query() query: CommunityQueryDto): Promise<PaginatedResponseDto<CommunityResponseDto>> {
    const [communities, count] = await this.communitiesService.findAll({
      limit: query.limit,
      page: query.page,
      name: query.name,
      displayName: query.displayName,
      communityType: query.communityType,
      sort: query.sort,
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      communities.length,
    );

    return new PaginatedResponseDto(communities.map(c => CommunityResponseDto.fromEntity(c)), paginationMeta);
  }

  @Get(':id')
  @UseGuards(OptionalJwtAuthGuard)
  async findOne(@Param('id', ParseIntPipe) id: number ,
  @GetUser() user :User)
  : Promise<ResponseDto<CommunityResponseDto>> {
    const community = await this.communitiesService.findOne(id,user);
   console.log(community);
   
    return new ResponseDto(CommunityResponseDto.fromEntity(community));
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateCommunityDto: UpdateCommunityDto,
  ): Promise<ResponseDto<CommunityResponseDto>> {
    const community = await this.communitiesService.update(  {
      id,
      name: updateCommunityDto.name,
      displayName: updateCommunityDto.displayName,
      description: updateCommunityDto.description,
      communityType: updateCommunityDto.communityType,
    });
    return new ResponseDto(CommunityResponseDto.fromEntity(community));
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  async remove(@Param('id', ParseIntPipe) id: number): Promise<ResponseDto<void>> {
    const success = await this.communitiesService.remove(id);
    return new ResponseDto(success);
  }
}

---


### FILE: backend/src/communities/communities.module.ts ###
import { Module } from '@nestjs/common';
import { CommunitiesService } from './communities.service';
import { CommunitiesController } from './communities.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Community } from './entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';

import { CommunityMembershipRequest } from 'src/community-membership-requests/entities/community-membership-request.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Community, CommunityMembership, CommunityMembershipRequest])],
  controllers: [CommunitiesController],
  providers: [CommunitiesService],
  exports: [CommunitiesService],
})
export class CommunitiesModule {}

---


### FILE: backend/src/communities/dto/create-community.dto.ts ###
import {
  IsEnum,
  IsOptional,
  IsString,
  Length,
  Matches,
} from 'class-validator';
import { CommunityType } from '../types';

export class CreateCommunityDto {
  @IsString()
  @Length(3, 50)
  @Matches(/^[a-z0-9\-]+$/, {
    message: 'Name can only contain lowercase letters, numbers, and hyphens.',
  })
  name: string;

  @IsOptional()
  @IsString()
  @Length(3, 100)
  displayName?: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsEnum(CommunityType)
  communityType?: CommunityType;
}

---


### FILE: backend/src/communities/dto/community-response.dto.ts ###
import { Exclude, Expose, plainToInstance } from 'class-transformer';
import { Community } from '../entities/community.entity';
import { CommunityType } from '../types'; // Import CommunityType

@Exclude()
export class CommunityResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly name: string;
  @Expose() readonly displayName: string;
  @Expose() readonly description: string;
  @Expose() readonly communityType: CommunityType;

  @Expose() readonly membersCount: number;
  @Expose() readonly createdAt: Date;
  @Expose() userMembershipStatus?: 'member' | 'pending' | 'none';

  static fromEntity(entity: Community): CommunityResponseDto {
    const dto = plainToInstance(CommunityResponseDto, entity, {
      excludeExtraneousValues: true,
    });
    dto.userMembershipStatus = entity.userMembershipStatus;
    return dto;
  }
}
---


### FILE: backend/src/communities/dto/community-query.dto.ts ###
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { PaginationDto } from '../../common/dto/pagination.dto';
import { CommunityType } from '../types';

export class CommunityQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  displayName?: string;

  @IsOptional()
  @IsEnum(CommunityType)
  communityType?: CommunityType;

  @IsOptional()
  @IsString()
  sort?: string;
}

---


### FILE: backend/src/communities/dto/update-community.dto.ts ###
import { PartialType } from '@nestjs/mapped-types';
import { CreateCommunityDto } from './create-community.dto';

export class UpdateCommunityDto extends PartialType(CreateCommunityDto) {}

---


### FILE: backend/src/mail/interfaces/mail-service.interface.ts ###
export interface IMailService {
  sendEmail(
    to: string,
    subject: string,
    templateName: string,
    context: any,
  ): Promise<void>;
}

---


### FILE: backend/src/mail/services/nodemailer-mail.service.ts ###
import { Injectable } from '@nestjs/common';
import { MailerService } from '@nestjs-modules/mailer';
import { IMailService } from '../interfaces/mail-service.interface';

@Injectable()
export class NodemailerMailService implements IMailService {
  constructor(private readonly mailerService: MailerService) {}

  async sendEmail(
    to: string,
    subject: string,
    templateName: string,
    context: any,
  ): Promise<void> {
    await this.mailerService.sendMail({
      to,
      subject,
      template: templateName,
      context,
    });
  }
}

---


### FILE: backend/src/mail/mail.module.ts ###
import { Module } from '@nestjs/common';
import { MailerModule } from '@nestjs-modules/mailer';
import { NodemailerMailService } from './services/nodemailer-mail.service';
import { IMailService } from './interfaces/mail-service.interface';
import { ConfigService } from '@nestjs/config';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
@Module({
  imports: [
    MailerModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        transport: {
          host: config.getOrThrow<string>('SMTP_HOST'),
          port: config.getOrThrow<number>('SMTP_PORT'),
          secure: false,
          /* auth: {
            user: config.getOrThrow<string>('SMTP_USER'),
            pass: config.getOrThrow<string>('SMTP_PASS'),
          },*/
        },
        defaults: {
          from: config.getOrThrow<string>('SMTP_FROM'),
        },
        template: {
          dir: process.cwd() + '/src/mail/templates',
          adapter: new HandlebarsAdapter(),
          options: { strict: true },
        },
      }),
    }),
  ],
  providers: [
    {
      provide: 'IMailService',
      useClass: NodemailerMailService,
    },
  ],
  exports: ['IMailService'],
})
export class MailModule {}

---


### FILE: backend/src/app.service.ts ###
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return '<h1>Hello World!';
  }
}

---


### FILE: backend/src/profile/profile.service.ts ###
import { ConflictException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Not, Repository } from 'typeorm';
import { Profile } from './entities/profile.entity';
import { User } from 'src/users/entities/user.entity';

interface CreateProfileParams {
  user: User;
  displayName: string;
  bio?: string | null;
  picture?: string | null;
}

interface UpdateProfileParams {
  profile: Profile;
  displayName?: string | null;
  bio?: string | null;
  picture?: string | null; // This will now be the file path
}

@Injectable()
export class ProfileService {
  constructor(
    @InjectRepository(Profile)
    private readonly profileRepo: Repository<Profile>,
  ) { }

async createProfile(params: CreateProfileParams): Promise<Profile> {
  try {
    const existingProfile = await this.findOneByUserId(params.user.id).catch(() => null);
    if (existingProfile) {
      throw new ConflictException('Profile already exists for this user.');
    }

    const existingDisplayname = await this.profileRepo.findOne({
      where: { displayName: params.displayName },
    });
    if (existingDisplayname) {
      throw new ConflictException('Username is already taken.');
    }

    const profile = this.profileRepo.create({
      user: params.user,
      displayName: params.displayName ?? null,
      bio: params.bio ?? null,
      picture: params.picture ?? null,
    });

    const savedProfile = await this.profileRepo.save(profile);

    const fullProfile = await this.profileRepo.findOne({
      where: { id: savedProfile.id },
      relations: ['user'],
    });

    if (!fullProfile) {
      throw new NotFoundException('Failed to retrieve the created profile.');
    }

    return fullProfile;
  } catch (err) {
    // Optional: log error here
    throw err;
  }
}

async updateProfile(params: UpdateProfileParams): Promise<Profile> {
  const { profile, displayName, bio, picture } = params;

  if (displayName) {
    const existingDisplayname = await this.profileRepo.findOne({
      where: { displayName, id: Not(profile.id) },
    });
    if (existingDisplayname) {
      throw new ConflictException('Display name is already taken.');
    }
  }

  Object.assign(profile, {
    ...(displayName !== undefined && { displayName }),
    ...(bio !== undefined && { bio }),
    ...(picture !== undefined && { picture }),
  });

  const savedProfile = await this.profileRepo.save(profile);

  const fullProfile = await this.profileRepo.findOne({
    where: { id: savedProfile.id },
    relations: ['user'],
  });

  if (!fullProfile) {
    throw new NotFoundException('Failed to retrieve the updated profile.');
  }

  return fullProfile;
}

  async findOneByUserId(userId: number): Promise<Profile > {
    const profile = await this.profileRepo.findOne({
      where: { user: { id: userId } },
      relations: ['user'] // Eager load the user entity
    });
    if (!profile) {
      throw new NotFoundException(`Profile for user with ID ${userId} not found.`);
    }
    return profile;
  }
}
---


### FILE: backend/src/profile/dtos/create-profile.dto.ts ###
import { IsNotEmpty, IsString, IsOptional, IsAlphanumeric, MinLength, MaxLength } from 'class-validator';

export class CreateProfileDto {
  @IsNotEmpty()
  @IsString()
  @IsAlphanumeric()
  @MinLength(3)
  @MaxLength(20)
  displayName: string;

  @IsOptional()
  @IsString()
  @MaxLength(255)
  bio?: string;
}
---


### FILE: backend/src/profile/dtos/update-profile.dto.ts ###
import { IsOptional, IsString, IsUrl, IsAlphanumeric, MinLength, MaxLength } from 'class-validator';

export class UpdateProfileDto {
  @IsOptional()
  @IsString()
  @IsAlphanumeric()
  @MinLength(3)
  @MaxLength(20)
  displayName?: string;

  @IsOptional()
  @IsString()
  @MaxLength(255)
  bio?: string;
}

---


### FILE: backend/src/profile/dtos/profile-response.dto.ts ###
import { Expose, Type } from 'class-transformer'; // Add Type
import { Profile } from '../entities/profile.entity';
import { UserResponseDto } from '../../users/dtos/user-response.dto'; // Import UserResponseDto

export class ProfileResponseDto {
  @Expose()
  id: number;

  @Expose()
  displayName: string;

  @Expose()
  bio: string | null;

  @Expose()
  picture: string | null;

  @Expose()
  @Type(() => UserResponseDto) // Specify the type for nesting
  user: UserResponseDto; // Nested user object

  /**
   * Factory method: converts a Profile entity into this DTO.
   * Purely copies values; no business or environment logic.
   */
  static fromEntity(entity: Profile): ProfileResponseDto {
    const dto = new ProfileResponseDto();
    dto.id = entity.id;
    dto.displayName = entity.displayName;
    dto.bio = entity.bio ?? null;
    dto.picture = entity.picture ?? null;

    // Populate nested user object
    if (entity.user) {
      dto.user = UserResponseDto.fromEntity(entity.user);
    } else {
      console.warn('Profile entity passed to ProfileResponseDto.fromEntity is missing the user relation.');
    }

    return dto;
  }
}

---


### FILE: backend/src/profile/interceptors/picture.interceptor.ts ###
import { FileInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname } from 'path';

/**
 * Reusable interceptor for profile picture uploads.
 * @param field The name of the file field (default: 'picture')
 */
export function PictureInterceptor(field = 'picture') {
  return FileInterceptor(field, {
    storage: diskStorage({
      destination: './uploads',
      filename: (_req, file, cb) => {
        const randomName = Array(32)
          .fill(null)
          .map(() => Math.floor(Math.random() * 16).toString(16))
          .join('');
        cb(null, `${randomName}${extname(file.originalname)}`);
      },
    }),
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
    fileFilter: (_req, file, callback) => {
      const allowedTypes = /jpeg|jpg|png|gif/;
      callback(null, allowedTypes.test(file.mimetype));
    },
  });
}

---


### FILE: backend/src/profile/profile.controller.ts ###
import {
  Controller,
  Get,
  UseGuards,
  Patch,
  Body,
  UseInterceptors,
  UploadedFile,
  Post,
  ConflictException,
  Param, // NEW
  ParseIntPipe, // NEW
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ProfileService } from './profile.service';
import { UpdateProfileDto } from './dtos/update-profile.dto';
import { CreateProfileDto } from './dtos/create-profile.dto';
import { User } from 'src/users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { FileInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname } from 'path';
import { ProfileResponseDto } from './dtos/profile-response.dto';
import { ConfigService } from '@nestjs/config';
import { PictureInterceptor } from './interceptors/picture.interceptor';
import { ResponseDto } from 'src/common/dto/response.dto';

@Controller('profile')
export class ProfileController {
  constructor(private readonly profileService: ProfileService

  ) { }
  @UseGuards(JwtAuthGuard)
  @Get()
  async getMyProfile(@GetUser() user: User): Promise<ResponseDto<ProfileResponseDto>> {
    const profile = await this.profileService.findOneByUserId(user.id);
    return new ResponseDto(ProfileResponseDto.fromEntity(profile));
  }

  // New endpoint to get a profile by user ID
  @Get('user/:userId')
  async getProfileByUserId(@Param('userId', ParseIntPipe) userId: number): Promise<ResponseDto<ProfileResponseDto>> {
    const profile = await this.profileService.findOneByUserId(userId);
    return new ResponseDto(ProfileResponseDto.fromEntity(profile));
  }

  @UseGuards(JwtAuthGuard)
  @Post()
  @UseInterceptors(PictureInterceptor
  )
  async createMyProfile(
    @GetUser() user: User,
    @Body() createProfileDto: CreateProfileDto,
    @UploadedFile() file: Express.Multer.File,
  ): Promise<ResponseDto<ProfileResponseDto>> {

    const profile = await this.profileService.createProfile({
      user,
      displayName: createProfileDto.displayName,
      bio: createProfileDto.bio,
      picture: file ? file.path : undefined,
    });

    return new ResponseDto(ProfileResponseDto.fromEntity(profile));
  }

  @UseGuards(JwtAuthGuard)
  @Patch()
  @UseInterceptors(PictureInterceptor)
  async updateMyProfile(
    @GetUser() user: User,
    @Body() updateProfileDto: UpdateProfileDto,
    @UploadedFile() file: Express.Multer.File,
  ): Promise<ResponseDto<ProfileResponseDto>> {
    const profile = await this.profileService.findOneByUserId(user.id);

    const updatedProfile = await this.profileService.updateProfile({
      profile,
      displayName: updateProfileDto.displayName,
      bio: updateProfileDto.bio,
      picture: file ? file.path : undefined,
    });

    return new ResponseDto(ProfileResponseDto.fromEntity(updatedProfile));
  }
}
---


### FILE: backend/src/profile/entities/profile.entity.ts ###
// src/profile/entities/profile.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, OneToOne, JoinColumn } from 'typeorm';
import { User } from '../../users/entities/user.entity'; // Updated path

@Entity('profiles') // Updated entity name
export class Profile { // Updated class name
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', unique: true })
  displayName: string;

  @Column({ type: 'text', nullable: true })
  bio: string | null;

  @Column({ type: 'varchar', nullable: true })
  picture: string | null;

  @OneToOne(() => User, user => user.profile)
  @JoinColumn()
  user: User;
}

---


### FILE: backend/src/profile/profile.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Profile } from './entities/profile.entity';
import { ProfileService } from './profile.service';
import { ProfileController } from './profile.controller';

@Module({
  imports: [TypeOrmModule.forFeature([Profile])],
  providers: [ProfileService],
  controllers: [ProfileController],
  exports: [ProfileService], // Export ProfileService so other modules can use it
})
export class ProfileModule {}

---


### FILE: backend/src/community-restrictions/community-restrictions.module.ts ###
import { Module } from '@nestjs/common';
import { CommunityRestrictionsService } from './community-restrictions.service';
import { CommunityRestrictionsController } from './community-restrictions.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';
import { User } from 'src/users/entities/user.entity';
import { CommunityRestriction } from './entities/community-restriction.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      CommunityRestriction,
      Community,
      User,
      CommunityMembership,
    ]),
  ],
  controllers: [CommunityRestrictionsController],
  providers: [CommunityRestrictionsService],
  exports: [CommunityRestrictionsService],
})
export class CommunityRestrictionsModule {}

---


### FILE: backend/src/community-restrictions/community-restrictions.controller.ts ###
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  ParseIntPipe,
  UseGuards,
} from '@nestjs/common';
import { CommunityRestrictionsService } from './community-restrictions.service';
import { CreateCommunityRestrictionDto } from './dto/create-community-restriction.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { User } from '../users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { UpdateCommunityRestrictionDto } from './dto/update-community-restriction.dto';
import { CaslService } from 'src/casl/casl.service';
import { Action } from 'src/casl/casl.types';
import { CommunityRestriction } from './entities/community-restriction.entity';
import { CommunityRestrictionResponseDto } from './dto/community-restriction-response.dto';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { CommunityRestrictionQueryDto } from './dto/community-restriction-query.dto';

@Controller('community-restrictions')
export class CommunityRestrictionsController {
  constructor(
    private readonly communityRestrictionsService: CommunityRestrictionsService,
  ) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  async create(
    @Body() createCommunityRestrictionDto: CreateCommunityRestrictionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommunityRestrictionResponseDto>> {
    // TODO: Add CASL check
    const restriction = await this.communityRestrictionsService.create(
      {
        restrictionType: createCommunityRestrictionDto.restrictionType,
        communityId: createCommunityRestrictionDto.communityId,
        userId: createCommunityRestrictionDto.userId,
        expiresAt:createCommunityRestrictionDto.expiresAt ,
        reason:createCommunityRestrictionDto.reason
      },
      user,
    );
    return new ResponseDto(CommunityRestrictionResponseDto.fromEntity(restriction));
  }

  @Get()
  @UseGuards(JwtAuthGuard)
  async findAll(
    @Query() query: CommunityRestrictionQueryDto,
    @GetUser() user: User,
  ): Promise<PaginatedResponseDto<CommunityRestrictionResponseDto>> {
    const { data, count } = await this.communityRestrictionsService.findAll(query, user);
    console.log(data);
    
    const paginationMeta = new PaginationMetaDto(query.page, query.limit, count, data.length);

    return new PaginatedResponseDto(
      data.map(CommunityRestrictionResponseDto.fromEntity),
      paginationMeta,
    );
  }

  @Get(':id')
  @UseGuards(JwtAuthGuard)
  async findOne(
    @Param('id', ParseIntPipe) id: number,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommunityRestrictionResponseDto>> {
    const restriction = await this.communityRestrictionsService.findOne(id, user);
    return new ResponseDto(CommunityRestrictionResponseDto.fromEntity(restriction));
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateCommunityRestrictionDto: UpdateCommunityRestrictionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommunityRestrictionResponseDto>> {
    // TODO: Add CASL check
    const restriction = await this.communityRestrictionsService.update(
      id,
      { restrictionType: updateCommunityRestrictionDto.restrictionType },
      user,
    );
    return new ResponseDto(CommunityRestrictionResponseDto.fromEntity(restriction));
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  async remove(
    @Param('id', ParseIntPipe) id: number,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    // TODO: Add CASL check
    await this.communityRestrictionsService.remove(id, user);
    return new ResponseDto(true);
  }
}

---


### FILE: backend/src/community-restrictions/entities/community-restriction.entity.ts ###
import {
  Column,
  CreateDateColumn,
  Entity,
  ManyToOne,
  PrimaryGeneratedColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';
import { CommunityRestrictionType } from '../community-restrictions.types';

@Entity('community_restrictions')
export class CommunityRestriction {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'simple-enum', enum: CommunityRestrictionType })
  restrictionType: CommunityRestrictionType;

  @Column({ type: 'text', nullable: true })
  reason: string;

  @Column({ type: 'datetime', nullable: true })
  expiresAt?: Date;

  @ManyToOne(() => Community, (community) => community.restrictions)
  community: Community;

  @ManyToOne(() => User, (user) => user.communityRestrictions)
  user: User;

  @ManyToOne(() => User)
  createdBy: User;

  @Column()
  createdById: number;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: backend/src/community-restrictions/community-restrictions.service.ts ###
import {
  ConflictException,
  ForbiddenException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CommunityRestriction } from './entities/community-restriction.entity';
import { User } from '../users/entities/user.entity';
import { DataSource } from 'typeorm';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';
import { CommunityMembershipRole } from 'src/community-memberships/types';
import { CommunityRestrictionType } from './community-restrictions.types';

@Injectable()
export class CommunityRestrictionsService {
  constructor(
    private dataSource: DataSource,
    @InjectRepository(CommunityRestriction)
    private readonly communityRestrictionsRepository: Repository<CommunityRestriction>,
    @InjectRepository(Community)
    private readonly communityRepository: Repository<Community>,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(CommunityMembership)
    private readonly communityMembershipRepository: Repository<CommunityMembership>,
  ) {}

  // Create a restriction (members only, moderators cannot be restricted)
  async create(
    data: {
      restrictionType: CommunityRestrictionType;
      communityId: number;
      userId: number;
      reason?: string;
      expiresAt?: Date;
    },
    user: User,
  ) {
    const community = await this.communityRepository.findOne({
      where: { id: data.communityId },
    });
    if (!community) {
      throw new NotFoundException('Community not found');
    }
console.log(data.expiresAt);

    const targetUser = await this.userRepository.findOne({
      where: { id: data.userId },
      relations: ['communityMemberships'],
    });
    if (!targetUser) {
      throw new NotFoundException('User to restrict not found');
    }

    // Only moderators can manage restrictions
    await this.canManageRestrictions(user.id, community.id);

    // Prevent restricting another moderator
    const targetMembership = targetUser.communityMemberships.find(
      (membership) => membership.communityId === community.id,
    );

    if (targetMembership?.role === CommunityMembershipRole.MODERATOR) {
      throw new ForbiddenException('You cannot restrict a moderator.');
    }

    const existingRestriction = await this.communityRestrictionsRepository.findOne({
      where: {
        community: { id: community.id },
        user: { id: targetUser.id },
      },
    });

    if (existingRestriction) {
      throw new ConflictException('This user is already restricted in this community.');
    }

    const restriction = this.communityRestrictionsRepository.create({
      restrictionType: data.restrictionType,
      reason: data.reason,
      expiresAt: data.expiresAt,
      community,
      user: targetUser,
      createdBy: user,
    });

    return this.communityRestrictionsRepository.save(restriction);
  }

  // List restrictions (paginated)
  async findAll(
    query: { communityId?: number; limit?: number; page?: number },
    user: User,
  ) {
    const { communityId, limit = 10, page = 1 } = query;

    const queryBuilder = this.communityRestrictionsRepository
      .createQueryBuilder('restriction')
      .leftJoinAndSelect('restriction.community', 'community')
      .leftJoinAndSelect('restriction.user', 'user')
      .take(limit)
      .skip((page - 1) * limit);

    if (communityId) {
      const community = await this.communityRepository.findOne({
        where: { id: communityId },
      });
      if (!community) {
        throw new NotFoundException('Community not found');
      }

      await this.canManageRestrictions(user.id, community.id);

      queryBuilder.andWhere('restriction.communityId = :communityId', { communityId });
    }

    const [data, count] = await queryBuilder.getManyAndCount();
    return { data, count };
  }

  // Get a single restriction
  async findOne(id: number, user: User) {
    const restriction = await this.communityRestrictionsRepository.findOne({
      where: { id },
      relations: ['community'],
    });

    if (!restriction) {
      throw new NotFoundException('Restriction not found');
    }

    await this.canManageRestrictions(user.id, restriction.community.id);

    return restriction;
  }

  // Update a restriction
  async update(
    id: number,
    data: {
      restrictionType?: CommunityRestrictionType;
      reason?: string;
      expiresAt?: Date;
    },
    user: User,
  ) {
    const restriction = await this.communityRestrictionsRepository.findOne({
      where: { id },
      relations: ['community'],
    });

    if (!restriction) {
      throw new NotFoundException('Restriction not found');
    }

    await this.canManageRestrictions(user.id, restriction.community.id);

    if (data.restrictionType) {
      restriction.restrictionType = data.restrictionType;
    }
    if (data.reason !== undefined) {
      restriction.reason = data.reason;
    }
    if (data.expiresAt !== undefined) {
      restriction.expiresAt = data.expiresAt;
    }

    return this.communityRestrictionsRepository.save(restriction);
  }

  // Get restriction by ID (internal)
  async findOneById(id: number) {
    return this.communityRestrictionsRepository.findOne({
      where: { id },
      relations: ['community', 'user'],
    });
  }

  // Remove a restriction
  async remove(id: number, user: User): Promise<boolean> {
    const restriction = await this.communityRestrictionsRepository.findOne({
      where: { id },
      relations: ['community'],
    });

    if (!restriction) {
      throw new NotFoundException('Restriction not found');
    }

    await this.canManageRestrictions(user.id, restriction.community.id);

    await this.communityRestrictionsRepository.remove(restriction);
    return true;
  }

  // Generic reusable authorization helper
  private async canManageRestrictions(userId: number, communityId: number) {
    const membership = await this.communityMembershipRepository.findOne({
      where: { communityId, userId },
    });

    if (!membership || membership.role !== CommunityMembershipRole.MODERATOR) {
      throw new ForbiddenException('You do not have permission in this community.');
    }

    return membership;
  }
}

---


### FILE: backend/src/community-restrictions/dto/community-restriction-response.dto.ts ###
import { Expose, Transform, Type } from 'class-transformer';
import { CommunityRestrictionType } from '../community-restrictions.types';
import { CommunityRestriction } from '../entities/community-restriction.entity';
import { UserResponseDto } from '../../users/dtos/user-response.dto'; // Import UserResponseDto

export class CommunityRestrictionResponseDto {
  @Expose()
  id: number;

  @Expose()
  restrictionType: CommunityRestrictionType;

  @Expose()
  reason: string;

  @Expose()
  @Transform(({ value }) => value ? value.toISOString() : null)
  expiresAt: Date | null;

  @Expose()
  @Transform(({ obj }) => obj.community.id)
  communityId: number;

  @Expose()
  @Transform(({ obj }) => obj.user.id)
  userId: number;

  @Expose()
  @Type(() => UserResponseDto) // Expose the full user object
  user: UserResponseDto | null; // Add user property

  @Expose()
  @Transform(({ obj }) => obj.createdBy.id)
  createdById: number;

  @Expose()
  @Transform(({ value }) => value.toISOString())
  createdAt: Date;

  static fromEntity(entity: CommunityRestriction): CommunityRestrictionResponseDto {
    const dto = new CommunityRestrictionResponseDto();
    Object.assign(dto, entity);
    // Manually map the user entity to UserResponseDto
    dto.user = entity.user ? UserResponseDto.fromEntity(entity.user) : null;
    return dto;
  }
}

---


### FILE: backend/src/community-restrictions/dto/community-restriction-query.dto.ts ###
import { IsEnum, IsNumber, IsOptional } from 'class-validator';
import { PaginationDto } from '../../common/dto/pagination.dto';
import { CommunityRestrictionType } from '../community-restrictions.types';
import { Type } from 'class-transformer';

export class CommunityRestrictionQueryDto extends PaginationDto {
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  communityId?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  userId?: number;

  @IsOptional()
  @IsEnum(CommunityRestrictionType)
  restrictionType?: CommunityRestrictionType;
}
---


### FILE: backend/src/community-restrictions/dto/create-community-restriction.dto.ts ###
import { IsNumber, IsEnum, IsOptional, IsString, IsDateString, IsDate } from 'class-validator';
import { CommunityRestrictionType } from '../community-restrictions.types';
import { Type } from 'class-transformer';

export class CreateCommunityRestrictionDto {
  @IsNumber()
  communityId: number;

  @IsNumber()
  userId: number;

  @IsEnum(CommunityRestrictionType)
  restrictionType: CommunityRestrictionType;

  @IsOptional()
  @IsString()
  reason?: string;

  @IsOptional()
@IsDate() // Use @IsDate() instead of @IsDateString()
@Type(() => Date) // Automatically converts string to Date object
  expiresAt?: Date;
}
---


### FILE: backend/src/community-restrictions/dto/update-community-restriction.dto.ts ###
import { PartialType } from '@nestjs/mapped-types';
import { IsEnum, IsOptional, IsString, IsDateString } from 'class-validator';
import { CommunityRestrictionType } from '../community-restrictions.types';

export class UpdateCommunityRestrictionDto {
  @IsEnum(CommunityRestrictionType)
  @IsOptional()
  restrictionType?: CommunityRestrictionType;

  @IsOptional()
  @IsString()
  reason?: string;

  @IsOptional()
  @IsDateString()
  expiresAt?: string;
}

---


### FILE: backend/src/community-restrictions/community-restrictions.types.ts ###
export enum CommunityRestrictionType {
  BAN = 'ban',
  MUTE = 'mute',
}

---


### FILE: backend/src/app.module.ts ###
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';

import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UsersModule } from './users/users.module';
import { PostsModule } from './posts/posts.module';
import { CommentsModule } from './comments/comments.module';
import { ReactionsModule } from './reactions/reactions.module';
import { CommunitiesModule } from './communities/communities.module';
import { CommunityMembershipsModule } from './community-memberships/community-memberships.module';

import { User } from './users/entities/user.entity';
import { Post } from './posts/entities/post.entity';
import { Comment } from './comments/entities/comment.entity';
import { AuthModule } from './auth/auth.module';
import { CaslModule } from './casl/casl.module';
import { EmailVerificationToken } from './email-verification/entities/email-verification-token.entity';

import { ResetPasswordModule } from './reset-password/reset-password.module';
import { PasswordResetToken } from './reset-password/entities/password-reset-token.entity';
import { CommentReaction } from './reactions/entities/comment-reaction.entity';
import { PostReaction } from './reactions/entities/post-reaction.entity';
import { Profile } from './profile/entities/profile.entity';
import { ProfileModule } from './profile/profile.module';
import { Community } from './communities/entities/community.entity';
import { CommunityMembership } from './community-memberships/entities/community-memberships.entity';
import { ReportsModule } from './reports/reports.module';
import { CommentReport } from './reports/entities/comment-report.entity';
import { PostReport } from './reports/entities/post-report.entity';
import { UserReport } from './reports/entities/user-report.entity';
import { CommunityMembershipRequest } from './community-membership-requests/entities/community-membership-request.entity';
import { CommunityMembershipRequestsModule } from './community-membership-requests/community-membership-requests.module';
import { EmailChangeToken } from './email-change/entities/email-change-token.entity';
import { EmailChangeModule } from './email-change/email-change.module';
import { CommunityRestriction } from './community-restrictions/entities/community-restriction.entity';
import { CommunityRestrictionsModule } from './community-restrictions/community-restrictions.module';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }), // loads .env globally

    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        type: config.getOrThrow<'sqlite' | 'mysql'>('DB_TYPE'),
        database: config.getOrThrow<string>('DB_NAME'),
        entities: [
          User,
          Post,
          Comment,
          CommentReaction,
          PostReaction,
          EmailVerificationToken,
          PasswordResetToken,
          Profile,
          Community,
          CommunityMembership,
          CommunityMembershipRequest, // NEW ENTITY
          CommentReport,
          PostReport,
          UserReport,
          CommunityRestriction,
          EmailChangeToken,
        ],
        migrations: ['./src/migrations/*.ts'],
        synchronize: false,
      }),
    }),

    UsersModule,
    PostsModule,
    CommentsModule,
    ReactionsModule,
    AuthModule,
    CaslModule,
    ResetPasswordModule,
    ProfileModule,
    CommunitiesModule,
    CommunityMembershipsModule,
    CommunityMembershipRequestsModule, // NEW MODULE
    ReportsModule,
    CommunityRestrictionsModule,
    EmailChangeModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

---


### FILE: backend/src/data-source.ts ###
import { DataSource } from 'typeorm';
import { config } from 'dotenv';
import { Post } from './posts/entities/post.entity';
import { User } from './users/entities/user.entity';
import { Comment } from './comments/entities/comment.entity';
import { PostReaction } from './reactions/entities/post-reaction.entity';
import { CommentReaction } from './reactions/entities/comment-reaction.entity';
import { EmailVerificationToken } from './email-verification/entities/email-verification-token.entity';
import { PasswordResetToken } from './reset-password/entities/password-reset-token.entity';
import { Profile } from './profile/entities/profile.entity';
import { Community } from './communities/entities/community.entity'; // Import Community
import { CommunityMembership } from './community-memberships/entities/community-memberships.entity'; // Import CommunityMembership
import { PostReport } from './reports/entities/post-report.entity';
import { CommentReport } from './reports/entities/comment-report.entity';
import { CommunityRestriction } from './community-restrictions/entities/community-restriction.entity';
import { UserReport } from './reports/entities/user-report.entity';

import { CommunityMembershipRequest } from './community-membership-requests/entities/community-membership-request.entity';
import { EmailChangeToken } from './email-change/entities/email-change-token.entity';

config(); // load .env manually

const dbName = process.env.DB_NAME;
if (!dbName) {
  throw new Error('DB_NAME environment variable is not defined.');
}

export const AppDataSource = new DataSource({
  type: 'sqlite',
  database: dbName,
  entities: [
    User,
    Post,
    Comment,
    PostReaction,
    CommentReaction,
    PasswordResetToken,
    EmailChangeToken,
    EmailVerificationToken,
    Profile,
    Community, // Add Community
    CommunityMembership, // Add CommunityMembership
    CommunityMembershipRequest, // Add CommunityMembershipRequest
    PostReport,
    CommentReport,
    UserReport,
    CommunityRestriction,
  ],
  synchronize: false,
  migrations: ['src/database/migrations/*.ts'],
  logging: true,
});

---


### FILE: backend/src/email-change/email-change.controller.ts ###
import {
  Controller,
  Post,
  Body,
  UseGuards,
  HttpCode,
  HttpStatus,
  Query,
  Get,
} from '@nestjs/common';
import { EmailChangeService } from './email-change.service';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { RequestEmailChangeDto } from './dto/request-email-change.dto';
import { VerifyEmailChangeDto } from './dto/verify-email-change.dto'; // Import the new DTO

@Controller('email/change')
export class EmailChangeController {
  constructor(private readonly emailChangeService: EmailChangeService) {}

  @Post('request')
  @UseGuards(JwtAuthGuard)
  @HttpCode(HttpStatus.OK)
  async requestEmailChange(
    @GetUser() user: User,
    @Body() { newEmail, currentPassword }: RequestEmailChangeDto,
  ): Promise<{ message: string }> {
    await this.emailChangeService.requestEmailChange(user, newEmail, currentPassword);
    return {
      message:
        'Verification email sent to your new address. Please check your inbox to complete the change.',
    };
  }

  @Get('verify') // Changed to POST
  @HttpCode(HttpStatus.OK)
  async verifyEmailChange(
    @Query('token') token: string,
  ): Promise<{ message: string }> {
    await this.emailChangeService.verifyEmailChange(token);
    return { message: 'Your email address has been successfully updated.' };
  }
}

---


### FILE: backend/src/email-change/entities/email-change-token.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';

@Entity('email_change_tokens')
export class EmailChangeToken {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 100 })
  newEmail: string;

  @Column({ type: 'varchar', unique: true })
  token: string;

  @Column({ type: 'datetime' })
  expiresAt: Date;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;

  @Column()
  userId: number; // Foreign key

  @Column({ type: 'datetime', default: () => 'CURRENT_TIMESTAMP' })
  createdAt: Date;
}

---


### FILE: backend/src/email-change/email-change.service.ts ###
import * as bcrypt from 'bcrypt';
import {
  Injectable,
  BadRequestException,
  InternalServerErrorException,
  Inject,
  ConflictException,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { randomUUID } from 'crypto';
import { EmailChangeToken } from './entities/email-change-token.entity'; // Corrected import
import { UsersService } from 'src/users/users.service';
import type { IMailService } from 'src/mail/interfaces/mail-service.interface';
import { ConfigService } from '@nestjs/config';
import { User } from 'src/users/entities/user.entity';

@Injectable()
export class EmailChangeService {
  constructor(
    @InjectRepository(EmailChangeToken) // Corrected injection
    private readonly emailChangeRepo: Repository<EmailChangeToken>,
    private readonly usersService: UsersService,
    private readonly configService: ConfigService,
    @Inject('IMailService')
    private readonly mailService: IMailService,
  ) {
    this.EXPIRATION_MS = this.configService.get<number>(
      'EMAIL_CHANGE_TOKEN_EXPIRATION',
      15 * 60 * 1000,
    );
  }
  EXPIRATION_MS: number;

  private generateVerificationLink(token: string): string {
    const domain = this.configService.get<string>('FRONTEND_URL');
    const path = '/email/change/verify'; // The path for the frontend email change verification page
    return `${domain}${path}?token=${token}`;
  }

  async requestEmailChange(
    user: User,
    newEmail: string,
    currentPassword: string,
  ): Promise<void> {
    if (!user.password) {
      throw new BadRequestException('User does not have a password set.');
    }

    if (!currentPassword) {
      throw new BadRequestException('Current password is required.');
    }

    const isPasswordMatching = await bcrypt.compare(
      currentPassword,
      user.password,
    );

    if (!isPasswordMatching) {
      throw new UnauthorizedException('Incorrect current password');
    }

    if (user.email === newEmail) {
      throw new BadRequestException('New email cannot be the same as the current email.');
    }

    const emailExists = await this.usersService.findByEmail(newEmail).catch(() => null);
    if (emailExists && emailExists.id !== user.id) {
      throw new ConflictException('Email already in use by another user.');
    }

    // Delete any existing pending email change requests for this user
    await this.emailChangeRepo.delete({ userId: user.id });

    const token = randomUUID();
    const record = this.emailChangeRepo.create({
      userId: user.id,
      newEmail,
      token,
      expiresAt: new Date(Date.now() + this.EXPIRATION_MS),
    });

    await this.emailChangeRepo.save(record);

    const verifyUrl = this.generateVerificationLink(token);

    try {
      await this.mailService.sendEmail(
        newEmail,
        'Verify Your New Email Address',
        'email-change-verification', // New template name
        { username: user.username, verifyUrl },
      );
    } catch (err) {
      console.error('Error sending email change verification email:', err);
      throw new InternalServerErrorException(
        'Failed to send email change verification email',
      );
    }
  }

  async verifyEmailChange(token: string): Promise<User> {
    const record = await this.emailChangeRepo.findOne({ where: { token }, relations: ['user'] });

    if (!record) {
      throw new BadRequestException('Invalid or expired email change token.');
    }
    if (record.expiresAt < new Date()) {
      await this.emailChangeRepo.delete({ token });
      throw new BadRequestException('Email change token expired.');
    }

    const user = await this.usersService.updateEmail(record.userId, record.newEmail);
    // Mark email as verified immediately after successful change
    await this.usersService.markEmailAsVerified(user.id);
    await this.emailChangeRepo.delete({ token });

    return user;
  }
}

---


### FILE: backend/src/email-change/dto/request-email-change.dto.ts ###
import { IsEmail, IsString, MinLength } from 'class-validator';

export class RequestEmailChangeDto {
  @IsEmail({}, { message: 'New email must be a valid email address.' })
  newEmail: string;

  @IsString({ message: 'Current password must be a string.' })
  @MinLength(6, { message: 'Current password must be at least 6 characters long.' })
  currentPassword: string;
}

---


### FILE: backend/src/email-change/dto/verify-email-change.dto.ts ###
import { IsNotEmpty, IsString } from 'class-validator';

export class VerifyEmailChangeDto {
  @IsString()
  @IsNotEmpty()
  token: string;
}
---


### FILE: backend/src/email-change/email-change.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { EmailChangeService } from './email-change.service';
import { EmailChangeController } from './email-change.controller';
import { EmailChangeToken } from './entities/email-change-token.entity';
import { UsersModule } from 'src/users/users.module';
import { MailModule } from 'src/mail/mail.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([EmailChangeToken]),
    UsersModule,
    MailModule,
  ],
  providers: [EmailChangeService],
  controllers: [EmailChangeController],
  exports: [EmailChangeService],
})
export class EmailChangeModule {}

---


### FILE: backend/src/comments/pipes/comment.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { CommentsService } from '../comments.service';
import { Comment } from '../entities/comment.entity';

@Injectable()
export class CommentPipe implements PipeTransform<string, Promise<Comment>> {
  constructor(private readonly commentsService: CommentsService) {}

  async transform(value: string): Promise<Comment> {
    const comment = await this.commentsService.findOne(+value);

    if (!comment) {
      throw new NotFoundException('Comment not found');
    }

    return comment;
  }
}

---


### FILE: backend/src/comments/comments.service.ts ###
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm'; // Added DataSource
import { Comment } from './entities/comment.entity';
import { Post } from 'src/posts/entities/post.entity'; // Added Post entity

// import { PostsService } from 'src/posts/posts.service'; // Removed PostsService

@Injectable()
export class CommentsService {
  constructor(
    @InjectRepository(Comment)
    private readonly commentRepo: Repository<Comment>,
    // private readonly postsService: PostsService, // Removed PostsService
    @InjectRepository(Post) // Injected Post repository
    private readonly postRepo: Repository<Post>,
    private dataSource: DataSource, // Injected DataSource
  ) { }

  async findAll(options: {
    postId?: number;
    authorId?: number;
    search?: string;
    page?: number;
    limit?: number;
    currentUserId?: number;
    parentId?: number;
  }): Promise<{ data: Comment[]; count: number }> {
    const { postId, authorId, search, page = 1, limit = 10, currentUserId, parentId } = options;
console.error('e',postId);

    const query = this.commentRepo
      .createQueryBuilder('comment')
      .leftJoinAndSelect('comment.author', 'author')
      .leftJoinAndSelect('comment.post', 'post')
      .leftJoinAndSelect('comment.parent', 'parent');

    if (parentId) {
      query.andWhere('comment.parentId = :parentId', { parentId });
    } else if (postId) {
      query.andWhere('comment.parentId IS NULL');
    }

    if (currentUserId) {
      query.leftJoinAndMapOne(
        'comment.userReaction',
        'comment.reactions',
        'userReaction',
        'userReaction.userId = :currentUserId',
      );
      query.setParameter('currentUserId', currentUserId);
    }

    if (search) {
      query.andWhere('comment.content LIKE :search', { search: `%${search}%` });
    }
    if (authorId) {
      query.andWhere('comment.author.id = :authorId', { authorId });
    }
    if (postId) {
      query.andWhere('comment.post.id = :postId', { postId });
    }

    query.orderBy('comment.createdAt', 'DESC');

    const [data, count] = await query.take(limit).skip((page - 1) * limit).getManyAndCount();

    const commentsWithLimitedReplies = await Promise.all(
      data.map(async (comment) => {
        const repliesQuery = this.commentRepo
          .createQueryBuilder('reply')
          .leftJoinAndSelect('reply.author', 'author')
          .where('reply.parentId = :commentId', { commentId: comment.id })
          .orderBy('reply.createdAt', 'ASC')
          .take(2);

        if (currentUserId) {
          repliesQuery.leftJoinAndMapOne(
            'reply.userReaction',
            'reply.reactions',
            'userReaction',
            'userReaction.userId = :currentUserId',
          );
          repliesQuery.setParameter('currentUserId', currentUserId);
        }

        comment.replies = await repliesQuery.getMany();
        return comment;
      }),
    );

    return { data: commentsWithLimitedReplies, count };
  }

  async findOne(id: number, currentUserId?: number) {

    const mainCommentQuery = this.commentRepo.createQueryBuilder('comment')

      .leftJoinAndSelect('comment.author', 'author')

      .leftJoinAndSelect('comment.post', 'post')

      .leftJoinAndSelect('comment.parent', 'parent');

    if (currentUserId) {

      mainCommentQuery.leftJoinAndMapOne(

        'comment.userReaction',

        'comment.reactions',

        'userReaction',

        'userReaction.userId = :currentUserId',

      );

      mainCommentQuery.setParameter('currentUserId', currentUserId);

    }

    mainCommentQuery.where('comment.id = :id', { id });

    const comment = await mainCommentQuery.getOne();

    if (comment) {

      const repliesQuery = this.commentRepo

        .createQueryBuilder('reply')

        .leftJoinAndSelect('reply.author', 'author')

        .where('reply.parentId = :commentId', { commentId: comment.id })

        .orderBy('reply.createdAt', 'ASC')

        .take(2); // Limit to 2 replies

      if (currentUserId) {

        repliesQuery.leftJoinAndMapOne(

          'reply.userReaction',

          'reply.reactions',

          'userReaction',

          'userReaction.userId = :currentUserId',

        );

        repliesQuery.setParameter('currentUserId', currentUserId);

      }

      comment.replies = await repliesQuery.getMany();

    }

    return comment;

  }

  async createComment(
    postId: number,
    content: string,
    userId: number,
    parentId?: number,
  ) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // Get the post directly
      const post = await queryRunner.manager.findOne(Post, { where: { id: postId } });
      if (!post) {
        throw new NotFoundException('Post not found');
      }

      if (post.commentsLocked) {
        throw new BadRequestException('Comments are locked for this post.');
      }

      
      const comment = queryRunner.manager.create(Comment, {
        content,
        authorId: userId,
        post: post,
      });

      if (parentId) {
        const parent = await queryRunner.manager.findOne(Comment, {
          where: { id: parentId },
          relations: ['post'],
        });
        if (!parent)
          throw new NotFoundException('Parent comment not found');
        if (parent.post.id !== postId) {
          throw new BadRequestException(
            'Parent comment does not belong to this post',
          );
        }
        comment.parent = parent;
        await queryRunner.manager.increment(Comment, { id: parentId }, 'repliesCount', 1); // Increment repliesCount directly
      }

      const savedComment = await queryRunner.manager.save(comment);

      // Increment commentsCount on the post directly
      await queryRunner.manager.increment(Post, { id: postId }, 'commentsCount', 1);

      await queryRunner.commitTransaction();
      return savedComment;
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }

  async update(
    updateCommentData: {
      id: number;
      content?: string;
    },
  ): Promise<Comment> {
    const comment = await this.commentRepo.findOneBy({
      id: updateCommentData.id,
    });
    if (!comment) {
      throw new NotFoundException('Comment not found');
    }

    if (updateCommentData.content !== undefined)
      comment.content = updateCommentData.content;

    return this.commentRepo.save(comment);
  }

  async remove(id: number): Promise<boolean> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const comment = await queryRunner.manager.findOne(Comment, {
        where: { id },
        relations: ['post', 'parent'], // Load post and parent relation to update counts
      });
      if (!comment) {
        throw new NotFoundException('Comment not found');
      }

      // Decrement commentsCount on the post directly
      if (comment.post) {
        await queryRunner.manager.decrement(Post, { id: comment.post.id }, 'commentsCount', 1);
      }

      // Decrement repliesCount on the parent comment directly
      if (comment.parent) {
        await queryRunner.manager.decrement(Comment, { id: comment.parent.id }, 'repliesCount', 1);
      }

      await queryRunner.manager.remove(comment);
      await queryRunner.commitTransaction();
      return true;
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }



}

---


### FILE: backend/src/comments/comments.controller.ts ###
import {
  Controller,
  Get,
  Post as HttpPost,
  Patch,
  Delete,
  Param,
  Body,
  UseGuards,
  Query,
  NotFoundException,
  ParseIntPipe, // Added
} from '@nestjs/common';
import { CommentsService } from './comments.service';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UpdateCommentDto } from './dto/update-comment.dto';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { OptionalJwtAuthGuard } from 'src/auth/guards/optional-jwt-auth.guard'; // Added
import { Action } from 'src/casl/casl.types';
import { Comment } from './entities/comment.entity';
// Removed CommentPipe
import { Post as PostEntity } from 'src/posts/entities/post.entity';
import { PostPipe } from 'src/posts/pipes/post.pipe';
import { CaslService } from 'src/casl/casl.service';
import { CommentResponseDto } from './dto/comment-response.dto';
import { CommentQueryDto } from './dto/comment-query.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { ResponseDto } from 'src/common/dto/response.dto';
import { CommentPipe } from './pipes/comment.pipe';

@Controller()
export class CommentsController {
  constructor(
    private readonly commentsService: CommentsService,
    private readonly caslService: CaslService,
  ) { }

  @Get('comments')
  @UseGuards(OptionalJwtAuthGuard) // Add guard to get user
  async findAll(@Query() query: CommentQueryDto, @GetUser() user: User): Promise<PaginatedResponseDto<CommentResponseDto>> {
    const { data, count } = await this.commentsService.findAll(
    { page: query.page,
      limit :query.limit,
      search :query.search,
      authorId :query.authorId,
      parentId:query.parentId ,
      postId :query.postId, // Ensure postId is passed to service
      currentUserId: user?.id, // Pass currentUserId
    }
    );

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(CommentResponseDto.fromEntity), paginationMeta);
  }

  @HttpPost('posts/:postId/comments')
  @UseGuards(JwtAuthGuard)
  async createForPost(
    @Param('postId', PostPipe) post: PostEntity,
    @Body() dto: CreateCommentDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommentResponseDto>> {
    this.caslService.enforce(user, Action.Create, Comment);
    const comment = await this.commentsService.createComment(
      post.id,
      dto.content,
      user.id,
      dto.parentId,
    );
    return new ResponseDto(CommentResponseDto.fromEntity(comment));
  }

  @Get('comments/:id')
  @UseGuards(OptionalJwtAuthGuard) // Add guard to get user
  async findOne(
    @Param('id') id: number, // Get id directly
    @GetUser() user: User, // Get current user
  ): Promise<ResponseDto<CommentResponseDto>> {
    const comment = await this.commentsService.findOne(id, user?.id); // Call service method
    if (!comment) {
      throw new NotFoundException('Comment not found');
    }
    return new ResponseDto(CommentResponseDto.fromEntity(comment));
  }

  @Patch('comments/:id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', CommentPipe) comment: Comment,
    @Body() dto: UpdateCommentDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommentResponseDto>> {
    this.caslService.enforce(user, Action.Update, comment);
    const updatedComment = await this.commentsService.update(
      {
        id: comment.id,
        content: dto.content,
      }
    );
    return new ResponseDto(CommentResponseDto.fromEntity(updatedComment));
  }

  @Delete('comments/:id')
  @UseGuards(JwtAuthGuard)
  async remove(
    @Param('id', CommentPipe) comment: Comment,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, comment);
    const success = await this.commentsService.remove(comment.id);
    return new ResponseDto(success);
  }
}


---


### FILE: backend/src/comments/entities/comment.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  OneToMany,
  Check,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { ReactionType } from 'src/reactions/reactions.types';
import { CommentReport } from '../../reports/entities/comment-report.entity';

@Entity('comments')
@Check(`id <> parentId`) export class Comment {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  content: string;

  @ManyToOne(() => Post, (post) => post.comments, { onDelete: 'CASCADE' })
  post: Post;
 // FK explicite
  @Column()
  postId: number;
  
  @ManyToOne(() => User, (user) => user.comments, {
    nullable: false,
    onDelete: 'CASCADE',
  })
  author: User;
  // FK explicite
  @Column()
  authorId: number;

  @ManyToOne(() => Comment, (comment) => comment.replies, {
    nullable: true,
    onDelete: 'CASCADE',
  })
  parent: Comment;

 @Column({nullable :true})
  parentId: number;

  @OneToMany(() => Comment, (comment) => comment.parent)
  replies: Comment[];

  @OneToMany(() => CommentReaction, (reaction) => reaction.comment)
  reactions: CommentReaction[];

  @Column({ default: 0 })
  likesCount: number;

  @Column({ default: 0 })
  dislikesCount: number;

  @Column({ default: 0 })
  repliesCount: number;

  @OneToMany(() => CommentReport, (commentReport) => commentReport.comment)
  reports: CommentReport[];

  userReaction?: { id: number; type: ReactionType };

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @DeleteDateColumn()
  deletedAt: Date;
}

---


### FILE: backend/src/comments/comments.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Comment } from './entities/comment.entity';
import { CommentsService } from './comments.service';
import { CommentsController } from './comments.controller';
import { PostsModule } from 'src/posts/posts.module';
import { CaslModule } from 'src/casl/casl.module';
import { CommunitiesModule } from 'src/communities/communities.module';
import { Post } from 'src/posts/entities/post.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([Comment, Post]),
    PostsModule,
    CaslModule,
    CommunitiesModule,
  ],
  providers: [CommentsService],
  controllers: [CommentsController],
  exports: [CommentsService],
})
export class CommentsModule {}

---


### FILE: backend/src/comments/dto/comment-response.dto.ts ###
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { Comment } from '../entities/comment.entity';
import { CommentReaction } from 'src/reactions/entities/comment-reaction.entity';
import { ReactionResponseDto } from 'src/reactions/dto/reaction-response.dto';
import { PostResponseDto } from 'src/posts/dto/post-response.dto';

@Exclude()
export class CommentResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly content: string;
  @Expose() readonly createdAt: Date;
  @Expose() readonly updatedAt: Date;

  @Expose() @Type(() => UserResponseDto) readonly author: UserResponseDto;
  @Expose() readonly postId: number;
  @Expose()
@Type(() => PostResponseDto)
readonly post?: PostResponseDto;

  @Expose() readonly parentId?: number;
  @Expose() readonly likesCount: number;
  @Expose() readonly dislikesCount: number;
  @Expose() readonly repliesCount: number;
  @Expose() @Type(() => ReactionResponseDto)
  readonly userReaction?: ReactionResponseDto | null;
  @Expose()
  @Type(() => CommentResponseDto)
  readonly replies?: CommentResponseDto[];

  static fromEntity(entity: Comment & { userReaction?: any }): CommentResponseDto {
    return plainToInstance(
      CommentResponseDto,
      {
        ...entity,
        author: entity.author
          ? UserResponseDto.fromEntity(entity.author)
          : null,
        replies:
          entity.replies?.map((r) => CommentResponseDto.fromEntity(r)) ?? [],
        userReaction: entity.userReaction
          ? ReactionResponseDto.fromEntity(entity.userReaction)
          : null,
           post: entity.post
        ? PostResponseDto.fromEntity(entity.post)
        : null,
      },
      { excludeExtraneousValues: true },
    );
  }
}

---


### FILE: backend/src/comments/dto/comment-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsString, IsInt } from 'class-validator';
import { Type } from 'class-transformer';

export class CommentQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  search?: string; // Filter by content

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  authorId?: number;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  postId?: number; // NEW FIELD: Filter by Post ID

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  parentId?: number;
  }

---


### FILE: backend/src/comments/dto/create-comment.dto.ts ###
import { IsNotEmpty, IsInt, IsOptional } from 'class-validator';

export class CreateCommentDto {
  @IsNotEmpty()
  content: string;

  // Add the optional parent ID
  @IsOptional()
  @IsInt()
  parentId?: number;
}

---


### FILE: backend/src/comments/dto/update-comment.dto.ts ###
import { PartialType } from '@nestjs/mapped-types';
import { CreateCommentDto } from './create-comment.dto';

export class UpdateCommentDto extends PartialType(CreateCommentDto) {}

---


--- FRONTEND SOURCE ---


### FILE: frontend/src/pages/Home.tsx ###
import { useAppSelector } from '../shared/stores/hooks';

const Home = () => {
  const { user } = useAppSelector((state) => state.auth);
  return (
    <div>
      <h1>Welcome to the forum, {user?.name}!</h1>
    </div>
  );
};

export default Home;
---


### FILE: frontend/src/pages/EmailChangeVerifyPage.tsx ###
import React, { useEffect, useState } from 'react';
import { useLocation } from 'react-router-dom';
import {  useVerifyEmailChangeMutation } from '../features/settings/services/emailChangeApiSlice';

const EmailChangeVerifyPage = () => {
  const query = new URLSearchParams(useLocation().search);
  const token = query.get('token');
  const [skip, setSkip] = useState(true);

  // Trigger the query only when the token is available
  useEffect(() => {
    if (token) {
      setSkip(false);
    }
  }, [token]);

  const { data, isLoading, isSuccess, isError, error } =
    useVerifyEmailChangeMutation({ token: token || '' }, { skip });

  let content;
  if (isLoading) {
    content = <div>Verifying your email change...</div>;
  } else if (isSuccess) {
    content = (
      <div className="text-green-600">
        Email address updated successfully! You can now log in with your new email.
      </div>
    );
    // Optionally, you might want to log out the user or refresh their session
    // if the email change affects their current session token.
    // For now, we'll just display the message.
  } else if (isError) {
    content = (
      <div className="text-red-600">
        Error verifying email change: {(error as any)?.data?.message || 'Invalid or expired token.'}
      </div>
    );
  } else {
    content = <div className="text-red-600">No verification token found.</div>;
  }

  return (
    <div className="container mx-auto py-8 text-center">
      <h1 className="text-2xl font-bold mb-4">Email Change Verification</h1>
      {content}
    </div>
  );
};

export default EmailChangeVerifyPage;

---


### FILE: frontend/src/layout/Header.tsx ###
import { Link } from 'react-router-dom';
import { useState } from 'react';
import { useAuth } from '../features/auth/hooks/useAuth';
import { useProfile } from '../features/profile/hooks/useProfile';
import LogoutButton from '../features/auth/components/LogoutButton';
import { FaHome, FaSignInAlt, FaUserPlus, FaSignOutAlt, FaBell, FaPlus, FaCaretDown, FaUserCircle } from 'react-icons/fa'; // Import icons

const Header = () => {
  const { isAuthenticated, user } = useAuth();
  const profile = useProfile();
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);

  const toggleDropdown = () => {
    setIsDropdownOpen(!isDropdownOpen);
  };

  return (
    <header className=" p-4 border-b border-gray-300">
      <nav className="container mx-auto flex justify-between items-center">
        <Link to="/" className="text-2xl font-bold flex items-center space-x-2">
          <FaHome className="inline-block" /> <span>Forum</span>
        </Link>
        <div className="flex items-center space-x-4">
          {isAuthenticated ? (
            <>
              {/* Create Post Button */}
              <Link to="/submit" className="flex items-center space-x-1 hover:text-gray-300">
                <FaPlus /> <span>Create Post</span>
              </Link>

              {/* Notification Bell */}
              <button className="relative hover:text-gray-300">
                <FaBell className="text-xl" />
                {/* Optional: Notification Badge */}
                {/* <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-4 w-4 flex items-center justify-center">3</span> */}
              </button>

              {/* User Profile Dropdown */}
              <div className="relative">
                <button onClick={toggleDropdown} className="flex items-center space-x-2 hover:text-gray-300 focus:outline-none">
                  {profile?.picture ? (
                    <img
                      src={profile.picture}
                      alt="Profile"
                      className="w-8 h-8 rounded-full object-cover"
                    />
                  ) : (
                    <FaUserCircle className="text-3xl" />
                  )}
                  <FaCaretDown />
                </button>
                {isDropdownOpen && (
                  <div className="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-700 rounded-md shadow-lg py-1 text-gray-800 dark:text-gray-200 z-10">
                    <Link
                      to={user ? `/profile/${user.id}` : ''}
                      className="block px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-600"
                    >
                      Profile (@{profile?.displayName})
                    </Link>
                    <Link to="/settings" className="block px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-600">
                      Settings
                    </Link>
                    <div className="border-t border-gray-200 dark:border-gray-600 my-1"></div>
                    <LogoutButton className="block w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-gray-100 dark:hover:bg-gray-600" />
                  </div>
                )}
              </div>
            </>
          ) : (
            <>
              <li>
                <Link to="/login" className="flex items-center space-x-1 hover:text-gray-300">
                  <FaSignInAlt /> <span>Login</span>
                </Link>
              </li>
              <li>
                <Link to="/register" className="flex items-center space-x-1 hover:text-gray-300">
                  <FaUserPlus /> <span>Register</span>
                </Link>
              </li>
            </>
          )}
        </div>
      </nav>
    </header>
  );
};

export default Header;

---


### FILE: frontend/src/layout/ModSidebar.tsx ###
// frontend/src/features/communities/components/ModSidebar.tsx
import { NavLink, useParams } from 'react-router-dom';
import { FaShieldAlt, FaUsers, FaTasks, FaUserShield, FaUserSlash } from 'react-icons/fa';

export const ModSidebar = () => {
  const { communityId } = useParams<{ communityId: string }>();
  const basePath = `/mod/community/${communityId}`;

  const navItems = [
    { label: 'Queues', path: `${basePath}/queues`, icon: <FaTasks /> },
    { label: 'Members', path: `${basePath}/members`, icon: <FaUsers /> },
    { label: 'Moderators', path: `${basePath}/moderators`, icon: <FaUserShield /> },
    { label: 'Restricted Users', path: `${basePath}/restricted-users`, icon: <FaUserSlash /> },
  ];

  return (
    <aside className="w-64 bg-gray-50 h-screen border-r border-gray-200 p-4">
      <div className="flex items-center gap-2 mb-6 px-2 text-gray-700 font-bold">
        <FaShieldAlt className="text-orange-600" />
        <span>Mod Tools</span>
      </div>
      <nav className="space-y-1">
        {navItems.map((item) => (
          <NavLink
            key={item.path}
            to={item.path}
            className={({ isActive }) =>
              `flex items-center gap-3 px-3 py-2 rounded-md transition-colors ${
                isActive ? 'bg-orange-100 text-orange-700' : 'hover:bg-gray-100 text-gray-600'
              }`
            }
          >
            {item.icon}
            {item.label}
          </NavLink>
        ))}
      </nav>
    </aside>
  );
};
---


### FILE: frontend/src/layout/LeftSidebar.tsx ###
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { FaHome, FaCompass, FaUsers, FaPlusSquare, FaRocket } from 'react-icons/fa'; // Example icons
import {Modal} from '../shared/components/ui/Modal'; // Assuming this path
import CreateCommunityForm from '../features/communities/components/CreateCommunityForm';

const LeftSidebar: React.FC = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleOpenModal = (event: React.MouseEvent) => {
    event.preventDefault(); // Prevent navigation
    setIsModalOpen(true);
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
  };

  return (
    <aside className="w-64 bg-white p-4 border-r border-gray-300 h-screen sticky top-0 hidden md:block">
      <nav className="space-y-4">
        <div>
          <h2 className="text-lg font-semibold text-gray-800 mb-2">Navigation</h2>
          <ul className="space-y-1">
            <li>
              <Link to="/" className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaHome /> <span>Home</span>
              </Link>
            </li>
            <li>
              <Link to="/discover" className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaCompass /> <span>Discover</span>
              </Link>
            </li>
            <li>
              <Link to="/explore-communities" className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaUsers /> <span>Explore Communities</span>
              </Link>
            </li>
            <li>
              <Link to="/my-communities" className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaUsers /> <span>My Communities</span>
              </Link>
            </li>
          </ul>
        </div>
        <div>
          <h2 className="text-lg font-semibold text-gray-800 mb-2">Actions</h2>
          <ul className="space-y-1">
            <li>
              <Link to="/submit" className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaPlusSquare /> <span>Create Post</span>
              </Link>
            </li>
            <li>
              <a href="#" onClick={handleOpenModal} className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaRocket /> <span>Start Community</span>
              </a>
            </li>
          </ul>
        </div>
      </nav>

      <Modal open={isModalOpen} size='lg' onClose={handleCloseModal} >
        <CreateCommunityForm onClose={handleCloseModal} />
      </Modal>
    </aside>
  
);
};

export default LeftSidebar;

---


### FILE: frontend/src/layout/ModLayout.tsx ###
// frontend/src/features/communities/layouts/ModLayout.tsx
import { Outlet } from 'react-router-dom';
import { ModSidebar } from './ModSidebar';
import Header from './Header';

const ModLayout = () => (
  <>
    <Header />
    <div className="flex min-h-screen bg-white">
      <ModSidebar />
      <main className="flex-1 p-8">
        <Outlet />
      </main>
    </div>
  </>
);
export default ModLayout;
---


### FILE: frontend/src/layout/MainLayout.tsx ###
// frontend/src/layout/MainLayout.tsx
import { Outlet } from 'react-router-dom';
import Header from './Header';
import LeftSidebar from './LeftSidebar';

const MainLayout = () => (
  <>
    <Header />
    <div className="flex">
      <LeftSidebar />
      <main className="flex-grow p-4">
        <Outlet /> 
      </main>
    </div>
  </>
);
export default MainLayout;
---


### FILE: frontend/src/features/community-memberships/types.ts ###
export interface CommunityMembership {
    userId: number;
    communityId: number;
    role: CommunityRole; // Add this
    user: User; // Add the user object
    rank: number; // Add rank
    // community: CommunityResponseDto; // Assuming CommunityResponseDto exists
    createdAt: string;
  }

  export interface User {
    id: number;
    username: string;
    email: string;
    // Add other user properties if needed from UserResponseDto
  }
  
  export interface CommunityMembershipQueryDto {
    userId?: number;
    communityId?: number;
    page?: number;
    limit?: number;
  }export type CommunityRole =  'moderator' | 'member';
---


### FILE: frontend/src/features/community-memberships/pages/MembersPage.tsx ###
import { useCommunityMemberships } from '../hooks/useCommunityMemberships';

export const MembersPage = () => {
  const { memberships, isLoading } = useCommunityMemberships();

  if (isLoading) return <div className="p-4 text-center">Loading members...</div>;

  return (
    <div className="max-w-4xl mx-auto">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-2xl font-bold text-gray-800">Community Members</h2>
        <span className="bg-gray-100 px-3 py-1 rounded-full text-sm text-gray-600 font-medium font-bold">
          Total: {memberships.length || 0}
        </span>
      </div>
      <div className="bg-white border border-gray-200 rounded-xl overflow-hidden shadow-sm">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">User</th>
              <th className="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Role</th>
              <th className="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Joined At</th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {memberships.map((membership) => (
              <tr key={membership.userId}>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">User #{membership.userId}</td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                    membership.role === 'admin' ? 'bg-red-100 text-red-800' :
                    membership.role === 'moderator' ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'
                  }`}>
                    {membership.role}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 font-mono">
                  {new Date(membership.createdAt).toLocaleDateString()}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};
---


### FILE: frontend/src/features/community-memberships/pages/ModeratorsPage.tsx ###
import { FaUserShield } from 'react-icons/fa';
import { Button } from '../../../shared/components/ui/Button';
import { useModerators } from '../hooks/useModerators';

export const ModeratorsPage = () => {
  const {
    moderators,
    isLoading,
    isRemovingMember,
    canRemoveModerator,
    handleRemoveModerator,
  } = useModerators();

  if (isLoading) return <div className="p-4">Loading moderation team...</div>;

  return (
    <div className="max-w-4xl mx-auto">
      <h2 className="text-2xl font-bold mb-6 flex items-center gap-2 text-gray-800 border-b pb-2">
        <FaUserShield className="text-orange-600" />
        Moderation Team
      </h2>
      <div className="overflow-x-auto bg-white rounded-lg shadow-sm border border-gray-200">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th
                scope="col"
                className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                Moderator
              </th>
              <th
                scope="col"
                className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                Role
              </th>
              <th
                scope="col"
                className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                Actions
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {moderators.map((mod) => {
              const canRemove = canRemoveModerator(mod);

              return (
                <tr key={mod.user.id}>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center">
                      <div className="flex-shrink-0 h-10 w-10">
                        {/* Avatar Placeholder */}
                        <div className="h-10 w-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-500 font-bold">
                          {mod.user.username.charAt(0).toUpperCase()}
                        </div>
                      </div>
                      <div className="ml-4">
                        <div className="text-sm font-medium text-gray-900">
                          {mod.user.username}
                        </div>
                        <div className="text-sm text-gray-500">
                          {mod.user.email}
                        </div>
                      </div>
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <span
                      className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-orange-100 text-orange-800`}
                    >
                      {mod.role}
                    </span>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => handleRemoveModerator(mod.userId)}
                      disabled={isRemovingMember || !canRemove}
                      className="ml-2"
                    >
                      Remove
                    </Button>
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
};
---


### FILE: frontend/src/features/community-memberships/services/communityMembershipsApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { CommunityMembership, CommunityMembershipQueryDto } from '../types';
import type { PaginatedResponse, ResponseDto } from '../../../shared/types';

export const communityMembershipsApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    getCommunityMemberships: builder.query<
      PaginatedResponse<CommunityMembership>,
      CommunityMembershipQueryDto
    >({
      query: (params) => ({
        url: '/community-memberships',
        params,
      }),
      providesTags: ['CommunityMemberships'],
    }),

    deleteMembership: builder.mutation<
      ResponseDto<boolean>,
      number // communityId
    >({
      query: (communityId) => ({
        url: `/users/me/communities/${communityId}/memberships`,
        method: 'DELETE',
      }),
      invalidatesTags: ['CommunityMemberships', 'Communities'],
    }),

    removeCommunityMember: builder.mutation<
      ResponseDto<boolean>,
      { communityId: number; targetUserId: number }
    >({
      query: ({ communityId, targetUserId }) => ({
        url: `/communities/${communityId}/members/${targetUserId}`,
        method: 'DELETE',
      }),
      invalidatesTags: ['CommunityMemberships', 'Communities'],
    }),
  }),
});

export const {
  useGetCommunityMembershipsQuery,
  useDeleteMembershipMutation,
  useRemoveCommunityMemberMutation,
} = communityMembershipsApi;

---


### FILE: frontend/src/features/community-memberships/hooks/useModerators.ts ###
import { useParams } from 'react-router-dom';
import {
  useGetCommunityMembershipsQuery,
  useRemoveCommunityMemberMutation,
} from '../services/communityMembershipsApi';
import { useAuth } from '../../auth/hooks/useAuth';
import type { User, CommunityMembership } from '../types';

export const useModerators = () => {
  const { communityId } = useParams();
  const { user: currentUser } = useAuth();
  const parsedCommunityId = Number(communityId);

  const { data: allMembershipsResponse, isLoading: isLoadingMemberships } =
    useGetCommunityMembershipsQuery({
      communityId: parsedCommunityId,
      limit: 100,
    });

  const moderators =
    allMembershipsResponse?.data.filter((m) => m.role === 'moderator') ?? [];

  const currentUserMembership = allMembershipsResponse?.data.find(
    (member) => member.userId === currentUser?.id
  );

  const canRemoveModerator = (
    targetMod: CommunityMembership
  ): boolean => {
    if (!currentUser || !currentUserMembership) return false;

    const isSelf = currentUserMembership.userId === targetMod.userId;
    const hasLowerRank = currentUserMembership.rank < targetMod.rank;

    return isSelf || hasLowerRank;
  };

  const [removeCommunityMember, { isLoading: isRemovingMember }] =
    useRemoveCommunityMemberMutation();

  const handleRemoveModerator = async (targetUserId: number) => {
    if (!communityId) return;
    try {
      await removeCommunityMember({
        communityId: parsedCommunityId,
        targetUserId,
      }).unwrap();
    } catch (err) {
      console.error('Failed to remove member:', err);
    }
  };

  return {
    moderators,
    isLoading: isLoadingMemberships,
    isRemovingMember,
    canRemoveModerator,
    handleRemoveModerator,
  };
};

---


### FILE: frontend/src/features/community-memberships/hooks/useCommunityMemberships.ts ###
import { useParams } from 'react-router-dom';
import { useGetCommunityMembershipsQuery } from '../services/communityMembershipsApi';

export const useCommunityMemberships = () => {
  const { communityId } = useParams();
  const { data: response, isLoading } = useGetCommunityMembershipsQuery({
    communityId: Number(communityId),
  });

  return {
    memberships: response?.data ?? [],
    isLoading,
    communityId,
  };
};

---


### FILE: frontend/src/features/feed/pages/FeedPage.tsx ###
import PostList from '../../posts/components/PostList';
import FeedFilters from '../components/FeedFilters';
import SuggestedCommunities from '../../communities/components/SuggestedCommunities';
import { useFeed } from '../hooks/useFeed';

const FeedPage = () => {
  const {
    queryParams,
    setQueryParams,
    posts,
    isLoading,
    isFetching,
    hasNextPage,
    error,
    lastPostElementRef,
  } = useFeed();

  return (
    <div className="container mx-auto p-4 flex flex-col md:flex-row gap-6">
      {/* Main Content Area */}
      <div className="md:w-3/4">
        <h1 className="text-3xl font-bold mb-6">Feed</h1>

        <FeedFilters
          queryParams={queryParams}
          setQueryParams={setQueryParams}
          isLoading={isLoading}
        />

        <PostList posts={posts} isLoading={isLoading} error={undefined} />

        {/* Loading indicator */}
        {isFetching && (
          <div className="text-center mt-4">
            <div className="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
            <p className="mt-2 text-gray-600">Loading more posts...</p>
          </div>
        )}

        {/* End of feed */}
        {!hasNextPage && posts.length > 0 && (
          <div className="text-center mt-8 p-4 border-t">
            <p className="text-gray-600">üéâ You've reached the end!</p>
            <p className="text-sm text-gray-500 mt-1">No more posts to load</p>
          </div>
        )}

        {/* Empty state */}
        {!isLoading && posts.length === 0 && (
          <div className="text-center p-8">
            <div className="text-4xl mb-4">üì≠</div>
            <h3 className="text-xl font-semibold mb-2">No posts yet</h3>
            <p className="text-gray-600">Be the first to create a post!</p>
          </div>
        )}

        {/* Invisible element for intersection observer */}
        {hasNextPage && <div ref={lastPostElementRef} className="h-1" />}
      </div>

      {/* Sidebar */}
      <div className="md:w-1/4">
        <SuggestedCommunities />
      </div>
    </div>
  );
};

export default FeedPage;

---


### FILE: frontend/src/features/feed/components/FeedFilters.tsx ###
import React from 'react';
import { Button } from '../../../shared/components/ui/Button';
import { Input } from '../../../shared/components/ui/Input';
import type { PostQueryDto } from '../../posts/types';
import { FaSearch, FaSortAmountDownAlt, FaFire, FaCalendarAlt } from 'react-icons/fa';

interface FeedFiltersProps {
  queryParams: PostQueryDto;
  setQueryParams: React.Dispatch<React.SetStateAction<PostQueryDto>>;
  isLoading: boolean;
}


const FeedFilters: React.FC<FeedFiltersProps> = ({ queryParams, setQueryParams, isLoading }) => {
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setQueryParams((prev) => ({ ...prev, search: e.target.value, page: 1 }));
  };
console.log(queryParams);

  const handleSortChange = (sortOption: string) => {
    setQueryParams((prev) => ({ ...prev, sort: sortOption, page: 1 }));
  };

  return (
    <div className="flex flex-col sm:flex-row justify-between items-center bg-white p-4 rounded-lg border border-gray-300 mb-6">
      <div className="relative flex-grow mb-3 sm:mb-0 sm:mr-4">
        <FaSearch className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" />
        <Input
          placeholder="Search posts..."
          className="pl-10 w-full"
          onChange={handleSearchChange}
          value={queryParams.search || ''}
        />
      </div>
      <div className="flex space-x-2">
        <Button
          variant={queryParams.sort === 'newest' ? 'default' : 'outline'}
          onClick={() => handleSortChange('newest')}
          disabled={isLoading}
          className="flex items-center space-x-1"
        >
          <FaSortAmountDownAlt /> <span>Newest</span>
        </Button>
        <Button
          variant={queryParams.sort === 'popular' ? 'default' : 'outline'}
          onClick={() => handleSortChange('popular')}
          disabled={isLoading}
          className="flex items-center space-x-1"
        >
          <FaFire /> <span>Popular</span>
        </Button>
        <Button
          variant={queryParams.sort === 'published_at' ? 'default' : 'outline'}
          onClick={() => handleSortChange('published_at')}
          disabled={isLoading}
          className="flex items-center space-x-1"
        >
          <FaCalendarAlt /> <span>Published</span>
        </Button>
      </div>
    </div>
  );
};

export default FeedFilters;

---


### FILE: frontend/src/features/feed/hooks/useFeed.ts ###
import { useEffect, useRef, useCallback, useState } from 'react';
import { useGetPostsInfiniteQuery } from '../../posts/services/postsApi';
import { useToastContext } from '../../../shared/providers/ToastProvider';
import type { PostQueryDto } from '../../posts/types';

export const useFeed = () => {
  const [queryParams, setQueryParams] = useState<Omit<PostQueryDto, 'page'>>({
    limit: 10,
  });

  const {
    data,
    error,
    isLoading,
    isFetching,
    fetchNextPage,
    hasNextPage,
  } = useGetPostsInfiniteQuery(queryParams);

  const posts = data?.pages.flatMap((page) => page.data) ?? [];

  const { showToast } = useToastContext();
  const observer = useRef<IntersectionObserver | null>(null);

  useEffect(() => {
    if (error) {
      showToast('Failed to load posts', 'error');
    }
  }, [error, showToast]);

  const lastPostElementRef = useCallback(
    (node: HTMLDivElement) => {
      if (isLoading || isFetching || !hasNextPage) return;

      if (observer.current) observer.current.disconnect();

      observer.current = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting && hasNextPage) {
          fetchNextPage();
        }
      });

      if (node) observer.current.observe(node);
    },
    [isLoading, isFetching, hasNextPage, fetchNextPage]
  );

  return {
    queryParams,
    setQueryParams,
    posts,
    isLoading,
    isFetching,
    hasNextPage,
    error,
    lastPostElementRef,
  };
};

---


### FILE: frontend/src/features/community-membership-requests/types.ts ###
// Replace enum with const object
export const CommunityMembershipRequestSort = {
  NEWEST: 'newest',
  OLDEST: 'oldest',
} as const;

export type CommunityMembershipRequestSort = (typeof CommunityMembershipRequestSort)[keyof typeof CommunityMembershipRequestSort];

export const CommunityMembershipRequestStatus = {
  PENDING: 'pending',
  ACCEPTED: 'accepted',
  REJECTED: 'rejected',
} as const;

export type CommunityMembershipRequestStatus = (typeof CommunityMembershipRequestStatus)[keyof typeof CommunityMembershipRequestStatus];

// Define a basic User interface for the frontend
export interface User {
  id: number;
  name: string;
  email: string;
  // Add other user properties if needed from UserResponseDto
}

export interface CommunityMembershipRequest {
    id: number;
    userId: number;
    communityId: number;
    user: User; // Add the user object
    status: 'pending' | 'accepted' | 'rejected';
    createdAt: string;
    updatedAt: string;
  }
  
export interface CommunityMembershipRequestQueryDto {
  page?: number;
  limit?: number;
  userId?: number;
  communityId?: number;
  status?: CommunityMembershipRequestStatus; // ‚úÖ include it
  sort?: CommunityMembershipRequestSort;
}


---


### FILE: frontend/src/features/community-membership-requests/services/communityMembershipRequestsApi.ts ###
import { apiSlice } from "../../../shared/services/apiSlice";
import type { ResponseDto } from "../../auth/types";
import type { CommunityMembershipQueryDto } from "../../community-memberships/types";
import type { CommunityMembershipRequest, CommunityMembershipRequestQueryDto } from "../types";

export const communityMembershipRequestsApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    // Create a join request (or auto-join if public)
    createMembershipRequest: builder.mutation<
      ResponseDto<CommunityMembershipRequest>,
      number // communityId
    >({
      query: (communityId) => ({
        url: `/communities/${communityId}/membership-requests`,
        method: 'POST',
      }),
      invalidatesTags: ['CommunityMembershipRequests', 'Communities', 'CommunityMemberships'],
    }),

    // Accept a pending request (admin/mod action, keep requestId for now)
    acceptMembershipRequest: builder.mutation<
      ResponseDto<CommunityMembershipRequest>,
  { communityId: number; userId: number } // pass both IDs
      >({
      query: ({communityId,userId}) => ({
        url: `/communities/${communityId}/membership-requests/${userId}/accept`,
        method: 'POST',
      }),
      invalidatesTags: ['CommunityMembershipRequests', 'Communities', 'CommunityMemberships'],
    }),

    // Cancel (reject) your own pending request ‚Äî user-centric, no requestId
    cancelMembershipRequest: builder.mutation<
      ResponseDto<boolean>,
      number // communityId
    >({
      query: (communityId) => ({
        url: `/communities/${communityId}/membership-requests/own`,
        method: 'DELETE',
      }),
      invalidatesTags: ['CommunityMembershipRequests', 'Communities', 'CommunityMemberships'],
    }),

    // 2Ô∏è‚É£ Reject any pending membership request (admin/mod)
    rejectMembershipRequest: builder.mutation<
      ResponseDto<boolean>,
      { communityId: number; userId: number } // target user
    >({
      query: ({ communityId, userId }) => ({
        url: `/communities/${communityId}/membership-requests`,
        method: 'DELETE',
        body: { userId }, // pass target userId in body
      }),
      invalidatesTags: ['CommunityMembershipRequests', 'Communities', 'CommunityMemberships'],
    }),

 // communityMembershipRequestsApi.ts (or wherever your api slice lives)
getCommunityMembershipRequests: builder.query<
  ResponseDto<CommunityMembershipRequest[]>,
  CommunityMembershipRequestQueryDto
>({
  query: (params) => ({
    url: `/communities/${params.communityId}/membership-requests`,
    params, // <-- pass the whole object as query params (page, limit, status, sort, etc.)
  }),
  providesTags: ['CommunityMembershipRequests'],
}),

  }),
});

export const {
  useCreateMembershipRequestMutation,
  useAcceptMembershipRequestMutation,
  useRejectMembershipRequestMutation,
  useCancelMembershipRequestMutation ,
  useGetCommunityMembershipRequestsQuery,
} = communityMembershipRequestsApi;

---


### FILE: frontend/src/features/reactions/components/ReactionButton.tsx ###
import React from 'react';
import { Button } from '../../../shared/components/ui/Button';
import { FaRegThumbsDown, FaRegThumbsUp, FaThumbsDown, FaThumbsUp } from 'react-icons/fa';

interface ReactionButtonProps {

    onClick: () => void;
    count?: number; // optional count
    disabled?: boolean;
    type: 'like' | 'dislike';
    userReaction?: 'like' | 'dislike' | null;
}

export const ReactionButton: React.FC<ReactionButtonProps> = ({
    onClick,
    count = 0,
    disabled = false,
    type,
    userReaction,
}) => {
  const isActive = userReaction === type;
    const ariaLabel = userReaction === 'like' ? 'Remove like' : 'Like'

    return (
        <Button
            onClick={onClick}
            disabled={disabled}
            size='sm'
            variant='secondary'

            aria-label={ariaLabel ?? type}
        >
                 {type === 'like' ? (
        isActive ? <FaThumbsUp /> : <FaRegThumbsUp />
      ) : isActive ? (
        <FaThumbsDown />
      ) : (
        <FaRegThumbsDown />
      )}
            
            {count > 0 && <span className="text-sm ms-2 font-medium">{count}</span>}
        </Button>
    );
};

---


### FILE: frontend/src/features/reactions/components/CommentReactionButtons.tsx ###
import { ReactionButtons } from './ReactionButtons';
import type { Comment } from '../../comments/types';
import { useCommentReactionButtons } from '../hooks/useCommentReactionButtons';

interface CommentReactionButtonsProps {
    comment: Comment;
}

export const CommentReactionButtons: React.FC<CommentReactionButtonsProps> = ({ comment }) => {
    const { handleLike, handleDislike, likesCount, dislikesCount, userReactionType } = useCommentReactionButtons({ comment });

    return (
        <ReactionButtons
            likesCount={likesCount}
            dislikesCount={dislikesCount}
            userReaction={userReactionType}
            onLike={handleLike}
            onDislike={handleDislike}
            disabled={false}
        />
    );
};

---


### FILE: frontend/src/features/reactions/components/ReactionButtons.tsx ###
import React from 'react';
import { FaThumbsUp, FaThumbsDown } from 'react-icons/fa';
import { ReactionButton } from './ReactionButton';
import type { ReactionType } from '../types/types';

interface ReactionButtonsProps {
    likesCount: number;
    dislikesCount: number;
    userReaction: ReactionType | null | undefined;
    onLike: () => void;
    onDislike: () => void;
    disabled?: boolean;
    className?: string;
}

export const ReactionButtons: React.FC<ReactionButtonsProps> = ({
    likesCount,
    dislikesCount,
    userReaction,
    onLike,
    onDislike,
    disabled = false,
    className = '',
}) => (
    <div className={`flex items-center space-x-3 ${className}`}>
        <ReactionButton
            count={likesCount}
            onClick={onLike}
            disabled={disabled}
            type="like"
            userReaction={userReaction}
        />

        <ReactionButton
            count={dislikesCount}
            onClick={onDislike}
            disabled={disabled}
            type="dislike"
            userReaction={userReaction}
        />
    </div>
);

---


### FILE: frontend/src/features/reactions/components/PostReactionButtons.tsx ###
import { ReactionButtons } from './ReactionButtons';
import type { Post } from '../../posts/types';
import { usePostReactionButtons } from '../hooks/usePostReactionButtons';

interface PostReactionButtonsProps {
    post: Post;
}

export const PostReactionButtons: React.FC<PostReactionButtonsProps> = ({ post }) => {
    const { handleLike, handleDislike, likesCount, dislikesCount, userReactionType } = usePostReactionButtons({ post });

    return (
        <ReactionButtons
            likesCount={likesCount}
            dislikesCount={dislikesCount}
            userReaction={userReactionType}
            onLike={handleLike}
            onDislike={handleDislike}
            disabled={false}
        />
    );
};

---


### FILE: frontend/src/features/reactions/services/reactionApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type {
  PostReaction,
  CommentReaction,
  CreateReactionDto,
  UpdateReactionDto,
  ReactionQueryDto,
  PaginatedResponse,
  ResponseDto
} from '../types/types';

export const reactionApi = apiSlice.injectEndpoints({
  overrideExisting: false, // Ensure this is not overriding existing endpoints
  endpoints: (builder) => ({
    getPostReactions: builder.query<PaginatedResponse<PostReaction>, { postId: number } & ReactionQueryDto>({
      query: ({ postId, ...params }) => ({ url: `/posts/${postId}/reactions`, params }),
      providesTags: (_result, _error, { postId }) => [{ type: 'PostReaction', id: postId }],
    }),

    getCommentReactions: builder.query<PaginatedResponse<CommentReaction>, { commentId: number } & ReactionQueryDto>({
      query: ({ commentId, ...params }) => ({ url: `/comments/${commentId}/reactions`, params }),
      providesTags: (_result, _error, { commentId }) => [{ type: 'CommentReaction', id: commentId }],
    }),

    createPostReaction: builder.mutation<ResponseDto<PostReaction>, { postId: number; data: CreateReactionDto }>({
      query: ({ postId, data }) => ({ url: `/posts/${postId}/reactions`, method: 'POST', body: data }),
      invalidatesTags: ['Posts']
    }),

    updatePostReaction: builder.mutation<ResponseDto<PostReaction>, { postId: number; reactionId: number; data: UpdateReactionDto }>({
      query: ({ postId, reactionId, data }) => ({ url: `/posts/${postId}/reactions/${reactionId}`, method: 'PATCH', body: data }),
            invalidatesTags: ['Posts']

    }),

    deletePostReaction: builder.mutation<ResponseDto<boolean>, { postId: number; reactionId: number }>({
      query: ({ postId, reactionId }) => ({ url: `/posts/${postId}/reactions/${reactionId}`, method: 'DELETE' }),
          invalidatesTags: ['Posts']

    }),

    createCommentReaction: builder.mutation<ResponseDto<CommentReaction>, { commentId: number; data: CreateReactionDto }>({
      query: ({ commentId, data }) => ({ url: `/comments/${commentId}/reactions`, method: 'POST', body: data }),
      invalidatesTags: ['Comments'],
    }),

    updateCommentReaction: builder.mutation<ResponseDto<CommentReaction>, { commentId: number; reactionId: number; data: UpdateReactionDto }>({
      query: ({ commentId, reactionId, data }) => ({ url: `/comments/${commentId}/reactions/${reactionId}`, method: 'PATCH', body: data }),
      invalidatesTags: ['Comments'],
    }),

    deleteCommentReaction: builder.mutation<ResponseDto<boolean>, { commentId: number; reactionId: number }>({
      query: ({ commentId, reactionId }) => ({ url: `/comments/${commentId}/reactions/${reactionId}`, method: 'DELETE' }),
      invalidatesTags: ['Comments'],
    }),
  }),
});

export const {
  useGetPostReactionsQuery,
  useGetCommentReactionsQuery,
  useCreatePostReactionMutation,
  useUpdatePostReactionMutation,
  useCreateCommentReactionMutation,
  useUpdateCommentReactionMutation,
  useDeletePostReactionMutation,
  useDeleteCommentReactionMutation,
} = reactionApi;

---


### FILE: frontend/src/features/reactions/types/types.ts ###
export const ReactionType = {
  LIKE: 'like',
  DISLIKE: 'dislike',
} as const;

export type ReactionType = typeof ReactionType[keyof typeof ReactionType];

export interface Reaction {
    id: number;
    type: ReactionType;
    userId: number;
    createdAt: string;
    updatedAt: string;
}

export interface PostReaction extends Reaction {
    postId: number;
    user: {
        id: number;
        name: string;
    };
}

export interface CommentReaction extends Reaction {
    commentId: number;
    user: {
        id: number;
        name: string;
    };
}

export interface CreateReactionDto {
    type: ReactionType;
}

export interface UpdateReactionDto {
    type: ReactionType;
}


export interface ReactionQueryDto {
    page?: number;
    limit?: number;
    type?: ReactionType;
    userId?: number;
}

export interface PaginatedResponse<T> {
    data: T[];
    meta: {
        page: number;
        limit: number;
        totalItems: number;
        totalPages: number;
        itemCount: number;
    };
}

export interface ResponseDto<T> {
    data: T;
    message: string;
}

---


### FILE: frontend/src/features/reactions/hooks/useCommentReactionButtons.ts ###
import {
  useCreateCommentReactionMutation,
  useDeleteCommentReactionMutation,
  useUpdateCommentReactionMutation,
} from '../services/reactionApi';
import type { Comment } from '../../comments/types';
import { ReactionType } from '../types/types';

interface UseCommentReactionButtonsProps {
  comment: Comment;
}

export const useCommentReactionButtons = ({
  comment,
}: UseCommentReactionButtonsProps) => {
  const [createReaction] = useCreateCommentReactionMutation();
  const [deleteReaction] = useDeleteCommentReactionMutation();
  const [updateReaction] = useUpdateCommentReactionMutation();

  const handleLike = async () => {
    if (comment.userReaction?.type === ReactionType.LIKE) {
      await deleteReaction({
        commentId: comment.id,
        reactionId: comment.userReaction.id!,
      });
    } else if (comment.userReaction?.type === ReactionType.DISLIKE) {
      await updateReaction({
        commentId: comment.id,
        reactionId: comment.userReaction.id!,
        data: { type: ReactionType.LIKE },
      });
    } else {
      await createReaction({ commentId: comment.id, data: { type: ReactionType.LIKE } });
    }
  };

  const handleDislike = async () => {
    if (comment.userReaction?.type === ReactionType.DISLIKE) {
      await deleteReaction({
        commentId: comment.id,
        reactionId: comment.userReaction.id!,
      });
    } else if (comment.userReaction?.type === ReactionType.LIKE) {
      await updateReaction({
        commentId: comment.id,
        reactionId: comment.userReaction.id!,
        data: { type: ReactionType.DISLIKE },
      });
    } else {
      await createReaction({ commentId: comment.id, data: { type: ReactionType.DISLIKE } });
    }
  };

  return {
    handleLike,
    handleDislike,
    likesCount: comment.likesCount,
    dislikesCount: comment.dislikesCount,
    userReactionType: comment.userReaction?.type,
  };
};

---


### FILE: frontend/src/features/reactions/hooks/usePostReactionButtons.ts ###
import {
  useCreatePostReactionMutation,
  useDeletePostReactionMutation,
  useUpdatePostReactionMutation,
} from '../services/reactionApi';
import type { Post } from '../../posts/types';
import { ReactionType } from '../types/types';

interface UsePostReactionButtonsProps {
  post: Post;
}

export const usePostReactionButtons = ({ post }: UsePostReactionButtonsProps) => {
  const [createReaction] = useCreatePostReactionMutation();
  const [deleteReaction] = useDeletePostReactionMutation();
  const [updateReaction] = useUpdatePostReactionMutation();

  const handleLike = async () => {
    if (post.userReaction?.type === ReactionType.LIKE) {
      await deleteReaction({ postId: post.id, reactionId: post.userReaction.id! });
    } else if (post.userReaction?.type === ReactionType.DISLIKE) {
      await updateReaction({
        postId: post.id,
        reactionId: post.userReaction.id!,
        data: { type: ReactionType.LIKE },
      });
    } else {
      await createReaction({ postId: post.id, data: { type: ReactionType.LIKE } });
    }
  };

  const handleDislike = async () => {
    if (post.userReaction?.type === ReactionType.DISLIKE) {
      await deleteReaction({ postId: post.id, reactionId: post.userReaction.id! });
    } else if (post.userReaction?.type === ReactionType.LIKE) {
      await updateReaction({
        postId: post.id,
        reactionId: post.userReaction.id!,
        data: { type: ReactionType.DISLIKE },
      });
    } else {
      await createReaction({ postId: post.id, data: { type: ReactionType.DISLIKE } });
    }
  };

  return {
    handleLike,
    handleDislike,
    likesCount: post.likesCount,
    dislikesCount: post.dislikesCount,
    userReactionType: post.userReaction?.type,
  };
};

---


### FILE: frontend/src/features/reports/types.ts ###

export interface Report {
  id: number;
  reason: string;
  createdAt: string;
  userId: number;
  postId?: number;
  commentId?: number;
}

export interface ReportQueryDto {
  communityId: number;
  page: number;
  limit: number;
}

---


### FILE: frontend/src/features/reports/components/ReportsQueue.tsx ###
import { Button } from "../../../shared/components/ui/Button";
import { useReportsQueue } from "../hooks/useReportsQueue";

export const ReportsQueue = () => {
  const { reports, isLoading, handleDismiss } = useReportsQueue();

  if (isLoading) return <div className="p-4">Loading reports...</div>;

  return (
    <div className="space-y-3">
      {reports.length === 0 ? (
        <div className="text-center py-10 bg-gray-50 rounded-lg border">
          <p className="text-gray-500 italic">No pending reports to review.</p>
        </div>
      ) : (
        reports.map((report) => (
          <div
            key={report.id}
            className="flex justify-between items-center p-4 bg-white rounded-lg border border-gray-200"
          >
            <div>
              <p className="font-medium text-gray-900 text-lg">
                Report #{report.id}
              </p>
              <p className="text-sm text-gray-700">{report.reason}</p>
              <p className="text-xs text-gray-500 italic">
                Reported by User #{report.userId} on{' '}
                {new Date(report.createdAt).toLocaleDateString()}
              </p>
              {report.postId && (
                <p className="text-xs text-gray-500">Post ID: {report.postId}</p>
              )}
              {report.commentId && (
                <p className="text-xs text-gray-500">
                  Comment ID: {report.commentId}
                </p>
              )}
            </div>
            <div className="flex gap-2">
              <Button
                size="sm"
                onClick={() => handleDismiss(report.id)}
                className="bg-blue-600 hover:bg-blue-700"
              >
                Dismiss
              </Button>
            </div>
          </div>
        ))
      )}
    </div>
  );
};

---


### FILE: frontend/src/features/reports/services/reportsApi.ts ###
import { apiSlice } from "../../../shared/services/apiSlice";
import type { ResponseDto } from "../../auth/types";
import type { Report, ReportQueryDto } from "../types";

export const reportsApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    getReports: builder.query<
      ResponseDto<Report[]>,
      ReportQueryDto
    >({
      query: (params) => ({
        url: `/communities/${params.communityId}/reports`,
        params,
      }),
      providesTags: ["Reports"],
    }),
    dismissReport: builder.mutation<
      ResponseDto<boolean>,
      { communityId: number; reportId: number }
    >({
      query: ({ communityId, reportId }) => ({
        url: `/communities/${communityId}/reports/${reportId}/dismiss`,
        method: "POST",
      }),
      invalidatesTags: ["Reports"],
    }),
  }),
});

export const {
  useGetReportsQuery,
  useDismissReportMutation,
} = reportsApi;

---


### FILE: frontend/src/features/reports/hooks/useReportsQueue.ts ###
import { useParams } from 'react-router-dom';
import { useGetReportsQuery, useDismissReportMutation } from '../services/reportsApi';

export const useReportsQueue = () => {
  const { communityId } = useParams();
  const { data: reports, isLoading } = useGetReportsQuery({
    communityId: +communityId,
    page: 1,
    limit: 10,
  });
  const [dismissReport] = useDismissReportMutation();

  const handleDismiss = (reportId: number) => {
    if (communityId) {
      dismissReport({ communityId: +communityId, reportId });
    }
  };

  return {
    reports: reports?.data ?? [],
    isLoading,
    handleDismiss,
  };
};

---


### FILE: frontend/src/features/settings/pages/SettingsPage.tsx ###
import React from 'react';
import Tabs from '../components/Tabs';
import ProfileSettings from '../components/ProfileSettings';
import AccountSettings from '../components/AccountSettings';

const SettingsPage = () => {
  const tabs = [
    {
      label: 'Account',
      content: <AccountSettings />,
    },
    {
      label: 'Profile',
      content: <ProfileSettings />,
    },
  ];

  return (
    <div className="container mx-auto py-8">
      <h1 className="text-2xl font-bold mb-8">User Settings</h1>
      <Tabs tabs={tabs} />
    </div>
  );
};

export default SettingsPage;

---


### FILE: frontend/src/features/settings/components/AccountSettings.tsx ###
import React, { useState } from 'react';
import { useAuth } from '../../auth/hooks/useAuth';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useRequestEmailChangeMutation } from '../services/emailChangeApiSlice';
import { Modal } from '../../../shared/components/ui/Modal';
import { Input } from '../../../shared/components/ui/Input';

const emailChangeSchema = z.object({
  newEmail: z.string().email('Invalid email address'),
  currentPassword: z.string().min(1, 'Current password is required'),
});

type EmailChangeFormInputs = z.infer<typeof emailChangeSchema>;

const AccountSettings = () => {
  const { user } = useAuth();
  const [showEmailChangeForm, setShowEmailChangeForm] = useState(false);
  const [requestEmailChange, { isLoading, isSuccess, isError, error }] =
    useRequestEmailChangeMutation();

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<EmailChangeFormInputs>({
    resolver: zodResolver(emailChangeSchema),
  });

  if (!user) {
    return <div>Loading user...</div>;
  }

  return (
    <div>
      <div className="py-4 sm:py-5 sm:grid sm:grid-cols-3 sm:gap-4">
        <dt className="text-sm font-medium text-gray-500">Email</dt>
        <dd className="mt-1 flex text-sm text-gray-900 sm:mt-0 sm:col-span-2">
          <span className="flex-grow">{user.email}</span>
          <button
            onClick={() => setShowEmailChangeForm(true)}
            className="ml-4 bg-white py-2 px-3 border border-gray-300 rounded-md shadow-sm text-sm leading-4 font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Edit
          </button>
        </dd>
      </div>

      <div className="py-4 sm:py-5 sm:grid sm:grid-cols-3 sm:gap-4">
        <dt className="text-sm font-medium text-gray-500">Username</dt>
        <dd className="mt-1 flex text-sm text-gray-900 sm:mt-0 sm:col-span-2">
          <span className="flex-grow">{user.username}</span>
          <button className="ml-4 bg-white py-2 px-3 border border-gray-300 rounded-md shadow-sm text-sm leading-4 font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
            Edit
          </button>
        </dd>
      </div>

      <Modal open={showEmailChangeForm} onClose={() => setShowEmailChangeForm(false)} >
        <form
          onSubmit={handleSubmit(async (data) => {
            try {
              console.log(data);
              
              await requestEmailChange(data).unwrap();
              reset();
              setShowEmailChangeForm(false);
            } catch (err) {
              console.error('Failed to request email change:', err);
            }
          })}
          className="mt-4"
        >
          <div className="mb-4">
            <label htmlFor="newEmail" className="block text-sm font-medium text-gray-700">
              New Email Address
            </label>
            <Input
              type="email"
              id="newEmail"
              {...register('newEmail')}
              className="mt-1"
            />                      {errors.newEmail && (
              <p className="mt-2 text-sm text-red-600">
                {errors.newEmail.message}
              </p>
            )}
          </div>
          <div className="mb-4">
            <label htmlFor="currentPassword" className="block text-sm font-medium text-gray-700">
              Current Password
            </label>
            <Input
              type="password"
              id="currentPassword"
              {...register('currentPassword')}
              className="mt-1"
            />                      {errors.currentPassword && (
              <p className="mt-2 text-sm text-red-600">
                {errors.currentPassword.message}
              </p>
            )}
          </div>

          <div className="flex justify-end space-x-2">
            <button
              type="submit"
              disabled={isLoading}
              className="inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
            >
              {isLoading ? 'Sending...' : 'Request Change'}
            </button>
            <button
              type="button"
              onClick={() => {
                setShowEmailChangeForm(false);
                reset();
              }}
              className="inline-flex justify-center rounded-md border border-gray-300 bg-white py-2 px-4 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
            >
              Cancel
            </button>
          </div>
          {isSuccess && (
            <p className="mt-2 text-sm text-green-600">
              Verification email sent! Please check your new inbox.
            </p>
          )}
          {isError && (
            <p className="mt-2 text-sm text-red-600">
              Error: {(error as any)?.data?.message || 'Failed to send email change request.'}
            </p>
          )}
        </form>
      </Modal>
    </div>);
};

export default AccountSettings;

---


### FILE: frontend/src/features/settings/components/forms/EditBioForm.tsx ###
import React, { useState } from 'react';
import  { Button } from '../../../../shared/components/ui/Button';
import { useUpdateMyProfileMutation } from '../../../profile/services/profileApi';
import { Textarea } from '../../../../shared/components/ui/TextArea';

interface EditBioFormProps {
  currentBio: string | null;
  onClose: () => void;
}

const EditBioForm: React.FC<EditBioFormProps> = ({ currentBio, onClose }) => {
  const [bio, setBio] = useState(currentBio || '');
  const [updateProfile, { isLoading }] = useUpdateMyProfileMutation();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateProfile({ bio }).unwrap();
      onClose();
    } catch (err) {
      console.error('Failed to update bio:', err);
      // TODO: Display error message to the user
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="bio" className="block text-sm font-medium text-gray-700">
          Bio
        </label>
        <Textarea
          id="bio"
          value={bio}
          onChange={(e) => setBio(e.target.value)}
          className="mt-1 block w-full"
          rows={4}
        />
      </div>
      <div className="flex justify-end space-x-2">
        <Button type="button" variant="outline" onClick={onClose}>
          Cancel
        </Button>
        <Button type="submit" isLoading={isLoading}>
          Save
        </Button>
      </div>
    </form>
  );
};

export default EditBioForm;

---


### FILE: frontend/src/features/settings/components/forms/EditPictureForm.tsx ###
import React, { useState } from 'react';
import  { Button } from '../../../../shared/components/ui/Button';
import { useUpdateMyProfileMutation } from '../../../profile/services/profileApi';

interface EditPictureFormProps {
  currentPicture: string | null;
  onClose: () => void;
}

const EditPictureForm: React.FC<EditPictureFormProps> = ({ currentPicture, onClose }) => {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [preview, setPreview] = useState<string | null>(currentPicture);
  const [updateProfile, { isLoading }] = useUpdateMyProfileMutation();

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      setSelectedFile(file);
      setPreview(URL.createObjectURL(file));
    } else {
      setSelectedFile(null);
      setPreview(currentPicture);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedFile) {
      console.warn('No file selected.');
      return;
    }

    try {
      await updateProfile({ pictureFile: selectedFile }).unwrap();
      onClose();
    } catch (err) {
      console.error('Failed to update profile picture:', err);
      // TODO: Display error message to the user
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="picture" className="block text-sm font-medium text-gray-700">
          Profile Picture
        </label>
        <div className="mt-1 flex items-center space-x-4">
          {preview && (
            <img src={preview} alt="Profile Preview" className="w-20 h-20 rounded-full object-cover" />
          )}
          <input
            type="file"
            id="picture"
            accept="image/*"
            onChange={handleFileChange}
            className="block w-full text-sm text-gray-500
                       file:mr-4 file:py-2 file:px-4
                       file:rounded-full file:border-0
                       file:text-sm file:font-semibold
                       file:bg-indigo-50 file:text-indigo-700
                       hover:file:bg-indigo-100"
          />
        </div>
      </div>
      <div className="flex justify-end space-x-2">
        <Button type="button" variant="outline" onClick={onClose}>
          Cancel
        </Button>
        <Button type="submit" isLoading={isLoading} disabled={!selectedFile}>
          Save
        </Button>
      </div>
    </form>
  );
};

export default EditPictureForm;

---


### FILE: frontend/src/features/settings/components/forms/EditDisplayNameForm.tsx ###
import React, { useState } from 'react';
import  { Button } from '../../../../shared/components/ui/Button';
import { Input } from '../../../../shared/components/ui/Input';
import { useUpdateMyProfileMutation } from '../../../profile/services/profileApi';

interface EditDisplayNameFormProps {
  currentDisplayName: string;
  onClose: () => void;
}

const EditDisplayNameForm: React.FC<EditDisplayNameFormProps> = ({
  currentDisplayName,
  onClose,
}) => {
  const [displayName, setDisplayName] = useState(currentDisplayName);
  const [updateProfile, { isLoading }] = useUpdateMyProfileMutation();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateProfile({ displayName }).unwrap();
      onClose();
    } catch (err) {
      console.error('Failed to update display name:', err);
      // TODO: Display error message to the user
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="displayName" className="block text-sm font-medium text-gray-700">
          Display Name
        </label>
        <Input
          type="text"
          id="displayName"
          value={displayName}
          onChange={(e) => setDisplayName(e.target.value)}
          className="mt-1 block w-full"
          required
        />
      </div>
      <div className="flex justify-end space-x-2">
        <Button type="button" variant="outline" onClick={onClose}>
          Cancel
        </Button>
        <Button type="submit" isLoading={isLoading}>
          Save
        </Button>
      </div>
    </form>
  );
};

export default EditDisplayNameForm;

---


### FILE: frontend/src/features/settings/components/ProfileSettings.tsx ###
import React, { useState } from 'react';
import { useProfile } from '../../profile/hooks/useProfile';
import { Modal } from '../../../shared/components/ui/Modal';
import EditDisplayNameForm from './forms/EditDisplayNameForm';
import EditBioForm from './forms/EditBioForm';
import EditPictureForm from './forms/EditPictureForm';

const ProfileSettings = () => {
  const profile = useProfile();
  const [isDisplayNameModalOpen, setIsDisplayNameModalOpen] = useState(false);
  const [isBioModalOpen, setIsBioModalOpen] = useState(false);
  const [isPictureModalOpen, setIsPictureModalOpen] = useState(false);


  if (!profile) {
    return <div>Loading profile...</div>;
  }

  return (
    <div>
      <div className="py-4 sm:py-5 sm:grid sm:grid-cols-3 sm:gap-4">
        <dt className="text-sm font-medium text-gray-500">Display Name</dt>
        <dd className="mt-1 flex text-sm text-gray-900 sm:mt-0 sm:col-span-2">
          <span className="flex-grow">{profile.displayName}</span>
          <button
            onClick={() => setIsDisplayNameModalOpen(true)}
            className="ml-4 bg-white py-2 px-3 border border-gray-300 rounded-md shadow-sm text-sm leading-4 font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Edit
          </button>
        </dd>
      </div>
      <div className="py-4 sm:py-5 sm:grid sm:grid-cols-3 sm:gap-4">
        <dt className="text-sm font-medium text-gray-500">Bio</dt>
        <dd className="mt-1 flex text-sm text-gray-900 sm:mt-0 sm:col-span-2">
          <span className="flex-grow">{profile.bio}</span>
          <button
            onClick={() => setIsBioModalOpen(true)}
            className="ml-4 bg-white py-2 px-3 border border-gray-300 rounded-md shadow-sm text-sm leading-4 font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Edit
          </button>
        </dd>
      </div>
      <div className="py-4 sm:py-5 sm:grid sm:grid-cols-3 sm:gap-4">
        <dt className="text-sm font-medium text-gray-500">Picture</dt>
        <dd className="mt-1 flex text-sm text-gray-900 sm:mt-0 sm:col-span-2">
          <span className="flex-grow">
            <img src={profile.picture} alt="Profile" className="w-10 h-10 rounded-full" />
          </span>
          <button
            onClick={() => setIsPictureModalOpen(true)}
            className="ml-4 bg-white py-2 px-3 border border-gray-300 rounded-md shadow-sm text-sm leading-4 font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Edit
          </button>
        </dd>
      </div>

      <Modal open={isDisplayNameModalOpen} onClose={() => setIsDisplayNameModalOpen(false)} title="Edit Display Name">
        <EditDisplayNameForm
          currentDisplayName={profile.displayName}
          onClose={() => setIsDisplayNameModalOpen(false)}
        />
      </Modal>

      <Modal open={isBioModalOpen} onClose={() => setIsBioModalOpen(false)} title="Edit Bio">
        <EditBioForm
          currentBio={profile.bio}
          onClose={() => setIsBioModalOpen(false)}
        />
      </Modal>

      <Modal open={isPictureModalOpen} onClose={() => setIsPictureModalOpen(false)} title="Edit Profile Picture">
        <EditPictureForm
          currentPicture={profile.picture}
          onClose={() => setIsPictureModalOpen(false)}
        />
      </Modal>


    </div>
  );
};

export default ProfileSettings;

---


### FILE: frontend/src/features/settings/components/Tabs.tsx ###
import React, { useState } from 'react';

interface Tab {
  label: string;
  content: React.ReactNode;
}

interface TabsProps {
  tabs: Tab[];
}

const Tabs: React.FC<TabsProps> = ({ tabs }) => {
  const [activeTab, setActiveTab] = useState(0);

  return (
    <div>
      <div className="border-b border-gray-200">
        <nav className="-mb-px flex space-x-8" aria-label="Tabs">
          {tabs.map((tab, index) => (
            <button
              key={tab.label}
              onClick={() => setActiveTab(index)}
              className={`${
                activeTab === index
                  ? 'border-indigo-500 text-indigo-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm`}
            >
              {tab.label}
            </button>
          ))}
        </nav>
      </div>
      <div className="mt-8">{tabs[activeTab].content}</div>
    </div>
  );
};

export default Tabs;

---


### FILE: frontend/src/features/settings/services/emailChangeApiSlice.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';

export const emailChangeApiSlice = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    requestEmailChange: builder.mutation<
      { message: string },
      { newEmail: string; currentPassword: string }
    >({
      query: (body) => ({
        url: '/email/change/request',
        method: 'POST',
        body,
      }),
    }),
    verifyEmailChange: builder.mutation<{ message: string }, { token: string }>({
      query: ({ token }) => ({
        url: `/email/change/verify?token=${token}`,
        method: 'GET',

      }),
      invalidatesTags: ['Me'],

    }),

  }),

});

export const { useRequestEmailChangeMutation, useVerifyEmailChangeMutation } =
  emailChangeApiSlice;

---


### FILE: frontend/src/features/posts/types.ts ###
import type { ReactionType } from "../reactions/types/types";

export const PostStatus = {
  PENDING: 'pending',
  APPROVED: 'approved',
  REJECTED: 'rejected',
} as const;
export type PostStatus = typeof PostStatus[keyof typeof PostStatus];
export interface Post {
  id: number;
  title: string;
  content: string;
  author: {
    username: string;
    id: number;
    name: string;
  };
  community?: {
    id: number;
    name: string;
  };
  views: number;
  likesCount: number;
  dislikesCount: number;
  commentsCount: number; // Added commentsCount
  userReaction?: { id: number; type: ReactionType };
  userSaved?: any;
  status: PostStatus;
  createdAt: string;
  updatedAt: string;
  publishedAt?: string;
}

export interface CreatePostDto {
  title: string;
  content: string;
  communityId?: number;
}

export interface UpdatePostDto {
  title?: string;
  content?: string;
}

export interface PostQueryDto {
  page?: number;
  limit?: number;
  search?: string;
  authorId?: number;
  sort?: string;
  startDate?: string;
  endDate?: string;
  communityId?: number;
  status?: PostStatus;
}


---


### FILE: frontend/src/features/posts/pages/CreatePostPage.tsx ###
import React from 'react';
import CreatePostForm from '../components/CreatePostForm';

const CreatePostPage: React.FC = () => {
  return (
    <div>
      <h1 className="text-2xl font-bold mb-4">Create Post</h1>
      <CreatePostForm />
    </div>
  );
};

export default CreatePostPage;

---


### FILE: frontend/src/features/posts/pages/PostDetailPage.tsx ###
import { useParams, Link } from 'react-router-dom';
import { useGetPostByIdQuery } from '../services/postsApi';
import { useToastContext } from '../../../shared/providers/ToastProvider';

import CommentList from '../../comments/components/CommentList'; // Import CommentList
import { CommentInput } from '../../comments/components/CommentInput'; // Import CommentInput
import { AboutCommunity } from '../../communities/components/AboutCommunity';
import { PostReactionButtons } from '../../reactions/components/PostReactionButtons';
import { PostSuggestionsList } from '../components/PostSuggestionsList';
import PostDetailCard from '../components/PostDetailCard'; // Import PostDetailCard
import { useGetCommentsInfiniteQuery } from '../../comments/services/commentsApi'; // NEW IMPORT
import { useEffect } from 'react';

const PostDetailPage = () => {
  const { id } = useParams<{ id: string }>();
  const postId = Number(id);
  const { data, error, isLoading } = useGetPostByIdQuery(postId);
  const { showToast } = useToastContext();

   // ‚úÖ HOOK ALWAYS RUNS
  useEffect(() => {
    if (!error) return;

    const errorMessage =
      (error as any).data?.message ||
      (error as any).message ||
      'Failed to load post';

    showToast(errorMessage, 'error');
  }, [error]);

  if (isLoading) {
    return <div className="text-center mt-8">Loading post...</div>;
  }

  if (!data?.data) {
    return <div className="text-center mt-8">Post not found.</div>;
  }

  const post = data.data;


  return (
    <div className="container mx-auto p-4 flex flex-col md:flex-row gap-6">
      {/* Main Content Area */}
      <div className="md:w-[70%]">
        <PostDetailCard post={post} />
        <div className="mb-6">
                <CommentInput postId={post.id} />
  
        </div>
        {/* Comments Section */}
        <CommentList
          postId={post.id}
        />
      </div>

      {/* Sidebar Area (Right) */}
      <div className="md:w-[30%]">
        <PostSuggestionsList currentPostId={postId} communityId={post.community?.id} />
        {post.community && (
          <div className="mt-4">
            <AboutCommunity communityId={post.community.id} />
          </div>
        )}
      </div>
    </div>
  );
};

export default PostDetailPage;

---


### FILE: frontend/src/features/posts/components/PostDetailCard.tsx ###
import React from 'react';
import type { Post } from '../types';
import { Link } from 'react-router-dom';
import { FaUser, FaUsers, FaEye } from 'react-icons/fa';
import { PostReactionButtons } from '../../reactions/components/PostReactionButtons';
import PostActionButtons from './PostCardFooter'; // Assuming it's in the same directory
import PostMetaData from './PostMetaData';
import PostCardFooter from './PostCardFooter';

interface PostDetailCardProps {
  post: Post;
}

const PostDetailCard: React.FC<PostDetailCardProps> = ({ post }) => {
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg   mb-20 ">
      {/* Post Metadata */}
     <PostMetaData post={post} />

      {/* Post Title */}
      <h1 className="text-2xl font-bold text-gray-900 dark:text-gray-100 leading-tight mb-4">
        {post.title}
      </h1>

      {/* Post Content */}
      <p className="text-gray-700 dark:text-gray-300 text-base mb-6  leading-[1.8] ">
        {post.content}
      </p>

      {/* Actions */}
       <PostCardFooter post={post}/>

    </div>
  );
};

export default PostDetailCard;

---


### FILE: frontend/src/features/posts/components/PostMetaData.tsx ###
import React from 'react';
import { Link } from 'react-router-dom';
import { FaUsers, FaUser } from 'react-icons/fa';

import type { Post } from '../types';
import { timeAgo } from '../../../shared/utils/date';

interface PostMetaProps {
  post: Post;
}

const PostMetaData: React.FC<PostMetaProps> = ({ post }) => {
  return (
    <div className="flex items-center text-xs md:text-sm text-gray-500 dark:text-gray-400 mb-2 space-x-1">
      {post.community && (
        <>
          <FaUsers className="mr-1" />
          <Link
            to={`/communities/${post.community.id}`}
            className="font-semibold hover:underline mr-1"
          >
            c/{post.community.name}
          </Link>
          <span className="mx-1">‚Ä¢</span>
        </>
      )}

      <FaUser className="mr-1" />
      <span>u/{post.author.username}</span>

      {post.publishedAt && (
        <>
          <span className="mx-1">‚Ä¢</span>
          <span className="text-xs">
            Published {timeAgo(post.publishedAt)}
          </span>
        </>
      )}
    </div>
  );
};

export default PostMetaData;

---


### FILE: frontend/src/features/posts/components/PostSuggestionCard.tsx ###
import React from 'react';
import { Link } from 'react-router-dom';
import type { Post } from '../types';

interface PostSuggestionCardProps {
  post: Post;
}

export const PostSuggestionCard: React.FC<PostSuggestionCardProps> = ({ post }) => {
  return (
    <div className="bg-gray-50 rounded-lg p-3 hover:bg-gray-100 transition-colors duration-200">
      <Link to={`/posts/${post.id}`} className="text-md font-semibold text-gray-800 hover:text-primary-600">
        {post.title}
      </Link>
      {post.community && (
        <p className="text-sm text-gray-500 mt-1">
          in <Link to={`/communities/${post.community.name}`} className="hover:underline">r/{post.community.name}</Link>
        </p>
      )}
      <p className="text-xs text-gray-400 mt-1">
        {post.views} views ‚Ä¢ {post.commentsCount} comments
      </p>
    </div>
  );
};

---


### FILE: frontend/src/features/posts/components/CreatePostForm.tsx ###
import React from 'react';

import SearchableSelect from '../../../shared/components/ui/SearchableSelect';
import { Textarea } from '../../../shared/components/ui/TextArea';
import { Input } from '../../../shared/components/ui/Input';
import { Label } from '../../../shared/components/ui/Label';
import { InputError } from '../../../shared/components/ui/InputError';
import { Button } from '../../../shared/components/ui/Button';
import { usePosts } from '../hooks/usePosts';

const CreatePostForm: React.FC = () => {
  const { form, communitySearch, create } = usePosts();
  const { register, handleSubmit, setValue, errors } = form;
  const { search, setSearch, communities, isFetching } = communitySearch;
  const { handleCreatePost, isLoading } = create;

  return (
    <form onSubmit={handleSubmit(handleCreatePost)} className="space-y-4">
      {/* Title */}
      <div>
        <Label className="block text-sm font-medium">Title</Label>
        <Input {...register('title')} />
        <InputError message={errors.title?.message} />
      </div>

      {/* Content */}
      <div>
        <Label className="block text-sm font-medium">Content</Label>
        <Textarea {...register('content')} rows={5} />
        <InputError message={errors.content?.message} />
      </div>

      {/* Community */}
      <div>
        <Label className="block text-sm font-medium">Community</Label>

        <SearchableSelect
          value={search}
          onSearch={setSearch}
          options={communities}
          loading={isFetching}
          getLabel={(c) => c.displayName}
          renderOption={(c) => <span>{c.displayName}</span>}
          onSelect={(c) => setValue('communityId', c.id)}
          placeholder="Search community..."
        />

        <InputError message={errors.communityId?.message} />
      </div>

      {/* Submit */}
      <Button type="submit" disabled={isLoading}>
        {isLoading ? 'Creating‚Ä¶' : 'Create Post'}
      </Button>
    </form>
  );
};

export default CreatePostForm;

---


### FILE: frontend/src/features/posts/components/PostList.tsx ###
import React from 'react';
import PostCard from './PostCard';
import type { Post } from '../types';

interface PostListProps {
  posts: Post[];
  isLoading: boolean;
  error: any; // Ideally, a more specific error type
}

const PostList: React.FC<PostListProps> = ({ posts, isLoading, error }) => {
  if (isLoading) {
    return <div className="text-center mt-8">Loading posts...</div>;
  }

  if (error) {
    // Error handling will be done in the parent FeedPage
    return <div className="text-center mt-8 text-red-500">Error loading posts.</div>;
  }

  return (
    <div className="p-0"> {/* Adjusted padding as FeedPage provides container padding */}
      {posts.length === 0 ? (
        <p className="text-center text-gray-600 mt-8">No posts found.</p>
      ) : (
        <div className="grid gap-6 grid-cols-1"> {/* Changed to single column */}
          {posts.map((post) => (
            <PostCard key={post.id} post={post} />
          ))}
        </div>
      )}
    </div>
  );
};

export default PostList;

---


### FILE: frontend/src/features/posts/components/PendingPostsQueue.tsx ###
import { useParams } from "react-router-dom";
import { useGetPostsInfiniteQuery, useUpdatePostStatusMutation } from "../services/postsApi";
import { Button } from "../../../shared/components/ui/Button";
import { PostStatus } from "../types";

export const PendingPostsQueue = () => {
  const { communityId } = useParams();
  const { data, isLoading } = useGetPostsInfiniteQuery({
    communityId: +communityId,
    status: PostStatus.PENDING,
  });
  const [updatePostStatus] = useUpdatePostStatusMutation();

  const approvePost = (postId: number) => {
    updatePostStatus({ id: postId, status: PostStatus.APPROVED });
  };

  const rejectPost = (postId: number) => {
    updatePostStatus({ id: postId, status: PostStatus.REJECTED });
  };


  if (isLoading) return <div className="p-4">Loading pending posts...</div>;

  const posts = data?.pages.flatMap(page => page.data) ?? [];

  return (
    <div className="space-y-3">
      {posts.length === 0 ? (
        <div className="text-center py-10 bg-gray-50 rounded-lg border">
          <p className="text-gray-500 italic">No pending posts to review.</p>
        </div>
      ) : (
        posts.map((post) => (
          <div key={post.id} className="flex justify-between items-center p-4 bg-white rounded-lg border border-gray-200">
            <div>
              <p className="font-medium text-gray-900 text-lg">{post.title}</p>
              <p className="text-sm text-gray-700">{post.content}</p>
              <p className="text-xs text-gray-500 italic">
                Posted by User #{post.author.name} on {new Date(post.createdAt).toLocaleDateString()}
              </p>
            </div>
            <div className="flex gap-2">
              <Button size="sm" onClick={() => approvePost(post.id)} className="bg-green-600 hover:bg-green-700">Approve</Button>
              <Button size="sm" variant="outline" onClick={() => rejectPost(post.id)} className="text-red-600 border-red-600 hover:bg-red-50">Reject</Button>
            </div>
          </div>
        ))
      )}
    </div>
  );
};

---


### FILE: frontend/src/features/posts/components/PostCardDropdown.tsx ###
import React from 'react';
import type { Post } from '../types';
import {
  FaEdit,
  FaTrashAlt,
  FaRegBookmark,
  FaBookmark,
} from 'react-icons/fa';
import { BsThreeDots } from 'react-icons/bs';
import Dropdown from '../../../shared/components/ui/Dropdown';
import { Button } from '../../../shared/components/ui/Button';
import { useAuth } from '../../auth/hooks/useAuth';
import { useDeletePostMutation } from '../services/postsApi';

interface PostDropdownProps {
  post: Post;
}

const PostDropdown: React.FC<PostDropdownProps> = ({ post }) => {
 
 const {user}=useAuth()
const [deletePost, { isLoading }] = useDeletePostMutation();

  const handleEditPost = () => {
    console.log('Edit post:', post.id);
    // TODO: Implement edit functionality
  };

  const  handleDeletePost = async () => {
    console.log('Delete post:', post.id);
    try {
    await deletePost(post.id).unwrap();
    console.log('Post deleted:', post.id);
  } catch (error) {
    console.error('Failed to delete post', error);
  }
  };

  const handleToggleSave = () => {
    console.log(post.userSaved ? 'Unsave post:' : 'Save post:', post.id);
    // TODO: Implement save/unsave functionality
  };

  return (
    <div className="absolute top-2 right-2">
      <Dropdown
        trigger={
          <Button variant="ghost" size="sm" className="p-2">
            <BsThreeDots className="text-lg text-gray-500 dark:text-gray-400" />
          </Button>
        }
        align="right"
      >
        <div className="py-1">
         {user?.id === post.author.id && (
  <>
    <button
      onClick={handleEditPost}
      className="flex items-center w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600"
    >
      <FaEdit className="mr-2" />
      Edit
    </button>

    <button
      onClick={handleDeletePost}
      className="flex items-center w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-gray-100 dark:hover:bg-gray-600"
    >
      <FaTrashAlt className="mr-2" />
      Delete
    </button>
  </>
)}

          <button
            onClick={handleToggleSave}
            className="flex items-center w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600"
          >
            {post.userSaved ? (
              <>
                <FaBookmark className="mr-2" /> Unsave
              </>
            ) : (
              <>
                <FaRegBookmark className="mr-2" /> Save
              </>
            )}
          </button>
        </div>
      </Dropdown>
    </div>
  );
};

export default PostDropdown;

---


### FILE: frontend/src/features/posts/components/RejectedPostsQueue.tsx ###
import { useParams } from "react-router-dom";
import { useGetPostsInfiniteQuery } from "../services/postsApi";
import { PostStatus } from "../types";

export const RejectedPostsQueue = () => {
  const { communityId } = useParams();
  const { data, isLoading } = useGetPostsInfiniteQuery({
    communityId: +communityId,
    status: PostStatus.REJECTED,
  });

  if (isLoading) return <div className="p-4">Loading rejected posts...</div>;

  const posts = data?.pages.flatMap(page => page.data) ?? [];

  return (
    <div className="space-y-3">
      {posts.length === 0 ? (
        <div className="text-center py-10 bg-gray-50 rounded-lg border">
          <p className="text-gray-500 italic">No rejected posts to review.</p>
        </div>
      ) : (
        posts.map((post) => (
          <div key={post.id} className="flex justify-between items-center p-4 bg-white rounded-lg border border-gray-200">
            <div>
              <p className="font-medium text-gray-900 text-lg">{post.title}</p>
              <p className="text-sm text-gray-700">{post.content}</p>
              <p className="text-xs text-gray-500 italic">
                Posted by User #{post.author.name} on {new Date(post.createdAt).toLocaleDateString()}
              </p>
            </div>
          </div>
        ))
      )}
    </div>
  );
};

---


### FILE: frontend/src/features/posts/components/PostCardFooter.tsx ###
import React from 'react';
import type { Post } from '../types';
import { Button } from '../../../shared/components/ui/Button';
import {
  FaRegCommentAlt,
  FaCommentAlt,
  FaRegBookmark,
  FaBookmark,
  FaEye,
} from 'react-icons/fa';
import { FiShare2 } from 'react-icons/fi';
import { PostReactionButtons } from '../../reactions/components/PostReactionButtons';

interface PostCardFooterProps {
  post: Post;
}

 const PostCardFooter: React.FC<PostCardFooterProps> = ({ post }) => {
  // Placeholder for actual action handlers
  const handleCommentClick = () => {
    console.log('Comment clicked for post:', post.id);
    // TODO: Implement navigation to post detail page comments or open comment modal
  };

  const handleShareClick = () => {
    console.log('Share clicked for post:', post.id);
    // TODO: Implement share functionality
  };



  return (
    <div className="flex items-center justify-between mt-3  dark:text-gray-400 text-sm md:text-base">

      <div className="flex items-center space-x-3 md:space-x-4">

        {/* Vote Buttons */}
        <PostReactionButtons post={post} />


        {/* Comment Button */}
        <Button variant="secondary" size="sm" className="space-x-2" onClick={handleCommentClick}>
          <FaRegCommentAlt />
          <span>{post.commentsCount || 0}</span>
        </Button>

        {/* Share Button */}
        <Button variant="secondary" size="sm" className="space-x-2" onClick={handleShareClick}>
          <FiShare2 />
          <span>Share</span>
        </Button>
       

      </div>
       {/* Views */}
        <div className="flex items-center space-x-1">
          <FaEye />
          <span>{post.views}</span>
        </div>
    </div>
  );
};

export default PostCardFooter;

---


### FILE: frontend/src/features/posts/components/PostSuggestionsList.tsx ###
import React from 'react';
import { useGetPostsInfiniteQuery } from '../services/postsApi';
import { PostSuggestionCard } from './PostSuggestionCard';

interface PostSuggestionsListProps {
  currentPostId: number;
  communityId?: number; // Optional: to suggest posts from the same community
}

export const PostSuggestionsList: React.FC<PostSuggestionsListProps> = ({ currentPostId, communityId }) => {
  const { data, error, isLoading } = useGetPostsInfiniteQuery({
    communityId: communityId,
    limit: 5, // Fetch 5 suggestions
  });

  // Flatten the pages array to get all posts
  const allPosts = data?.pages.flatMap((page) => page.data) || [];

  // Filter out the current post from suggestions
  const suggestions = allPosts.filter(post => post.id !== currentPostId);

  if (isLoading) {
    return <p>Loading suggestions...</p>;
  }

  if (error) {
    return <p>Error loading suggestions.</p>;
  }

  if (suggestions.length === 0) {
    return <p>No suggestions found.</p>;
  }

  return (
    <div className="bg-white p-4 rounded-lg border border-gray-300">
      <h2 className="text-xl font-bold mb-4">More Posts Like This</h2>
      <div className="flex flex-col gap-3">
        {suggestions.map((post) => (
          <PostSuggestionCard key={post.id} post={post} />
        ))}
      </div>
    </div>
  );
};


---


### FILE: frontend/src/features/posts/components/PostCard.tsx ###
import React from 'react';
import type { Post } from '../types';
import { Link } from 'react-router-dom';
import {
  FaEye,
  FaUser,
  FaUsers,
  FaRegCommentAlt,
} from 'react-icons/fa';
import { timeAgo } from '../../../shared/utils/date'; // Import timeAgo from shared utils
import PostDropdown from './PostCardDropdown'; // Import PostDropdown component
import PostCardFooter from './PostCardFooter';
import PostMetaData from './PostMetaData';

interface PostCardProps {
  post: Post;
}

const PostCard: React.FC<PostCardProps> = ({ post }) => {
 

  return (
    <div className="relative bg-white dark:bg-gray-800 rounded-lg s border border-gray-300 hover:shadow-lg transition-shadow duration-200 mb-6 p-5">
      {/* Three dots dropdown */}
      <PostDropdown post={post} />

      {/* Post Metadata */}
           <PostMetaData post={post} />


      {/* Post Title */}
      <Link to={`/posts/${post.id}`}>
        <h2 className="text-lg  font-bold text-gray-900 dark:text-gray-100 hover:text-primary-600 leading-tight mb-2 line-clamp-2">
          {post.title}
        </h2>
      </Link>

      {/* Post Content */}
      <p className="text-gray-700 dark:text-gray-300 text-sm  line-clamp-3 mb-4">
        {post.content}
      </p>

      {/* Actions */}
   <PostCardFooter post={post}/>
    </div>
  );
};

export default PostCard;

---


### FILE: frontend/src/features/posts/services/postsApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { Post, CreatePostDto, UpdatePostDto, PostQueryDto, PostStatus } from '../types';
import type { PaginatedResponse, ResponseDto } from '../../../shared/types';

export const postsApi = apiSlice.injectEndpoints({
    endpoints: (builder) => ({
        
      getPosts: builder.infiniteQuery<
  PaginatedResponse<Post>,
  PostQueryDto,
  number
>({
  infiniteQueryOptions: {
    initialPageParam: 1,
    getNextPageParam: (lastPage) => {
      const { page, totalPages } = lastPage.meta;
      return page < totalPages ? page + 1 : undefined;
    },
  },

  query: ({ queryArg, pageParam }) => ({
    url: '/posts',
    params: {
      ...(queryArg ?? {}),
      page: pageParam,
      limit: queryArg?.limit ?? 10,
    },
  }),

  keepUnusedDataFor: 60,
  providesTags: ['Posts'],
}),
        getPostById: builder.query<ResponseDto<Post>, number>({
            query: (id) => `/posts/${id}`,
            providesTags: (result, error, id) => [{ type: 'Posts', id }],
        }),
        createPost: builder.mutation<ResponseDto<Post>, CreatePostDto>({
            query: (newPost) => ({
                url: '/posts',
                method: 'POST',
                body: newPost,
            }),
            invalidatesTags: ['Posts'],
        }),
        updatePost: builder.mutation<ResponseDto<Post>, { id: number; data: UpdatePostDto }>({
            query: ({ id, data }) => ({
                url: `/posts/${id}`,
                method: 'PATCH',
                body: data,
            }),
          invalidatesTags: ['Posts'],
        }),
        updatePostStatus: builder.mutation<ResponseDto<Post>, { id: number; status: PostStatus }>({
          query: ({ id, status }) => ({
            url: `/posts/${id}/status`,
            method: 'PATCH',
            body: { status },
          }),
          invalidatesTags: ['Posts'],
      }),
        deletePost: builder.mutation<ResponseDto<boolean>, number>({
            query: (id) => ({
                url: `/posts/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: ['Posts'],
        }),
    }),
});

export const {
    
      useGetPostsInfiniteQuery,
    useGetPostByIdQuery,
    useCreatePostMutation,
    useUpdatePostMutation,
    useUpdatePostStatusMutation,
    useDeletePostMutation,
} = postsApi;

---


### FILE: frontend/src/features/posts/hooks/usePosts.ts ###
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useNavigate } from 'react-router-dom';

import { useGetCommunitiesQuery } from '../../communities/services/communitiesApi';
import { useCreatePostMutation } from '../services/postsApi';

/* -------------------------------------------------------------------------- */
/*                                   Schema                                   */
/* -------------------------------------------------------------------------- */

const createPostSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  content: z.string().min(1, 'Content is required'),
  communityId: z.number().min(1, 'Community is required'),
});

type CreatePostFormValues = z.infer<typeof createPostSchema>;

/* -------------------------------------------------------------------------- */
/*                                    Hook                                    */
/* -------------------------------------------------------------------------- */

export const usePosts = () => {
  const navigate = useNavigate();
  const [createPost, { isLoading }] = useCreatePostMutation();

  const {
    register,
    handleSubmit,
    setValue,
    formState: { errors },
  } = useForm<CreatePostFormValues>({
    resolver: zodResolver(createPostSchema),
  });

  /* --------------------------- Search State -------------------------------- */

  const [search, setSearch] = useState('');

  const { data, isFetching } = useGetCommunitiesQuery(
    { name: search },
    { skip: search.trim().length === 0 }
  );

  const communities = data?.data ?? [];

  /* ---------------------------- Submit ------------------------------------- */

  const handleCreatePost = async (values: CreatePostFormValues) => {
    try {
      await createPost(values).unwrap();
      navigate('/');
    } catch (err) {
      console.error('Create post failed', err);
    }
  };

  /* -------------------------------------------------------------------------- */

  return {
    form: {
      register,
      handleSubmit,
      setValue,
      errors,
    },
    communitySearch: {
      search,
      setSearch,
      communities,
      isFetching,
    },
    create: {
      handleCreatePost,
      isLoading,
    },
  };
};

---


### FILE: frontend/src/features/auth/types.ts ###
export interface RegisterDto {
    name: string;
    email: string;
    password: string;
  }
  
  export interface LoginDto {
    email: string;
    password: string;
  }

  export interface UserResponseDto {
    id: string;
    username: string;
    email: string;
  }

  export interface ResponseDto<T> {
    data: T;
    message: string;
  }
  
---


### FILE: frontend/src/features/auth/pages/Register.tsx ###
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useRegisterMutation } from '../services/authApi';
import type { RegisterDto } from '../types';
import { Button } from '../../../shared/components/ui/Button';
import { Input } from '../../../shared/components/ui/Input';
import { Label } from '../../../shared/components/ui/Label';
import { InputError } from '../../../shared/components/ui/InputError';
import { useNavigate } from 'react-router-dom';

const registerSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters long'),
});

const Register = () => {
  const [register, { isLoading, error }] = useRegisterMutation();
  const navigate = useNavigate();
  const {
    register: formRegister,
    handleSubmit,
    formState: { errors },
  } = useForm<RegisterDto>({
    resolver: zodResolver(registerSchema),
  });

  const onSubmit = async (data: RegisterDto) => {
    try {
      await register(data).unwrap();
      navigate('/email-verification', { state: { email: data.email } });
    } catch (err: any) {
      console.error('Failed to register: ', err);
    }
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-md">
        <h1 className="text-2xl font-bold text-center">Register</h1>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
          <div>
            <Label htmlFor="name">Name</Label>
            <Input id="name" {...formRegister('name')} />
            <InputError message={errors.name?.message} />
          </div>
          <div>
            <Label htmlFor="email">Email</Label>
            <Input id="email" {...formRegister('email')} />
            <InputError message={errors.email?.message} />
          </div>
          <div>
            <Label htmlFor="password">Password</Label>
            <Input id="password" type="password" {...formRegister('password')} />
            <InputError message={errors.password?.message} />
          </div>
          <Button type="submit" disabled={isLoading} className="w-full">
            {isLoading ? 'Registering...' : 'Register'}
          </Button>
          {error && (
            <InputError
              message={
                (error as any).data?.message || (error as any).message || 'Unknown error'
              }
            />
          )}
        </form>
      </div>
    </div>
  );
};

export default Register;

---


### FILE: frontend/src/features/auth/pages/Login.tsx ###
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import type { LoginDto } from '../types';
import GoogleLogin from '../components/GoogleLogin';
import { Button } from '../../../shared/components/ui/Button';
import { Input } from '../../../shared/components/ui/Input';
import { Label } from '../../../shared/components/ui/Label';
import { InputError } from '../../../shared/components/ui/InputError';
import { useAuth } from '../hooks/useAuth';

const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
});

const Login = () => {
  const { handleLogin, isLoggingIn, loginError } = useAuth();
  const {
    register: formRegister,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginDto>({
    resolver: zodResolver(loginSchema),
  });

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-lg border border-gray-300">
        <h1 className="text-2xl font-bold text-center">Login</h1>
        <form onSubmit={handleSubmit(handleLogin)} className="space-y-6">
          <div>
            <Label htmlFor="email">Email</Label>
            <Input id="email" {...formRegister('email')} />
            <InputError message={errors.email?.message} />
          </div>
          <div>
            <Label htmlFor="password">Password</Label>
            <Input id="password" type="password" {...formRegister('password')} />
            <InputError message={errors.password?.message} />
          </div>
          <Button type="submit" disabled={isLoggingIn} className="w-full">
            {isLoggingIn ? 'Logging in...' : 'Login'}
          </Button>
          {loginError && (
            <InputError
              message={
                (loginError as any).data?.message ||
                (loginError as any).message ||
                'Unknown error'
              }
            />
          )}
        </form>
        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300"></div>
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">Or</span>
          </div>
        </div>
        <GoogleLogin />
      </div>
    </div>
  );
};

export default Login;

---


### FILE: frontend/src/features/auth/pages/VerificationResult.tsx ###
import React, { useEffect } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { useToastContext } from '../../../shared/providers/ToastProvider';

const VerificationResult = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { showToast } = useToastContext();

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const success = params.get('success');
    const error = params.get('error');
    const message =params.get('message') ?? ''
    if (success) {
      showToast(message, 'success');
    } else if (error) {
      showToast(message, 'error');
    }

    navigate('/login');
  }, [location, navigate, showToast]);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-md">
        <h1 className="text-2xl font-bold text-center">Verifying your email...</h1>
      </div>
    </div>
  );
};

export default VerificationResult;

---


### FILE: frontend/src/features/auth/pages/EmailVerification.tsx ###
import React, { useState } from 'react';
import { useLocation } from 'react-router-dom';
import { useResendEmailVerificationMutation } from '../services/authApi';
import { Button } from '../../../shared/components/ui/Button';
import { useToastContext } from '../../../shared/providers/ToastProvider';

const EmailVerification = () => {
  const location = useLocation();
  const email = location.state?.email;
  const [resendEmail, { isLoading }] = useResendEmailVerificationMutation();
  const { showToast } = useToastContext();

  const handleResendEmail = async () => {
    try {
      await resendEmail({ email }).unwrap();
      showToast('Verification email sent successfully!', 'success');
    } catch (err: any) {
      const errorMessage = err.data?.message || err.message || 'Unknown error';
      showToast(errorMessage, 'error');
      console.error('Failed to resend verification email: ', err);
    }
  };

  if (!email) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen">
        <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-md">
          <h1 className="text-2xl font-bold text-center">Invalid Page</h1>
          <p className="text-center">
            No email address was provided. Please register first.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-md">
        <h1 className="text-2xl font-bold text-center">Email Sent Successfully</h1>
        <p className="text-center">
          A verification email has been sent to <strong>{email}</strong>.
          Please check your inbox and click the verification link to activate your account.
        </p>
        <div className="text-center">
          <p>Didn't receive the email?</p>
          <Button
            variant="link"
            onClick={handleResendEmail}
            disabled={isLoading}
          >
            {isLoading ? 'Sending...' : 'Resend email'}
          </Button>
        </div>
      </div>
    </div>
  );
};

export default EmailVerification;

---


### FILE: frontend/src/features/auth/components/GoogleLogin.tsx ###
import { Button } from '../../../shared/components/ui/Button';

const GoogleLogin = () => {
  const googleLogin = () => {
    window.location.href = 'http://localhost:3000/api/auth/google';
  };

  return (
    <Button onClick={googleLogin} className="w-full">
      Login with Google
    </Button>
  );
};

export default GoogleLogin;

---


### FILE: frontend/src/features/auth/components/LogoutButton.tsx ###
import { useAppDispatch } from '../../../shared/stores/hooks';
import { logout } from '../stores/authSlice';
import { FaSignOutAlt } from 'react-icons/fa';
import { Button } from '../../../shared/components/ui/Button'; // Assuming you have a Button component

interface LogoutButtonProps {
  className?: string; // Add className prop
}

const LogoutButton: React.FC<LogoutButtonProps> = ({ className }) => {
  const dispatch = useAppDispatch();

  const handleLogout = () => {
    dispatch(logout());
  };

  return (
    <Button onClick={handleLogout} variant="ghost" className={`flex items-center space-x-1 ${className}`}>
      <FaSignOutAlt /> <span>Logout</span>
    </Button>
  );
};

export default LogoutButton;

---


### FILE: frontend/src/features/auth/components/AuthGard.tsx ###
import { useSelector } from 'react-redux';
import { Navigate, useLocation } from 'react-router-dom';
import type { RootState } from '../../../shared/stores/store';
import type { JSX } from 'react';

const AuthGuard = ({ children }: { children: JSX.Element }) => {
  const { accessToken } = useSelector((state: RootState) => state.auth);
  const location = useLocation();

  if (!accessToken) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
};

export default AuthGuard;

---


### FILE: frontend/src/features/auth/stores/authSlice.ts ###
import { createSlice, type PayloadAction } from '@reduxjs/toolkit';
import { authApi } from '../services/authApi';

interface AuthState {
  accessToken: string | null;
}

const initialState: AuthState = {
  accessToken: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setAccessToken: (state, action: PayloadAction<string | null>) => {
      state.accessToken = action.payload;
    },
    logout: (state) => {
      state.accessToken = null;
    },
  },
});

export const { setAccessToken, logout } = authSlice.actions;

export default authSlice.reducer;

---


### FILE: frontend/src/features/auth/services/authApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { LoginDto, RegisterDto, UserResponseDto, ResponseDto } from '../types';
import { setAccessToken, logout as authLogout } from '../stores/authSlice'; // Import setAccessToken and rename logout

export const authApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    register: builder.mutation<ResponseDto<UserResponseDto>, RegisterDto>({
      query: (credentials) => ({
        url: 'auth/register',
        method: 'POST',
        body: credentials,
      }),
      invalidatesTags: ['Me'],
    }),
    login: builder.mutation<ResponseDto<{ user: UserResponseDto, accessToken: string }>, LoginDto>({
      query: (credentials) => ({
        url: 'auth/login',
        method: 'POST',
        body: credentials,
      }),
      invalidatesTags: ['Me'],
      async onQueryStarted(_arg, { dispatch, queryFulfilled }) {
        try {
          const { data } = await queryFulfilled;
          dispatch(setAccessToken(data.data.accessToken));
        } catch (error) {
          // Handle error if needed
        }
      },
    }),
    logout: builder.mutation<ResponseDto<null>, void>({
      query: () => ({
        url: 'auth/logout',
        method: 'POST',
      }),
      invalidatesTags: ['Me'],
      async onQueryStarted(_arg, { dispatch, queryFulfilled }) {
        await queryFulfilled;
        dispatch(authLogout());
      },
    }),
    getMe: builder.query<ResponseDto<UserResponseDto>, void>({
      query: () => 'auth/me',
      providesTags: ['Me'],
    }),

    refresh: builder.query<ResponseDto<{ user: UserResponseDto, accessToken: string }>, void>({
      query: () => 'auth/refresh', // This endpoint on the backend uses the HttpOnly cookie to get a new access token and user
      async onQueryStarted(_arg, { dispatch, queryFulfilled }) {
        try {
          const { data } = await queryFulfilled;
          dispatch(setAccessToken(data.data.accessToken));
        } catch (error) {
          // Handle error if needed
        }
      },
    }),
    resendEmailVerification: builder.mutation<ResponseDto<null>, { email: string }>({
      query: ({ email }) => ({
        url: 'email-verification/resend',
        method: 'POST',
        body: { email },
      }),
    }),
  }),
});
export const {
  useRegisterMutation,
  useLoginMutation,
  useLogoutMutation,
  useGetMeQuery,
  useResendEmailVerificationMutation,
} = authApi;

---


### FILE: frontend/src/features/auth/hooks/useAuth.ts ###
import { useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import type { RootState } from '../../../shared/stores/store';
import { useLoginMutation, useGetMeQuery } from '../services/authApi';
import type { LoginDto } from '../types';

export const useAuth = () => {
  const { data, isLoading: isUserLoading, error: userError } = useGetMeQuery();
  const user = data?.data;

  const accessToken = useSelector((state: RootState) => state.auth.accessToken);

  const [login, { isLoading, error }] = useLoginMutation();
  const navigate = useNavigate();

  const handleLogin = async (data: LoginDto) => {
    try {
      await login(data).unwrap();
      navigate('/');
    } catch (err: any) {
      console.error('Failed to login: ', err);
    }
  };

  return {
    user,
    isUserLoading,
    userError,
    accessToken,
    isAuthenticated: !!user && !!accessToken,
    handleLogin,
    isLoggingIn: isLoading,
    loginError: error,
  };
};

---


### FILE: frontend/src/features/communities/types.ts ###
export interface Community {
  communityType: CommunityType;
  id: number;
  name: string;
  displayName: string;
  description: string;
  membersCount: number;
  createdAt: string;
  userMembershipStatus?: 'member' | 'pending' | 'none';
}

export interface CreateCommunityDto {
  name: string;
  displayName?: string;
  description?: string;
}

export interface UpdateCommunityDto extends Partial<CreateCommunityDto> {}

export interface CommunityQueryDto {
  name?: string;
  displayName?: string;
  page?: number;
  limit?: number;
}

export type CommunityType = 'public' | 'restricted' | 'private';

---


### FILE: frontend/src/features/communities/pages/MyCommunitiesPage.tsx ###
import React from 'react';
import { useGetCommunityMembershipsQuery } from '../../community-memberships/services/communityMembershipsApi';
import CommunityCard from '../components/CommunityCard'; // Assuming a CommunityCard component exists
import type { CommunityMembership } from '../../community-memberships/types';
import type { Community } from '../types';
import { useAuth } from '../../auth/hooks/useAuth';

const MyCommunitiesPage: React.FC = () => {
  const { user } = useAuth(); // Get current user from auth context/hook

  const { data, isLoading, isError, error } = useGetCommunityMembershipsQuery(
    {
      userId: user?.id,
      limit: 100, // Fetch a reasonable number of memberships
    },
    { skip: !user?.id } // Skip query if user ID is not available
  );

  if (isLoading) {
    return <div className="text-center mt-8">Loading your communities...</div>;
  }

  if (isError) {
    console.error("Error loading my communities:", error);
    return <div className="text-center mt-8 text-red-500">Error loading your communities.</div>;
  }

  const memberships: CommunityMembership[] = data?.data || [];
  const myCommunities: Community[] = memberships.map(sub => sub.community).filter(Boolean) as Community[];

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-3xl font-bold mb-6">My Communities</h1>

      {myCommunities.length === 0 ? (
        <div className="text-center p-8 bg-white rounded-lg shadow-md">
          <p className="text-gray-600 text-lg mb-4">You haven't joined any communities yet.</p>
          <p className="text-gray-500">Explore communities to find ones that interest you!</p>
          {/* TODO: Add a link to the Explore Communities page here */}
        </div>
      ) : (
        <div className="grid gap-6 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
          {myCommunities.map((community) => (
            <CommunityCard key={community.id} community={community} />
          ))}
        </div>
      )}
    </div>
  );
};

export default MyCommunitiesPage;

---


### FILE: frontend/src/features/communities/pages/CommunityPage.tsx ###
import React from 'react';
import { useParams } from 'react-router-dom';
import { CommunityHeader } from '../components/CommunityHeader';
import PostList from '../../posts/components/PostList';
import { useGetPostsInfiniteQuery } from '../../posts/services/postsApi';

export const CommunityPage = () => {
  const { communityId } = useParams<{ communityId: string }>();
  const communityIdNumber = +(communityId || 0);

  const {
    data: postsData,
    error: postsError,
    isLoading: postsLoading,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useGetPostsInfiniteQuery({ communityId: communityIdNumber });

  const posts = postsData?.pages.flatMap((page) => page.data) || [];

  return (
    <>
    <div className="mb-8">
            <CommunityHeader communityId={communityIdNumber}  />

    </div>

      <PostList posts={posts} isLoading={postsLoading} error={postsError} />
    </>
  );
};


---


### FILE: frontend/src/features/communities/pages/QueuesPage.tsx ###
// frontend/src/features/communities/pages/mod/ModQueuesPage.tsx
import { useState } from 'react';
import { useParams } from 'react-router-dom';
import { useAcceptMembershipRequestMutation, useGetCommunityMembershipRequestsQuery, useRejectMembershipRequestMutation } from '../../community-membership-requests/services/communityMembershipRequestsApi';
import { Button } from '../../../shared/components/ui/Button';
import { CommunityMembershipRequestStatus } from '../../community-membership-requests/types';
import { ReportsQueue } from '../../reports/components/ReportsQueue';
import { PendingPostsQueue } from '../../posts/components/PendingPostsQueue';
import { RejectedPostsQueue } from '../../posts/components/RejectedPostsQueue';

const JoinRequestsQueue = () => {
  const { communityId } = useParams();
  const { data:requests, isLoading } = useGetCommunityMembershipRequestsQuery({
    communityId: +communityId,
    status: CommunityMembershipRequestStatus.PENDING,
    page: 1,
    limit: 10,
  });
  const [approve] = useAcceptMembershipRequestMutation();
  const [reject] = useRejectMembershipRequestMutation();

  if (isLoading) return <div className="p-4">Loading queue...</div>;

  return (
    <>
      {requests?.data.length === 0 ? (
        <div className="text-center py-10 bg-gray-50 rounded-lg border">
          <p className="text-gray-500 italic">No pending requests to review.</p>
        </div>
      ) : (
        <div className="space-y-3">
          {requests?.data.map((req) => (
            <div key={req.id} className="flex items-center p-4 bg-white rounded-lg border border-gray-200 shadow-sm">
              <div className="flex-shrink-0 mr-4">
                {/* Placeholder for avatar - could be replaced with actual avatar later */}
                <div className="h-10 w-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-500 font-bold">
                  {req.user.username.charAt(0).toUpperCase()}
                </div>
              </div>
              <div className="flex-grow">
                <a href={`/profile/${req.userId}`} className="font-medium text-blue-600 hover:underline text-lg">
                  {req.user.username}
                </a>
                <p className="text-xs text-gray-500 italic">Requested on {new Date(req.createdAt).toLocaleDateString()}</p>
              </div>
              <div className="flex gap-2">
                <Button size="sm" onClick={() => approve({communityId: req.communityId,
                  userId:req.userId})} className="bg-green-600 hover:bg-green-700 rounded-full">Approve</Button>
                <Button size="sm" variant="outline" onClick={() => reject({userId:req.userId ,communityId:req.communityId})} className="text-red-600 border-red-600 hover:bg-red-50 rounded-full">Reject</Button>
              </div>
            </div>
          ))}
        </div>
      )}
    </>
  );
}

export const ModQueuesPage = () => {
  const [activeTab, setActiveTab] = useState('join-requests');

  return (
    <div className="max-w-4xl mx-auto">
      <h2 className="text-2xl font-bold mb-6">Moderation Queues</h2>

      <div className="border-b border-gray-200">
        <nav className="-mb-px flex space-x-8" aria-label="Tabs">
          <button
            onClick={() => setActiveTab('join-requests')}
            className={`${
              activeTab === 'join-requests'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
            } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm`}
          >
            Join Requests
          </button>
          <button
            onClick={() => setActiveTab('reports')}
            className={`${
              activeTab === 'reports'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
            } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm`}
          >
            Reports
          </button>
          <button
            onClick={() => setActiveTab('pending-posts')}
            className={`${
              activeTab === 'pending-posts'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
            } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm`}
          >
            Pending Posts
          </button>
          <button
            onClick={() => setActiveTab('rejected-posts')}
            className={`${
              activeTab === 'rejected-posts'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
            } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm`}
          >
            Rejected Posts
          </button>
        </nav>
      </div>

      <div className="py-6">
        {activeTab === 'join-requests' && <JoinRequestsQueue />}
        {activeTab === 'reports' && <ReportsQueue />}
        {activeTab === 'pending-posts' && <PendingPostsQueue />}
        {activeTab === 'rejected-posts' && <RejectedPostsQueue />}
      </div>
    </div>
  );
};
---


### FILE: frontend/src/features/communities/pages/ExploreCommunitiesPage.tsx ###
import React, { useState } from 'react';
import { useGetCommunitiesQuery } from '../services/communitiesApi';
import CommunityCard from '../components/CommunityCard';
import type { CommunityQueryDto } from '../types';

const ExploreCommunitiesPage: React.FC = () => {
  const [queryParams, setQueryParams] = useState<CommunityQueryDto>({
    limit: 10,
    page: 1,
  });
  const [searchTerm, setSearchTerm] = useState('');

  const { data, isLoading, isError, error } = useGetCommunitiesQuery(queryParams);

  const communities = data?.data || [];
  const meta = data?.meta;

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchTerm(e.target.value);
  };

  const handleSearchSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setQueryParams((prev) => ({ ...prev, name: searchTerm, page: 1 }));
  };

  const handleLoadMore = () => {
    if (meta?.hasNextPage) {
      setQueryParams((prev) => ({ ...prev, page: (prev.page || 1) + 1 }));
    }
  };

  if (isLoading && queryParams.page === 1) {
    return <div className="text-center mt-8">Loading communities...</div>;
  }

  if (isError) {
    console.error("Error loading communities:", error);
    return <div className="text-center mt-8 text-red-500">Error loading communities.</div>;
  }

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-3xl font-bold mb-6">Explore Communities</h1>

      <form onSubmit={handleSearchSubmit} className="mb-6 flex space-x-2">
        <input
          type="text"
          placeholder="Search communities by name..."
          value={searchTerm}
          onChange={handleSearchChange}
          className="flex-grow p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500"
        />
        <button
          type="submit"
          className="bg-primary-600 text-white px-4 py-2 rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500"
        >
          Search
        </button>
      </form>

      {communities.length === 0 ? (
        <div className="text-center p-8 bg-white rounded-lg shadow-md">
          <p className="text-gray-600 text-lg mb-4">No communities found matching your criteria.</p>
        </div>
      ) : (
        <div className="grid gap-6 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
          {communities.map((community) => (
            <CommunityCard key={community.id} community={community} />
          ))}
        </div>
      )}

      {meta?.hasNextPage && (
        <div className="text-center mt-6">
          <button
            onClick={handleLoadMore}
            disabled={isLoading}
            className="bg-gray-200 text-gray-800 px-4 py-2 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400"
          >
            {isLoading ? 'Loading more...' : 'Load More'}
          </button>
        </div>
      )}
    </div>
  );
};

export default ExploreCommunitiesPage;

---


### FILE: frontend/src/features/communities/components/SuggestedCommunities.tsx ###
import React from 'react';
import { useGetCommunitiesQuery } from '../services/communitiesApi';
import { Link } from 'react-router-dom';

const SuggestedCommunities = () => {
  const { data, isLoading, isError } = useGetCommunitiesQuery({ sort: 'popular', limit: 5 });

  if (isLoading) {
    return (
      <div className="bg-white rounded-lg shadow-md p-4">
        <h2 className="text-xl font-semibold mb-4">Suggested Communities</h2>
        <div className="animate-pulse space-y-3">
          <div className="h-4 bg-gray-200 rounded w-3/4"></div>
          <div className="h-4 bg-gray-200 rounded"></div>
          <div className="h-4 bg-gray-200 rounded w-5/6"></div>
        </div>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="bg-white rounded-lg shadow-md p-4 text-red-600">
        <h2 className="text-xl font-semibold mb-4">Suggested Communities</h2>
        <p>Error loading suggested communities.</p>
      </div>
    );
  }

  const communities = data?.data || [];

  if (communities.length === 0) {
    return null; // Or a message like "No suggestions"
  }

  return (
    <div className="bg-white rounded-lg border border-gray-300 p-4">
      <h2 className="text-xl font-semibold mb-4">Suggested Communities</h2>
      <ul>
        {communities.map((community) => (
          <li key={community.id} className="mb-2 last:mb-0">
            <Link to={`/communities/${community.id}`} className="text-primary-600 hover:underline">
              {community.displayName || community.name}
            </Link>
            <p className="text-sm text-gray-500">{community.membersCount} subscribers</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default SuggestedCommunities;

---


### FILE: frontend/src/features/communities/components/CommunityCard.tsx ###
import React from 'react';
import type { Community } from '../types';
import { Link } from 'react-router-dom';
import { FaUsers } from 'react-icons/fa';

interface CommunityCardProps {
  community: Community;
}

const CommunityCard: React.FC<CommunityCardProps> = ({ community }) => {
  return (
    <div className="bg-white dark:bg-gray-800 rounded-xl border border-gray-300 p-4 flex flex-col justify-between border border-gray-300 hover:shadow-lg transition-shadow duration-200">
      <div>
        <Link to={`/communities/${community.id}`}>
          <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100 hover:text-primary-600 mb-2">
            c/{community.name}
          </h3>
        </Link>
        <p className="text-gray-600 dark:text-gray-300 text-sm line-clamp-3 mb-3">
          {community.description || 'No description provided.'}
        </p>
      </div>
      <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
        <FaUsers className="mr-1" />
        <span>{community.membersCount || 0} subscribers</span>
      </div>
    </div>
  );
};

export default CommunityCard;

---


### FILE: frontend/src/features/communities/components/AboutCommunity.tsx ###
import React from 'react';
import { useAuth } from '../../auth/hooks/useAuth';
import { useGetCommunityByIdQuery } from '../services/communitiesApi';
import { Link } from 'react-router-dom';
import { CommunityMembershipActionButton } from './CommunityMembershipActionButton';

interface AboutCommunityProps {
  communityId: number;
}

export const AboutCommunity: React.FC<AboutCommunityProps> = ({ communityId }) => {
  const { user: currentUser } = useAuth();
  const { data: communityData, error: communityError, isLoading: communityLoading } = useGetCommunityByIdQuery(communityId);


  if (communityLoading) {
    return <div className="p-4 bg-white rounded-lg shadow">Loading community info...</div>;
  }

  if (communityError || !communityData?.data) {
    return <div className="p-4 bg-white rounded-lg shadow text-red-500">Community not found</div>;
  }

  const community = communityData.data;

  return (
    <div className="bg-white rounded-lg border border-gray-300 p-4">
      <h2 className="text-lg font-semibold mb-2">
        About <Link to={`/communities/${community.id}`} className="text-primary-600 hover:underline">r/{community.name}</Link></h2>
      {community.description && <p className="text-sm text-gray-700 mb-3">{community.description}</p>}
      <div className="flex justify-between items-center text-sm text-gray-600 mb-3">
        <span>Members: {community.membersCount.toLocaleString()}</span>
        <span>Created: {new Date(community.createdAt).toLocaleDateString()}</span>
      </div>
      <CommunityMembershipActionButton community={community} currentUser={currentUser} />
    </div>
  );
};

---


### FILE: frontend/src/features/communities/components/CommunityHeader.tsx ###
import React from 'react';
import { useSelector } from 'react-redux';
import type { RootState } from '../../../shared/stores/store';
import { useGetCommunityByIdQuery } from '../services/communitiesApi';
import { CommunityMembershipActionButton } from './CommunityMembershipActionButton';
import { FaShieldAlt } from 'react-icons/fa';
import  { Link } from 'react-router-dom';
import  { Button } from '../../../shared/components/ui/Button';
import { useGetCommunityMembershipsQuery } from '../../community-memberships/services/communityMembershipsApi';
import { useAuth } from '../../auth/hooks/useAuth';

interface CommunityHeaderProps {
  communityId: number;
}

export const CommunityHeader: React.FC<CommunityHeaderProps> = ({ communityId }) => {
  const { user: currentUser } = useAuth();
  const { data, error, isLoading } = useGetCommunityByIdQuery(communityId);

const { data: membershipData } = useGetCommunityMembershipsQuery({
    communityId,
    userId: currentUser?.id,
  }, { skip: !currentUser?.id });

  console.log(membershipData);
  
  const membership = membershipData?.data?.[0];
  const isMod = membership?.role === 'admin' || membership?.role === 'moderator'|| membership?.role === 'owner';
  if (isLoading) {
    return <div className="h-40 animate-pulse rounded-lg bg-gray-200" />;
  }

  if (error || !data?.data) {
    return <div className="text-sm text-red-500">Community not found</div>;
  }

  const community = data.data;
  console.log(community);
  

  return (
    <div className="overflow-hidden rounded-lg border border-gray-300 bg-white">
      {/* Banner */}
      <div className="h-28 bg-gradient-to-r from-indigo-500 to-purple-600" />

      {/* Content */}
      <div className="relative px-4 pb-4">
        {/* Avatar */}
        <div className="absolute -top-10 flex h-20 w-20 items-center justify-center rounded-full border-4 border-white bg-gray-100 text-2xl font-bold text-gray-600">
          {community.displayName?.charAt(0).toUpperCase()}
        </div>

        <div className="ml-24 flex items-start justify-between pt-2">
          <div>
            <h1 className="text-xl font-semibold leading-tight">
              {community.displayName}
            </h1>
            <p className="text-sm text-gray-500">r/{community.name} ({community.communityType})</p>
          </div>
{/* Mod Tools Button: Only visible to Mods/Admins */}
        {isMod && (
          <Link to={`/mod/community/${communityId}`}>
            <Button variant="outline" className="flex items-center gap-2">
              <FaShieldAlt className="text-orange-600" />
              Mod Tools
            </Button>
          </Link>
        )}
          <CommunityMembershipActionButton community={community} currentUser={currentUser} />
        </div>

        {/* Description */}
        {community.description && (
          <p className="mt-3 text-sm text-gray-700">
            {community.description}
          </p>
        )}

        {/* Stats */}
        <div className="mt-3 flex gap-4 text-sm text-gray-600">
          <span>
            <strong className="text-gray-900">
              {community.membersCount.toLocaleString()}
            </strong>{' '}
            members
          </span>
          <span>Online</span>
        </div>
      </div>
    </div>
  );
};

---


### FILE: frontend/src/features/communities/components/CommunityMembershipActionButton.tsx ###
import React from 'react';
import { Button } from '../../../shared/components/ui/Button';
import {
  useCancelMembershipRequestMutation,
  useCreateMembershipRequestMutation,
  useRejectMembershipRequestMutation,
} from '../../community-membership-requests/services/communityMembershipRequestsApi';
import { useDeleteMembershipMutation } from '../../community-memberships/services/communityMembershipsApi';
import type { Community } from '../types';
import type { UserResponseDto } from '../../auth/types';

interface CommunityMembershipActionButtonProps {
  community: Community;
  currentUser: UserResponseDto | null;
}

export const CommunityMembershipActionButton: React.FC<
  CommunityMembershipActionButtonProps
> = ({ community, currentUser }) => {
  const [createMembershipRequest, { isLoading: isCreatingRequest }] =
    useCreateMembershipRequestMutation();
  const [deleteMembership, { isLoading: isDeletingMembership }] =
    useDeleteMembershipMutation();
  const [cancelMembershipRequest, { isLoading: isRejectingRequest }] =
    useCancelMembershipRequestMutation();

  const handleJoinOrRequest = () => {
    if (currentUser) {
      createMembershipRequest(community.id);
    } else {
      console.log('Please log in to join or request membership.');
      // TODO: Implement actual login redirection or modal
    }
  };

  const handleLeave = () => {
    if (currentUser) {
      deleteMembership(community.id);
    } else {
      console.log('Please log in to leave the community.');
    }
  };

  const handleCancelRequest = () => {
    if (currentUser && community.userMembershipStatus=="pending") {
      // Assuming communityId is used to reject the user's own request
      cancelMembershipRequest(community.id);
    } else {
      console.log('Error: Cannot cancel request.');
    }
  };

  if (!currentUser) {
    return (
      <Button onClick={() => console.log('Redirect to login')} disabled>
        Login to Join
      </Button>
    ); // Or null, depending on UX
  }

  switch (community.userMembershipStatus) {
    case 'member':
      return (
        <Button onClick={handleLeave} disabled={isDeletingMembership}>
          {isDeletingMembership ? 'Leaving...' : 'Joined'}
        </Button>
      );
    case 'pending':
      return (
        <Button onClick={handleCancelRequest} disabled={isRejectingRequest}>
          {isRejectingRequest ? 'Cancelling...' : 'Cancel Request'}
        </Button>
      );
    case 'none':
    default:
      return (
        <Button onClick={handleJoinOrRequest} disabled={isCreatingRequest}>
          {isCreatingRequest
            ? 'Sending Request...'
            : community.communityType === 'public'
            ? 'Join'
            : 'Request to Join'}
        </Button>
      );
  }
};

---


### FILE: frontend/src/features/communities/components/CreateCommunityForm.tsx ###
import React from "react";
import { Button } from "../../../shared/components/ui/Button";
import { Input } from "../../../shared/components/ui/Input";
import { Label } from "../../../shared/components/ui/Label";
import { Textarea } from "../../../shared/components/ui/TextArea";
import { Controller } from "react-hook-form";
import { InputError } from "../../../shared/components/ui/InputError";
import { InputRadio } from "../../../shared/components/InputRadio";
import Toast from "../../../shared/components/ui/Toast";
import { useCreateCommunityForm } from "../hooks/useCreateCommunityForm";

interface CreateCommunityFormProps {
  onClose: () => void;
}

const CreateCommunityForm: React.FC<CreateCommunityFormProps> = ({
  onClose,
}) => {
  const { step, form, submission, navigation, toast: toastState } =
    useCreateCommunityForm(onClose);
  const { control, register, handleSubmit, errors } = form;
  const { onSubmit, isLoading } = submission;
  const { nextStep, prevStep } = navigation;
  const { toast, setToast } = toastState;

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="p-4">
      {toast && (
        <Toast
          message={toast.message}
          type={toast.type}
          onClose={() => setToast(null)}
        />
      )}
      {/* Step 0: Community Type */}
      {step === 0 && (
        <div className="mb-4">
          <h2 className="text-xl font-bold mb-2">
            Choose your community type
          </h2>
          <p className="text-gray-600 mb-4">
            Each community type controls who can view and post in your
            community.
          </p>
          <Controller
            name="communityType"
            control={control}
            render={({ field }) => {
              const options = [
                {
                  value: "public",
                  title: "Public",
                  description: "Anyone can view, post, and comment.",
                },
                {
                  value: "restricted",
                  title: "Restricted",
                  description:
                    "Anyone can view, only approved users can post.",
                },
                {
                  value: "private",
                  title: "Private",
                  description: "Only approved users can view and post.",
                },
              ];

              return (
                <div className="flex flex-col gap-3 mt-2">
                  {options.map((option) => (
                    <div
                      key={option.value}
                      className={`flex items-center p-4 border rounded-lg cursor-pointer transition
                  ${
                    field.value === option.value
                      ? "border-blue-500 bg-blue-50"
                      : "border-gray-300 hover:bg-gray-50"
                  }
                `}
                      onClick={() => field.onChange(option.value)}
                    >
                      <InputRadio
                        checked={field.value === option.value}
                        onChange={() => field.onChange(option.value)}
                        size="md"
                        colorClass="bg-blue-500"
                      />
                      <div className="ml-3">
                        <div className="font-medium">{option.title}</div>
                        <div className="text-sm text-gray-500">
                          {option.description}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              );
            }}
          />
          <InputError message={errors.communityType?.message} />
        </div>
      )}

      {/* Step 1: Community Info */}
      {step === 1 && (
        <>
          <h2 className="text-xl font-bold mb-2">
            Tell us about your community
          </h2>
          <p className="text-gray-600 mb-4">
            Give your community a name and description so people know what it‚Äôs
            about.
          </p>
          <div className="mb-4">
            <Label htmlFor="name">Community Name:</Label>
            <Input id="name" {...register("name")} />
            <InputError message={errors.name?.message} />
          </div>
          <div className="mb-4">
            <Label htmlFor="description">Description:</Label>
            <Textarea
              id="description"
              {...register("description")}
              rows={4}
            />
            <InputError message={errors.description?.message} />
          </div>
        </>
      )}

      {/* Navigation */}
      <div className="flex gap-5 justify-end mt-4">
        {step > 0 && (
          <Button type="button" variant="secondary" onClick={prevStep}>
            Back
          </Button>
        )}

        {step < 1 && (
          <Button type="button" onClick={nextStep}>
            Next
          </Button>
        )}

        {step === 1 && (
          <Button type="submit" disabled={isLoading}>
            {isLoading ? "Creating..." : "Create Community"}
          </Button>
        )}
      </div>
    </form>
  );
};

export default CreateCommunityForm;

---


### FILE: frontend/src/features/communities/services/communitiesApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { Community, CreateCommunityDto, UpdateCommunityDto, CommunityQueryDto } from '../types';
import type { PaginatedResponse, ResponseDto } from '../../../shared/types';

export const communitiesApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    getCommunities: builder.query<PaginatedResponse<Community>, CommunityQueryDto>({
      query: (params) => ({
        url: '/communities',
        params,
      }),
      providesTags: ['Communities',"CommunityMemberships"],
    }),
    getCommunityById: builder.query<ResponseDto<Community>, number>({
      query: (id) => `/communities/${id}`,
      providesTags: (result, error, id) => [{ type: 'Communities', id }],
    }),
    createCommunity: builder.mutation<ResponseDto<Community>, CreateCommunityDto>({
      query: (newCommunity) => ({
        url: '/communities',
        method: 'POST',
        body: newCommunity,
      }),
      invalidatesTags: ['Communities',"CommunityMemberships"],
    }),
    updateCommunity: builder.mutation<ResponseDto<Community>, { id: number; data: UpdateCommunityDto }>({
      query: ({ id, data }) => ({
        url: `/communities/${id}`,
        method: 'PATCH',
        body: data,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Communities', id }],
    }),
    deleteCommunity: builder.mutation<ResponseDto<boolean>, number>({
      query: (id) => ({
        url: `/communities/${id}`,
        method: 'DELETE',
      }),
      invalidatesTags: ['Communities',"CommunityMemberships"],
    }),
  }),
});

export const {
  useGetCommunitiesQuery,
  useGetCommunityByIdQuery,
  useCreateCommunityMutation,
  useUpdateCommunityMutation,
  useDeleteCommunityMutation,
} = communitiesApi;

---


### FILE: frontend/src/features/communities/hooks/useCreateCommunityForm.ts ###
import React, { useState } from "react";
import { useForm, type SubmitHandler } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import z from "zod";
import { useCreateCommunityMutation } from "../services/communitiesApi";
import type { ToastType } from "../../../shared/components/ui/Toast";

const createCommunitySchema = z.object({
  communityType: z.enum(["public", "private", "restricted"]),
  name: z.string().min(3, "Community Name must be at least 3 characters"),
  description: z.string().optional(),
});

type CreateCommunityFormValues = z.infer<typeof createCommunitySchema>;

const stepFields: (keyof CreateCommunityFormValues)[][] = [
  ["communityType"], // Step 0
  ["name", "description"], // Step 1
];

export const useCreateCommunityForm = (onClose: () => void) => {
  const [step, setStep] = React.useState(0);
  const [createCommunity, { isLoading }] = useCreateCommunityMutation();
  const [toast, setToast] =
    useState<{ message: string; type: ToastType } | null>(null);

  const {
    control,
    register,
    trigger,
    handleSubmit,
    formState: { errors },
  } = useForm<CreateCommunityFormValues>({
    resolver: zodResolver(createCommunitySchema),
    defaultValues: {
      name: "",
      description: "",
    },
  });

  const onSubmit: SubmitHandler<CreateCommunityFormValues> = async (data) => {
    try {
      const response = await createCommunity(data).unwrap();
      setToast({ message: "Community created successfully!", type: "success" });
      onClose();
    } catch (err) {
      setToast({
        message: (err as any).data?.message || "Failed to create community",
        type: "error",
      });
      console.error("Failed to create community:", err);
    }
  };

  const nextStep = async () => {
    const valid = await trigger(stepFields[step]);
    if (valid) setStep(step + 1);
  };

  const prevStep = () => {
    setStep(step - 1);
  };

  return {
    step,
    form: {
      control,
      register,
      handleSubmit,
      errors,
    },
    submission: {
      onSubmit,
      isLoading,
    },
    navigation: {
      nextStep,
      prevStep,
    },
    toast: {
      toast,
      setToast,
    },
  };
};

---


### FILE: frontend/src/features/profile/types.ts ###
// Assuming User is already defined in a shared types file or needs to be defined here.
// For now, let's include a minimal User type if not already globally available.
export interface User {
  id: number;
  username: string;
  email: string;
  // Add other user properties as needed
}

export interface Profile {
  id: number;
  displayName: string;
  bio: string | null;
  picture: string | null; // URL to the profile picture
  user: User; // The associated user object
  
}

export interface UpdateProfilePayload {
  username?: string;
  bio?: string | null;
  picture?: string | null;
}

export interface CreateProfilePayload {
  username: string;
  bio?: string | null;
  picture?: string | null;
}

---


### FILE: frontend/src/features/profile/pages/ProfilePage.tsx ###
import { FaUserCircle, FaEdit } from 'react-icons/fa';
import { ProfileEditForm } from '../components/ProfileEditForm';
import { Modal } from '../../../shared/components/ui/Modal';
import UserCommentList from '../../comments/components/UserCommentList';
import { Button } from '../../../shared/components/ui/Button';
import PostList from '../../posts/components/PostList';
import { useProfile } from '../hooks/useProfilePage';

export const ProfilePage = () => {
  const {
    profile,
    isLoading,
    error,
    isMyProfile,
    isEditing,
    setIsEditing,
    activeTab,
    setActiveTab,
    handleEditSuccess,
    handleEditCancel,
    posts,
    comments,
  } = useProfile();

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-screen">
        <p className="text-gray-600">Loading profile...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex justify-center items-center h-screen">
        <p className="text-red-500">Error: {error}</p>
      </div>
    );
  }

  if (!profile) {
    return (
      <div className="flex justify-center items-center h-screen">
        <p className="text-gray-600">Profile not found.</p>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto my-8 p-6 bg-white border border-gray-300 rounded-lg">
      {/* Profile Display Section */}
      <>
        <div className="flex items-center space-x-6">
          <div className="flex-shrink-0">
            {profile.picture ? (
              <img
                className="h-24 w-24 rounded-full object-cover border-4 border-blue-300"
                src={profile.picture}
                alt={`${profile.username}'s profile picture`}
              />
            ) : (
              <FaUserCircle className="h-24 w-24 text-gray-400 border-4 border-blue-300 rounded-full p-1" />
            )}
          </div>
          <div>
            <h1 className="text-4xl font-bold text-gray-800">
              {profile.username}
            </h1>
            <p className="text-gray-600 text-lg">{profile.user.email}</p>
            {isMyProfile && (
              <Button
              
                onClick={() => setIsEditing(true)}
              >
                <FaEdit />
                <span className='mx-2'>Edit Profile</span>
              </Button>
            )}
          </div>
        </div>

        <div className="mt-8 border-t border-gray-300 pt-6">
          <h2 className="text-2xl font-semibold text-gray-800">About Me</h2>
          <p className="mt-4 text-gray-700">
            {profile.bio || 'No biography available yet.'}
          </p>
        </div>
      </>

      {/* Profile Edit Modal */}
      {isMyProfile && (
        <Modal open={isEditing} onClose={handleEditCancel}>
          <ProfileEditForm
            currentProfile={profile}
            onSuccess={handleEditSuccess}
            onCancel={handleEditCancel}
          />
        </Modal>
      )}

      {/* Posts and Comments Sections */}
      <div className="mt-8 border-t border-gray-300 pt-6">
        <div className="flex space-x-4 mb-4">
          <Button
            variant={activeTab === 'posts' ? 'default' : 'outline'}
            onClick={() => setActiveTab('posts')}
          >
            Posts ({posts.total})
          </Button>
          <Button
            variant={activeTab === 'comments' ? 'default' : 'outline'}
            onClick={() => setActiveTab('comments')}
          >
            Comments ({comments.total})
          </Button>
        </div>

        {activeTab === 'posts' && (
          <div>
            <h2 className="text-2xl font-semibold text-gray-800 mb-4">
              Posts
            </h2>
            {posts.isLoading ? (
              <p>Loading posts...</p>
            ) : posts.data.length > 0 ? (
              <>
                <PostList
                  posts={posts.data}
                  isLoading={false}
                  error={undefined}
                />
                {posts.hasNextPage && (
                  <div className="flex justify-center mt-4">
                    <Button
                      onClick={() => posts.fetchNextPage()}
                      disabled={posts.isFetchingNextPage}
                    >
                      {posts.isFetchingNextPage
                        ? 'Loading more...'
                        : 'Load More Posts'}
                    </Button>
                  </div>
                )}
              </>
            ) : (
              <p>No posts found.</p>
            )}
          </div>
        )}

        {activeTab === 'comments' && (
          <div>
            <h2 className="text-2xl font-semibold text-gray-800 mb-4">
              Comments
            </h2>
            {comments.isLoading ? (
              <p>Loading comments...</p>
            ) : comments.data.length > 0 ? (
              <>
                <UserCommentList // Use UserCommentList
                  comments={comments.data}
                  fetchNextPage={comments.fetchNextPage}
                  hasNextPage={comments.hasNextPage}
                  isFetchingNextPage={comments.isFetchingNextPage}
                  isLoading={comments.isLoading}
                />
              </>
            ) : (
              <p>No comments found.</p>
            )}
          </div>
        )}
      </div>
    </div>
  );
};
---


### FILE: frontend/src/features/profile/components/ProfileEditForm.tsx ###
import { Input } from '../../../shared/components/ui/Input';
import { Textarea } from '../../../shared/components/ui/TextArea';
import { Button } from '../../../shared/components/ui/Button';
import { Label } from '../../../shared/components/ui/Label';
import { useProfileEditForm } from '../hooks/useProfileEditForm';
import type { Profile } from '../types';

interface ProfileEditFormProps {
  currentProfile: Profile;
  onSuccess: () => void;
  onCancel: () => void;
}

export const ProfileEditForm = ({
  currentProfile,
  onSuccess,
  onCancel,
}: ProfileEditFormProps) => {
  const { form, submission, file } = useProfileEditForm({
    currentProfile,
    onSuccess,
  });
  const { register, handleSubmit, errors } = form;
  const { onSubmit, isLoading } = submission;
  const { selectedFile, handleFileChange } = file;

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <Label htmlFor="displayName">Display Name</Label>
        <Input id="displayName" {...register('displayName')} className="w-full" />
        {errors.displayName && (
          <p className="text-red-500 text-sm mt-1">
            {errors.displayName.message}
          </p>
        )}
      </div>

      <div>
        <Label htmlFor="bio">Bio</Label>
        <Textarea
          id="bio"
          {...register('bio')}
          className="w-full"
          rows={5}
        />
        {errors.bio && (
          <p className="text-red-500 text-sm mt-1">{errors.bio.message}</p>
        )}
      </div>

      <div>
        <Label htmlFor="picture">Profile Picture</Label>
        <Input
          id="picture"
          type="file"
          accept="image/*"
          onChange={handleFileChange}
          className="w-full"
        />
        {selectedFile && (
          <p className="text-sm text-gray-500 mt-1">
            File selected: {selectedFile.name}
          </p>
        )}
      </div>

      <div className="flex justify-end space-x-2">
        <Button
          type="button"
          variant="outline"
          onClick={onCancel}
          disabled={isLoading}
        >
          Cancel
        </Button>
        <Button type="submit" disabled={isLoading}>
          {isLoading ? 'Saving...' : 'Save Changes'}
        </Button>
      </div>
    </form>
  );
};

---


### FILE: frontend/src/features/profile/services/profileApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { ResponseDto } from '../../../shared/types';
import type { Profile } from '../types'; // Assuming types.ts defines Profile

export const profileApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    getProfileByUserId: builder.query<
      ResponseDto<Profile>, // Adjust response type if needed
      number // userId
    >({
      query: (userId) => `/profile/user/${userId}`,
      providesTags: ['Profile'],
    }),
    updateMyProfile: builder.mutation<
      ResponseDto<Profile>,
      Partial<Profile> & { pictureFile?: File }
    >({
      query: ({ pictureFile, ...patch }) => {
        const formData = new FormData();
        if (pictureFile) {
          formData.append('file', pictureFile);
        }
        Object.keys(patch).forEach(key => {
          if (patch[key] !== undefined) {
            formData.append(key, patch[key]);
          }
        });

        return {
          url: `/profile`,
          method: 'PATCH',
          body: formData,
        };
      },
      invalidatesTags: ['Me', 'Profile'],
    }),
    createMyProfile: builder.mutation<
      ResponseDto<Profile>,
      Partial<Profile> & { pictureFile?: File }
    >({
      query: ({ pictureFile, ...patch }) => {
        const formData = new FormData();
        if (pictureFile) {
          formData.append('file', pictureFile);
        }
        Object.keys(patch).forEach(key => {
          if (patch[key] !== undefined) {
            formData.append(key, patch[key]);
          }
        });

        return {
          url: `/profile`,
          method: 'POST',
          body: formData,
        };
      },
      invalidatesTags: ['Me', 'Profile'],
    }),
  }),
});

export const {
  useGetProfileByUserIdQuery,
  useUpdateMyProfileMutation,
  useCreateMyProfileMutation,
} = profileApi;

---


### FILE: frontend/src/features/profile/hooks/useProfile.ts ###
import { useGetMeQuery } from "../../auth/services/authApi";
import { useGetProfileByUserIdQuery } from "../services/profileApi";

export const useProfile = () => {
  const { data: me } = useGetMeQuery();
  const userId = me?.data.id;
  const { data: profile } = useGetProfileByUserIdQuery(userId!, {
    skip: !userId,
  });

  return profile?.data;
};

---


### FILE: frontend/src/features/profile/hooks/useProfileEditForm.ts ###
import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { useUpdateMyProfileMutation } from '../services/profileApi';
import type { Profile } from '../types';

interface UseProfileEditFormProps {
  currentProfile: Profile;
  onSuccess: () => void;
}

const profileSchema = z.object({
  displayName: z
    .string()
    .min(3, 'Display name must be at least 3 characters.')
    .max(20, 'Display name cannot exceed 20 characters.'),
  bio: z.string().max(500, 'Bio cannot exceed 500 characters.').nullable(),
  pictureFile: z.any().optional(),
});

type ProfileFormValues = z.infer<typeof profileSchema>;

export const useProfileEditForm = ({
  currentProfile,
  onSuccess,
}: UseProfileEditFormProps) => {
  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<ProfileFormValues>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      displayName: currentProfile.displayName,
      bio: currentProfile.bio,
    },
  });

  const [updateMyProfile, { isLoading, isSuccess, isError, error }] =
    useUpdateMyProfileMutation();
  const [selectedFile, setSelectedFile] = useState<File | null>(null);

  useEffect(() => {
    if (isSuccess) {
      onSuccess();
    }
    if (isError) {
      console.error('Profile update failed:', error);
    }
  }, [isSuccess, isError, onSuccess, error]);

  const onSubmit = async (data: ProfileFormValues) => {
    const payload: Partial<Profile> & { pictureFile?: File } = {
      displayName: data.displayName,
      bio: data.bio === '' ? null : data.bio,
    };

    if (selectedFile) {
      payload.pictureFile = selectedFile;
    }

    try {
      await updateMyProfile(payload).unwrap();
    } catch (err) {
      // Error handled by useEffect
    }
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setSelectedFile(e.target.files[0]);
    } else {
      setSelectedFile(null);
    }
  };

  return {
    form: {
      register,
      handleSubmit,
      errors,
    },
    submission: {
      onSubmit,
      isLoading,
    },
    file: {
      selectedFile,
      handleFileChange,
    },
  };
};

---


### FILE: frontend/src/features/profile/hooks/useProfilePage.ts ###
import { useState } from 'react';
import { useParams } from 'react-router-dom';
import { useAuth } from '../../auth/hooks/useAuth';
import { useGetProfileByUserIdQuery } from '../services/profileApi';
import { useGetPostsInfiniteQuery } from '../../posts/services/postsApi';
import { useGetCommentsInfiniteQuery } from '../../comments/services/commentsApi';

export const useProfile = () => {
  const { userId } = useParams<{ userId: string }>();
  const parsedUserId = Number(userId);

  const {
    data: profileResponse,
    isLoading,
    error,
    refetch,
  } = useGetProfileByUserIdQuery(parsedUserId);
  const { user: currentUser } = useAuth();

  const profile = profileResponse?.data;
  const isMyProfile = currentUser?.id === parsedUserId;

  const [isEditing, setIsEditing] = useState(false);
  const [activeTab, setActiveTab] = useState<'posts' | 'comments'>('posts');

  const handleEditSuccess = () => {
    setIsEditing(false);
    refetch();
  };

  const handleEditCancel = () => {
    setIsEditing(false);
  };

  // Fetch Posts by User
  const {
    data: postsData,
    fetchNextPage: fetchNextPostsPage,
    hasNextPage: hasNextPostsPage,
    isFetchingNextPage: isFetchingNextPostsPage,
    isLoading: isLoadingPosts,
  } = useGetPostsInfiniteQuery({ authorId: parsedUserId });

  const posts = postsData?.pages.flatMap((page) => page.data) ?? [];

  // Fetch Comments by User
  const {
    data: commentsData,
    fetchNextPage: fetchNextCommentsPage,
    hasNextPage: hasNextCommentsPage,
    isFetchingNextPage: isFetchingNextCommentsPage,
    isLoading: isLoadingComments,
  } = useGetCommentsInfiniteQuery({ authorId: parsedUserId });

  const comments = commentsData?.pages.flatMap((page) => page.data) ?? [];

  let errorMessage: string | null = null;
  if (error) {
    if ('status' in error && 'data' in error) {
      if (
        typeof error.data === 'object' &&
        error.data !== null &&
        'message' in error.data
      ) {
        errorMessage = (error.data as { message: string }).message;
      }
    } else if ('message' in error) {
      errorMessage = error.message ?? null;
    } else {
      errorMessage = 'Failed to load profile';
    }
  }

  return {
    profile,
    isLoading,
    error: errorMessage,
    isMyProfile,
    isEditing,
    setIsEditing,
    activeTab,
    setActiveTab,
    handleEditSuccess,
    handleEditCancel,
    posts: {
      data: posts,
      fetchNextPage: fetchNextPostsPage,
      hasNextPage: hasNextPostsPage,
      isFetchingNextPage: isFetchingNextPostsPage,
      isLoading: isLoadingPosts,
      total: postsData?.pages[0]?.meta?.totalItems ?? 0,
    },
    comments: {
      data: comments,
      fetchNextPage: fetchNextCommentsPage,
      hasNextPage: hasNextCommentsPage,
      isFetchingNextPage: isFetchingNextCommentsPage,
      isLoading: isLoadingComments,
      total: commentsData?.pages[0]?.meta?.totalItems ?? 0,
    },
  };
};

---


### FILE: frontend/src/features/community-restrictions/types.ts ###
// Enum compatible with React/TS
export const CommunityRestrictionType = {
  BAN: 'ban',
  MUTE: 'mute',
} as const;

export type CommunityRestrictionType = typeof CommunityRestrictionType[keyof typeof CommunityRestrictionType];

// Define a basic User interface for the frontend (copied from community-membership-requests/types.ts)
export interface User {
  id: number;
  name: string;
  email: string;
  // Add other user properties if needed from UserResponseDto
}

// Interface for a Community Restriction (matches backend DTO)
export interface CommunityRestriction {
  id: number;
  communityId: number;
  userId: number;
  user: User; // Add the user object
  createdById: number;
  restrictionType: CommunityRestrictionType;
  reason?: string;
  expiresAt?: string | null; // ISO string or null
  createdAt: string;          // ISO string
}

// DTO for creating a community restriction
export interface CreateCommunityRestrictionDto {
  communityId: number;
  userId: number;
  restrictionType: CommunityRestrictionType;
  reason?: string;
  expiresAt?: string; // ISO string
}

// DTO for updating a community restriction
export interface UpdateCommunityRestrictionDto {
  restrictionType?: CommunityRestrictionType;
  reason?: string;
  expiresAt?: string; // ISO string
}

// Query parameters for fetching community restrictions
export interface CommunityRestrictionQueryDto{
  page?: number;
  limit?: number;
  communityId?: number;
  userId?: number;
  restrictionType?: CommunityRestrictionType;
}

---


### FILE: frontend/src/features/community-restrictions/pages/RestrictedUsersPage.tsx ###
import { useState } from 'react';
import { useParams } from 'react-router-dom';
import { Button } from '../../../shared/components/ui/Button';
import { CommunityRestrictionType } from '../../community-restrictions/types';
import {
  useGetCommunityRestrictionsQuery,
  useDeleteCommunityRestrictionMutation,
} from '../../community-restrictions/services/communityRestrictionsApi.ts';
import { Modal } from '../../../shared/components/ui/Modal';
import { CreateRestrictionForm } from '../../community-restrictions/components/CreateRestrictionForm';

export const RestrictedUsersPage = () => {
  const { communityId } = useParams<{ communityId: string }>();
  const { data: response, isLoading, refetch } = useGetCommunityRestrictionsQuery({
    communityId: Number(communityId),
    page: 1,
    limit: 50,
  });
  const [removeRestriction] = useDeleteCommunityRestrictionMutation();
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleRestrictionCreated = () => {
    setIsModalOpen(false);
    refetch(); // Refetch restrictions to update the list
  };

  if (isLoading) return <div className="p-4">Loading restricted users...</div>;

  const restrictions = response?.data ?? [];

  return (
    <div className="max-w-4xl mx-auto">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-2xl font-bold">Restricted Users</h2>
        <Button onClick={() => setIsModalOpen(true)}>Create Restriction</Button>
      </div>

      {restrictions.length === 0 ? (
        <div className="text-center py-10 bg-gray-50 rounded-lg border">
          <p className="text-gray-500 italic">No users are currently restricted.</p>
        </div>
      ) : (
        <div className="space-y-3">
          {restrictions.map((r) => (
            <div
              key={r.id}
              className="flex justify-between items-center p-4 bg-white rounded-lg border border-gray-200"
            >
              <div>
                <span className="font-medium text-gray-900 text-lg">User #{r.userId}</span>
                <p className="text-sm text-gray-500">
                  Restriction: {r.restrictionType === CommunityRestrictionType.BAN ? 'Ban' : 'Mute'}
                </p>
                {r.reason && <p className="text-xs italic text-gray-400">Reason: {r.reason}</p>}
                <p className="text-xs text-gray-400">
                  Expires: {r.expiresAt ? new Date(r.expiresAt).toLocaleString() : 'Never'}
                </p>
              </div>
              <div>
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => removeRestriction(r.id)}
                  className="text-red-600 border-red-600 hover:bg-red-50"
                >
                  Remove Restriction
                </Button>
              </div>
            </div>
          ))}
        </div>
      )}

      <Modal  open={isModalOpen} onClose={() => setIsModalOpen(false)}>
        <CreateRestrictionForm
          communityId={Number(communityId)}
          onSuccess={handleRestrictionCreated}
          onCancel={() => setIsModalOpen(false)}
        />
      </Modal>
    </div>
  );
};

---


### FILE: frontend/src/features/community-restrictions/pages/ModRestrictionsPage.tsx ###
import { useState } from 'react';
import { BannedUsersQueue } from '../components/BannedUsersQueue';
import { MutedUsersQueue } from '../components/MutedUsersQueue'; // Will create this next

export const ModRestrictionsPage = () => {
  const [activeTab, setActiveTab] = useState('banned-users');

  return (
    <div className="max-w-4xl mx-auto">
      <h2 className="text-2xl font-bold mb-6">Moderation Restrictions</h2>

      <div className="border-b border-gray-200">
        <nav className="-mb-px flex space-x-8" aria-label="Tabs">
          <button
            onClick={() => setActiveTab('banned-users')}
            className={`${
              activeTab === 'banned-users'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
            } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm`}
          >
            Banned Users
          </button>
          <button
            onClick={() => setActiveTab('muted-users')}
            className={`${
              activeTab === 'muted-users'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
            } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm`}
          >
            Muted Users
          </button>
        </nav>
      </div>

      <div className="py-6">
        {activeTab === 'banned-users' && <BannedUsersQueue />}
        {activeTab === 'muted-users' && <MutedUsersQueue />}
      </div>
    </div>
  );
};

---


### FILE: frontend/src/features/community-restrictions/components/CreateRestrictionForm.tsx ###
import { CommunityRestrictionType } from '../types';
import { Button } from '../../../shared/components/ui/Button';
import { Input } from '../../../shared/components/ui/Input';
import { Label } from '../../../shared/components/ui/Label';
import { Select, type SelectOption } from '../../../shared/components/ui/Select';
import SearchableSelect from '../../../shared/components/ui/SearchableSelect';
import { Textarea } from '../../../shared/components/ui/TextArea';
import { useCreateRestriction } from '../hooks/useCreateRestriction';

interface CreateRestrictionFormProps {
  communityId: number;
  onSuccess: () => void;
  onCancel: () => void;
}

interface SearchableUser {
  id: number;
  label: string;
}

export const CreateRestrictionForm = ({
  communityId,
  onSuccess,
  onCancel,
}: CreateRestrictionFormProps) => {
  const { form, members, submission } = useCreateRestriction({
    communityId,
    onSuccess,
  });
  const {
    selectedUser,
    setSelectedUser,
    userSearchTerm,
    setUserSearchTerm,
    restrictionType,
    setRestrictionType,
    reason,
    setReason,
    expiresAt,
    setExpiresAt,
    formError,
  } = form;
  const { isLoadingMembers, filteredMembers } = members;
  const { handleSubmit, isCreating } = submission;

  if (isLoadingMembers) {
    return <div className="p-4">Loading members...</div>;
  }

  const restrictionTypeOptions: SelectOption[] = [
    { value: CommunityRestrictionType.BAN, label: 'Ban' },
    { value: CommunityRestrictionType.MUTE, label: 'Mute' },
  ];

  return (
    <form onSubmit={handleSubmit}>
      <div className="space-y-4">
        <div>
          <Label htmlFor="user-select">User</Label>
          <SearchableSelect<SearchableUser>
            value={selectedUser ? selectedUser.label : userSearchTerm}
            onSearch={setUserSearchTerm}
            options={filteredMembers}
            onSelect={(user) => {
              setSelectedUser(user);
              setUserSearchTerm(user.label); // Keep the selected user's label in the input
            }}
            getLabel={(user) => user.label}
            placeholder="Search for a user"
            loading={isLoadingMembers}
          />
        </div>

        <div>
          <Label htmlFor="restriction-type-select">Restriction Type</Label>
          <Select
            id="restriction-type-select"
            value={restrictionType}
            onChange={(value) =>
              setRestrictionType(value as CommunityRestrictionType)
            }
            className="w-full"
            options={restrictionTypeOptions}
          />
        </div>

        <div>
          <Label htmlFor="reason">Reason</Label>
          <Textarea
            id="reason"
            value={reason}
            onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
              setReason(e.target.value)
            }
            placeholder="Reason for restriction (optional)"
            className="w-full"
            rows={3}
          />
        </div>

        <div>
          <Label htmlFor="expires-at">Expires At (optional)</Label>
          <Input
            type="datetime-local"
            id="expires-at"
            value={expiresAt}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
              setExpiresAt(e.target.value)
            }
            className="w-full"
          />
        </div>

        {formError && <p className="text-red-500 text-sm">{formError}</p>}

        <div className="flex justify-end space-x-2">
          <Button
            type="button"
            variant="outline"
            onClick={onCancel}
            disabled={isCreating}
          >
            Cancel
          </Button>
          <Button type="submit" disabled={isCreating}>
            {isCreating ? 'Creating...' : 'Create'}
          </Button>
        </div>
      </div>
    </form>
  );
};

---


### FILE: frontend/src/features/community-restrictions/components/MutedUsersQueue.tsx ###
import { Button } from "../../../shared/components/ui/Button";
import { useMutedUsers } from "../hooks/useMutedUsers";

export const MutedUsersQueue = () => {
  const { mutedUsers, isLoading, unmuteUser } = useMutedUsers();

  if (isLoading) return <div className="p-4">Loading muted users...</div>;

  return (
    <div className="space-y-3">
      {mutedUsers.length === 0 ? (
        <div className="text-center py-10 bg-gray-50 rounded-lg border">
          <p className="text-gray-500 italic">
            No muted users in this community.
          </p>
        </div>
      ) : (
        mutedUsers.map((restriction) => (
          <div
            key={restriction.id}
            className="flex justify-between items-center p-4 bg-white rounded-lg border border-gray-200"
          >
            <div>
              <p className="font-medium text-gray-900 text-lg">
                {restriction.user.username}
              </p>
              <p className="text-sm text-gray-700">{restriction.reason}</p>
              <p className="text-xs text-gray-500 italic">
                Muted on {new Date(restriction.createdAt).toLocaleDateString()}
                {restriction.expiresAt &&
                  ` - Expires on ${new Date(
                    restriction.expiresAt
                  ).toLocaleDateString()}`}
              </p>
            </div>
            <div className="flex gap-2">
              <Button
                size="sm"
                onClick={() => unmuteUser(restriction.id)}
                className="bg-green-600 hover:bg-green-700"
              >
                Unmute
              </Button>
            </div>
          </div>
        ))
      )}
    </div>
  );
};

---


### FILE: frontend/src/features/community-restrictions/components/BannedUsersQueue.tsx ###
import { Button } from "../../../shared/components/ui/Button";
import { useBannedUsers } from "../hooks/useBannedUsers";

export const BannedUsersQueue = () => {
  const { bannedUsers, isLoading, unbanUser } = useBannedUsers();

  if (isLoading) return <div className="p-4">Loading banned users...</div>;

  return (
    <div className="space-y-3">
      {bannedUsers.length === 0 ? (
        <div className="text-center py-10 bg-gray-50 rounded-lg border">
          <p className="text-gray-500 italic">
            No banned users in this community.
          </p>
        </div>
      ) : (
        bannedUsers.map((restriction) => (
          <div
            key={restriction.id}
            className="flex justify-between items-center p-4 bg-white rounded-lg border border-gray-200"
          >
            <div>
              <p className="font-medium text-gray-900 text-lg">
                {restriction.user.username}
              </p>
              <p className="text-sm text-gray-700">{restriction.reason}</p>
              <p className="text-xs text-gray-500 italic">
                Banned on {new Date(restriction.createdAt).toLocaleDateString()}
                {restriction.expiresAt &&
                  ` - Expires on ${new Date(
                    restriction.expiresAt
                  ).toLocaleDateString()}`}
              </p>
            </div>
            <div className="flex gap-2">
              <Button
                size="sm"
                onClick={() => unbanUser(restriction.id)}
                className="bg-red-600 hover:bg-red-700"
              >
                Unban
              </Button>
            </div>
          </div>
        ))
      )}
    </div>
  );
};

---


### FILE: frontend/src/features/community-restrictions/services/communityRestrictionsApi.ts ###
import { apiSlice } from "../../../shared/services/apiSlice";
import type { ResponseDto } from "../../auth/types";
import type {
  CommunityRestriction,
  CreateCommunityRestrictionDto,
  UpdateCommunityRestrictionDto,
  CommunityRestrictionQueryDto,
} from "../types";

export const communityRestrictionsApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    // Fetch restrictions (supports query params)
    getCommunityRestrictions: builder.query<
      ResponseDto<CommunityRestriction[]>,
      CommunityRestrictionQueryDto
    >({
      query: (params) => ({
        url: `/community-restrictions`,
        params,
      }),
      providesTags: ['CommunityRestrictions'],
    }),

    // Create a restriction
    createCommunityRestriction: builder.mutation<
      ResponseDto<CommunityRestriction>,
      CreateCommunityRestrictionDto
    >({
      query: (body) => ({
        url: `/community-restrictions`,
        method: 'POST',
        body,
      }),
      invalidatesTags: ['CommunityRestrictions'],
    }),

    // Update a restriction
    updateCommunityRestriction: builder.mutation<
      ResponseDto<CommunityRestriction>,
      { id: number; body: UpdateCommunityRestrictionDto }
    >({
      query: ({ id, body }) => ({
        url: `/community-restrictions/${id}`,
        method: 'PATCH',
        body,
      }),
      invalidatesTags: ['CommunityRestrictions'],
    }),

    // Delete a restriction
    deleteCommunityRestriction: builder.mutation<
      ResponseDto<boolean>,
      number // id
    >({
      query: (id) => ({
        url: `/community-restrictions/${id}`,
        method: 'DELETE',
      }),
      invalidatesTags: ['CommunityRestrictions'],
    }),
  }),
});

export const {
  useGetCommunityRestrictionsQuery,
  useCreateCommunityRestrictionMutation,
  useUpdateCommunityRestrictionMutation,
  useDeleteCommunityRestrictionMutation,
} = communityRestrictionsApi;

---


### FILE: frontend/src/features/community-restrictions/hooks/useCreateRestriction.ts ###
import { useState } from 'react';
import { CommunityRestrictionType } from '../types';
import { useGetCommunityMembershipsQuery } from '../../community-memberships/services/communityMembershipsApi';
import type { CommunityMembershipQueryDto } from '../../community-memberships/types';
import { useCreateCommunityRestrictionMutation } from '../services/communityRestrictionsApi';

interface UseCreateRestrictionProps {
  communityId: number;
  onSuccess: () => void;
}

interface SearchableUser {
  id: number;
  label: string;
}

export const useCreateRestriction = ({
  communityId,
  onSuccess,
}: UseCreateRestrictionProps) => {
  const [selectedUser, setSelectedUser] = useState<SearchableUser | null>(null);
  const [userSearchTerm, setUserSearchTerm] = useState<string>('');
  const [restrictionType, setRestrictionType] =
    useState<CommunityRestrictionType>(CommunityRestrictionType.BAN);
  const [reason, setReason] = useState<string>('');
  const [expiresAt, setExpiresAt] = useState<string>('');
  const [formError, setFormError] = useState<string | null>(null);

  const communityMembershipsQueryParams: CommunityMembershipQueryDto = {
    communityId: communityId,
    limit: 100,
  };
  const { data: membersResponse, isLoading: isLoadingMembers } =
    useGetCommunityMembershipsQuery(communityMembershipsQueryParams);

  const [createRestriction, { isLoading: isCreating }] =
    useCreateCommunityRestrictionMutation();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setFormError(null);

    if (!selectedUser) {
      setFormError('Please select a user.');
      return;
    }

    try {
      await createRestriction({
        communityId,
        userId: selectedUser.id,
        restrictionType,
        reason: reason || undefined,
        expiresAt: expiresAt ? new Date(expiresAt).toISOString() : undefined,
      }).unwrap();
      onSuccess();
    } catch (err: any) {
      setFormError(err.data?.message || 'Failed to create restriction.');
    }
  };

  const allMembers = membersResponse?.data ?? [];
  const searchableMembers: SearchableUser[] = allMembers.map((member) => ({
    id: member.userId,
    label: member.user.username,
  }));

  const filteredMembers = searchableMembers.filter((member) =>
    member.label.toLowerCase().includes(userSearchTerm.toLowerCase())
  );

  return {
    form: {
      selectedUser,
      setSelectedUser,
      userSearchTerm,
      setUserSearchTerm,
      restrictionType,
      setRestrictionType,
      reason,
      setReason,
      expiresAt,
      setExpiresAt,
      formError,
    },
    members: {
      isLoadingMembers,
      filteredMembers,
    },
    submission: {
      handleSubmit,
      isCreating,
    },
  };
};

---


### FILE: frontend/src/features/community-restrictions/hooks/useMutedUsers.ts ###
import { useParams } from 'react-router-dom';
import {
  useGetCommunityRestrictionsQuery,
  useDeleteCommunityRestrictionMutation,
} from '../services/communityRestrictionsApi';
import { CommunityRestrictionType } from '../types';

export const useMutedUsers = () => {
  const { communityId } = useParams();
  const { data: restrictions, isLoading } = useGetCommunityRestrictionsQuery({
    communityId: +communityId,
    restrictionType: CommunityRestrictionType.MUTE,
    page: 1,
    limit: 10,
  });
  const [unmute] = useDeleteCommunityRestrictionMutation();

  return {
    mutedUsers: restrictions?.data ?? [],
    isLoading,
    unmuteUser: unmute,
  };
};

---


### FILE: frontend/src/features/community-restrictions/hooks/useBannedUsers.ts ###
import { useParams } from 'react-router-dom';
import {
  useGetCommunityRestrictionsQuery,
  useDeleteCommunityRestrictionMutation,
} from '../services/communityRestrictionsApi';
import { CommunityRestrictionType } from '../types';

export const useBannedUsers = () => {
  const { communityId } = useParams();
  const { data: restrictions, isLoading } = useGetCommunityRestrictionsQuery({
    communityId: +communityId,
    restrictionType: CommunityRestrictionType.BAN,
    page: 1,
    limit: 10,
  });
  const [unban] = useDeleteCommunityRestrictionMutation();

  return {
    bannedUsers: restrictions?.data ?? [],
    isLoading,
    unbanUser: unban,
  };
};

---


### FILE: frontend/src/features/comments/types.ts ###
import type { Post } from "../posts/types";
import type { ReactionType } from "../reactions/types/types";

export interface Comment {
    id: number;
    content: string;
    author: {
        id: number;
        username: string;
    };
    postId: number;
    parentId?: number; // For replies
    likesCount: number;
    dislikesCount: number;
    repliesCount: number;
    userReaction?: { id: number; type: ReactionType } | null;
    replies?: Comment[]; // Added for nested replies
    post?: Post; // Re-added for UserCommentCard

    createdAt: string;
    updatedAt: string;
}

export interface CreateCommentDto {
    content: string;
    parentId?: number;
}

export interface UpdateCommentDto {
    content: string;
}

export interface CommentQueryDto {
    page?: number;
    limit?: number;
    postId?: number;
    authorId?: number;
    parentId?: number;
}

export interface PaginatedResponse<T> {
    data: T[];
    meta: {
        page: number;
        limit: number;
        totalItems: number;

        totalPages: number;

        itemCount: number;
    };
}

export interface ResponseDto<T> {
    data: T;
    message: string;
}

---


### FILE: frontend/src/features/comments/components/CommentInput.tsx ###
import React from 'react';
import { Button } from '../../../shared/components/ui/Button';
import { Textarea } from '../../../shared/components/ui/TextArea';
import { useComments } from '../hooks/useComments';

interface CommentInputProps {
  postId: number;
  parentId?: number;
  onCommentPosted?: () => void;
  onCancel?: () => void;
  autoFocus?: boolean;
  initialContent?: string;
}

export const CommentInput: React.FC<CommentInputProps> = ({
  postId,
  parentId,
  onCommentPosted,
  onCancel,
  autoFocus = false,
  initialContent = '',
}) => {
  const { content, setContent, handleCreateComment, isCreating } = useComments({
    postId,
    parentId,
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    handleCreateComment(onCommentPosted, content || initialContent);
  };

  return (
    <form onSubmit={handleSubmit} className="mt-4">
      <Textarea
        rows={parentId ? 2 : 4} // Smaller for replies
        placeholder={parentId ? 'Write a reply...' : 'Write a comment...'}
        value={content || initialContent}
        onChange={(e) => setContent(e.target.value)}
        autoFocus={autoFocus}
      />
      <div className="flex justify-end space-x-2 mt-2">
        {onCancel && (
          <Button type="button" variant="ghost" onClick={onCancel}>
            Cancel
          </Button>
        )}
        <Button type="submit" disabled={isCreating}>
          {isCreating ? 'Replying...' : parentId ? 'Reply' : 'Comment'}
        </Button>
      </div>
    </form>
  );
};
---


### FILE: frontend/src/features/comments/components/CommentCard.tsx ###
import { FaUser, FaReply } from 'react-icons/fa';
import type { Comment } from '../types';
import { CommentReactionButtons } from '../../reactions/components/CommentReactionButtons';
import { Button } from '../../../shared/components/ui/Button';
import { CommentInput } from './CommentInput';
import { timeAgo } from '../../../shared/utils/date';
import { useCommentCard } from '../hooks/useCommentCard';

interface CommentCardProps {
  comment: Comment;
  postId: number;
  level: number;
}

const CommentCard: React.FC<CommentCardProps> = ({
  comment,
  postId,
  level,
}) => {
  const {
    showReplies,
    setShowReplies,
    showReplyInput,
    setShowReplyInput,
    allReplies,
    remainingReplies,
    handleReplyPosted,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    shouldRender,
  } = useCommentCard({ comment, postId, level });

  if (!shouldRender) {
    return null;
  }

  return (
    <div className="mb-3">
      {/* COMMENT CARD */}
      <div className="rounded-lg border border-gray-300 bg-white p-4 ">
        <div className="mb-2 flex items-center text-sm text-gray-500">
          <FaUser className="mr-1" />
          <span>u/{comment.author.username}</span>
          <span className="mx-1">‚Ä¢</span>
          <span className="text-xs">{timeAgo(comment.createdAt)}</span>
        </div>

        {/* DEBUG */}
        <div className="mb-1 text-xs text-gray-400">
          id: {comment.id}, parentId: {comment.parentId ?? 'null'}
          {showReplies ? ' 1' : ' 0'}
        </div>

        <p className="mb-3 text-sm text-gray-800">{comment.content}</p>

        <div className="flex items-center space-x-4 text-xs text-gray-500">
          <CommentReactionButtons comment={comment} />

          <button
            onClick={() => setShowReplyInput((v) => !v)}
            className="flex items-center space-x-1 hover:text-primary-600"
          >
            <FaReply />
            <span>Reply</span>
          </button>

          {comment.repliesCount > 0 && (
            <Button onClick={() => setShowReplies((v) => !v)} variant="link">
              {showReplies
                ? `Hide replies (${comment.repliesCount})`
                : remainingReplies > 0
                ? `+ Load replies (${remainingReplies} remaining)`
                : `View replies (${comment.repliesCount})`}
            </Button>
          )}
        </div>
      </div>

      {showReplyInput && (
        <div className="mt-3 ml-6 border-l border-gray-200 pl-4">
          <CommentInput
            postId={postId}
            parentId={comment.id}
            onCommentPosted={handleReplyPosted}
            onCancel={() => setShowReplyInput(false)}
            autoFocus
          />
        </div>
      )}

      {/* REPLIES */}
      {showReplies && allReplies.length > 0 && (
        <div className="mt-3 ml-6 border-l border-gray-200 pl-4">
          {allReplies.map((reply) => (
            <CommentCard
              key={reply.id}
              comment={reply}
              postId={postId}
              level={level + 1}
            />
          ))}
        </div>
      )}

      {showReplies && hasNextPage && (
        <div className="flex justify-center mt-2 ml-6">
          <Button variant="link" onClick={fetchNextPage} disabled={isFetchingNextPage}>
            {isFetchingNextPage
              ? 'Loading more replies‚Ä¶'
              : '+ Load more replies'}
          </Button>
        </div>
      )}
    </div>
  );
};

export default CommentCard;

---


### FILE: frontend/src/features/comments/components/UserCommentList.tsx ###
import { Button } from '../../../shared/components/ui/Button';
import UserCommentCard from './UserCommentCard'; // Import the new UserCommentCard
import type { Comment } from '../types'; // Import Comment type

interface UserCommentListProps {
    comments: Comment[]; // Accept comments as a prop
    fetchNextPage: () => void;
    hasNextPage: boolean;
    isFetchingNextPage: boolean;
    isLoading?: boolean; // Optional loading state from parent
}

const UserCommentList: React.FC<UserCommentListProps> = ({
    comments,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
}) => {
    if (isLoading) return <div>Loading comments...</div>;

    return (
        <div className="space-y-4">
            {comments.length === 0 ? (
                <p>No comments found.</p>
            ) : (
                comments.map((comment) => (
                    // Render UserCommentCard instead of CommentCard
                    <UserCommentCard key={comment.id} comment={comment} />
                ))
            )}
            {hasNextPage && (
                <div className="flex justify-center mt-4">
                    <Button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>
                        {isFetchingNextPage ? 'Loading more...' : 'Load More Comments'}
                    </Button>
                </div>
            )}
        </div>
    );
};

export default UserCommentList;

---


### FILE: frontend/src/features/comments/components/CommentList.tsx ###
import type { Comment } from '../types';
import { Button } from '../../../shared/components/ui/Button';
import CommentCard from './CommentCard';
import { useComments } from '../hooks/useComments';

interface CommentListProps {
  postId: number;
}

const CommentList: React.FC<CommentListProps> = ({ postId }) => {
  const {
    comments,
    isLoadingComments,
    pagination: { fetchNextPage, hasNextPage, isFetchingNextPage },
  } = useComments({ postId });

  if (isLoadingComments && !comments.length)
    return <div>Loading comments...</div>;

  return (
    <div className="space-y-4">
      {comments.length === 0 ? (
        <p>No comments found.</p>
      ) : (
        comments.map((comment: Comment) => (
          <CommentCard
            key={comment.id}
            comment={comment}
            level={0}
            postId={comment.postId}
          />
        ))
      )}
      {hasNextPage && (
        <div className="flex justify-center mt-4">
          <Button onClick={fetchNextPage} disabled={isFetchingNextPage}>
            {isFetchingNextPage ? 'Loading more...' : 'Load More Comments'}
          </Button>
        </div>
      )}
    </div>
  );
};

export default CommentList;

---


### FILE: frontend/src/features/comments/components/UserCommentCard.tsx ###
import React from 'react';
import { useNavigate } from 'react-router-dom';
import type { Comment } from '../types';
import { FaUser, FaQuoteLeft } from 'react-icons/fa';
import { timeAgo } from '../../../shared/utils/date';

interface UserCommentCardProps {
  comment: Comment;
}

const UserCommentCard: React.FC<UserCommentCardProps> = ({ comment }) => {
  const navigate = useNavigate();
  console.log(comment.post);
  
  const handleCardClick = () => {
    if (comment.post?.id) {
      navigate(`/posts/${comment.post.id}`);
    }
  };

  return (
    <div
      className="mb-3 cursor-pointer rounded-lg border border-gray-300 bg-white p-4 hover:bg-gray-50 transition-colors duration-150 ease-in-out"
      onClick={handleCardClick}
    >
      <div className="mb-2 flex items-center text-sm text-gray-500">
        <FaUser className="mr-1" />
        <span>u/{comment.author.username}</span>
        <span className="mx-1">‚Ä¢</span>
        <span className="text-xs">
          {timeAgo(comment.createdAt)}
        </span>
        {comment.post && (
          <>
            <span className="mx-1">‚Ä¢</span>
            <FaQuoteLeft className="mr-1 text-xs" />
            <span className="text-xs font-semibold">
              on "{comment.post.title}"
              {comment.post.community && ` in c/${comment.post.community.name}`}
            </span>
          </>
        )}
      </div>

      <p className="mb-3 text-sm text-gray-800 line-clamp-2">
        {comment.content}
      </p>

      {/* No reply buttons or reaction buttons here, just a simple display */}
    </div>
  );
};

export default UserCommentCard;

---


### FILE: frontend/src/features/comments/services/commentsApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { Comment, CreateCommentDto, UpdateCommentDto, CommentQueryDto, PaginatedResponse, ResponseDto } from '../types';

export const commentsApi = apiSlice.injectEndpoints({
    overrideExisting: false, // Ensure this is not overriding existing endpoints
    endpoints: (builder) => ({
        getComments: builder.infiniteQuery<
            PaginatedResponse<Comment>,
            CommentQueryDto, // Simplified type parameter
            number
        >({
            infiniteQueryOptions: {
                initialPageParam: 1,
                getNextPageParam: (lastPage) => {
                    const { page, totalPages } = lastPage.meta;
                    return page < totalPages ? page + 1 : undefined;
                },
            },
            query: ({ queryArg, pageParam }) => ({
                url: `/comments`,
                params: {
                    ...queryArg, // Pass other query arguments
                    page: pageParam, // Explicitly use pageParam for the page number
                    limit: queryArg?.limit ?? 10,
                },
            }),
           
            providesTags: ["Comments"],
        }),
        createComment: builder.mutation<ResponseDto<Comment>, { postId: number; data: CreateCommentDto }>({
            query: ({ postId, data }) => ({
                url: `/posts/${postId}/comments`,
                method: 'POST',
                body: data,
            }),
            invalidatesTags: ['Comments',"Posts"],
        }),
        updateComment: builder.mutation<ResponseDto<Comment>, { id: number; data: UpdateCommentDto }>({
            query: ({ id, data }) => ({
                url: `/comments/${id}`,
                method: 'PATCH',
                body: data,
            }),
            invalidatesTags: ['Comments',"Posts"],
        }),
        deleteComment: builder.mutation<ResponseDto<boolean>, number>({
            query: (id) => ({
                url: `/comments/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: ['Comments',"Posts"],
        }),
    }),
});

export const {
    useGetCommentsInfiniteQuery, // RENAMED EXPORT
    useCreateCommentMutation,
    useUpdateCommentMutation,
    useDeleteCommentMutation,
} = commentsApi;

---


### FILE: frontend/src/features/comments/hooks/useCommentCard.ts ###
import { useState, useMemo, useEffect } from 'react';
import type { Comment } from '../types';
import { useGetCommentsInfiniteQuery } from '../services/commentsApi';

const REPLIES_LIMIT = 2;
const MAX_DEPTH = 5;

interface UseCommentCardProps {
  comment: Comment;
  postId: number;
  level: number;
}

export const useCommentCard = ({
  comment,
  postId,
  level,
}: UseCommentCardProps) => {
  const [showReplies, setShowReplies] = useState(false);
  useEffect(() => {
    if (comment.repliesCount > 0) {
      setShowReplies(true);
    }
  }, [comment.repliesCount]);

  const [showReplyInput, setShowReplyInput] = useState(false);

  const initialReplies = comment.replies ?? [];
  const initialRepliesCount = initialReplies.length;
  const hasMoreRepliesThanInitial = comment.repliesCount > initialRepliesCount;

  const initialQueryPageParam = 1;

  const { data, fetchNextPage, hasNextPage, isFetchingNextPage } =
    useGetCommentsInfiniteQuery(
      { postId, parentId: comment.id, limit: REPLIES_LIMIT },
      {
        initialPageParam: initialQueryPageParam,
        skip: !showReplies || !hasMoreRepliesThanInitial,
      }
    );

  const allReplies = useMemo(() => {
    const fetchedReplies = data?.pages.flatMap((page) => page.data) || [];
    const combinedReplies = [...initialReplies, ...fetchedReplies];

    const map = new Map<number, Comment>();
    combinedReplies.forEach((reply) => map.set(reply.id, reply));

    return [...map.values()].sort(
      (a, b) =>
        new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
    );
  }, [initialReplies, data]);

  const remainingReplies = Math.max(0, comment.repliesCount - allReplies.length);

  const handleReplyPosted = () => {
    setShowReplyInput(false);
    // Rely on RTK Query cache invalidation for UI update
  };

  const shouldRender = level <= MAX_DEPTH;

  return {
    showReplies,
    setShowReplies,
    showReplyInput,
    setShowReplyInput,
    allReplies,
    remainingReplies,
    handleReplyPosted,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    shouldRender,
  };
};

---


### FILE: frontend/src/features/comments/hooks/useComments.ts ###
import { useState, useMemo } from 'react';
import {
  useCreateCommentMutation,
  useGetCommentsInfiniteQuery,
} from '../services/commentsApi';
import { useToastContext } from '../../../shared/providers/ToastProvider';

interface UseCommentsProps {
  postId: number;
  parentId?: number;
}

export const useComments = ({ postId, parentId }: UseCommentsProps) => {
  const [content, setContent] = useState('');
  const [createComment, { isLoading: isCreating }] = useCreateCommentMutation();
  const { showToast } = useToastContext();

  const {
    data: paginatedData,
    isLoading: isLoadingComments,
    isFetching: isFetchingComments,
    refetch,
    fetchNextPage, // Directly use fetchNextPage from the infinite query hook
    hasNextPage,
  } = useGetCommentsInfiniteQuery(
    { postId, parentId, limit: 10 }, // No 'page' in queryArg, it's handled by infiniteQuery
    {
      // pollingInterval: 30000,
      // refetchOnMountOrArgChange: true,
    }
  );

  const comments = useMemo(
    () => paginatedData?.pages.flatMap((page) => page.data) ?? [],
    [paginatedData?.pages]
  );
  const meta = useMemo(
    () => paginatedData?.pages[paginatedData.pages.length - 1]?.meta,
    [paginatedData?.pages]
  );

  const handleCreateComment = async (
    onCommentPosted?: () => void,
    commentContent?: string
  ) => {
    const finalContent = commentContent || content;
    if (!finalContent.trim()) {
      showToast('Comment cannot be empty', 'error');
      return;
    }

    try {
      await createComment({
        postId,
        data: { content: finalContent, parentId },
      }).unwrap();
      setContent('');
      showToast('Comment posted successfully', 'success');
      onCommentPosted?.();
      refetch();
    } catch (error: any) {
      const errorMessage =
        error.data?.message || error.message || 'Failed to post comment';
      showToast(errorMessage, 'error');
    }
  };

  return {
    content,
    setContent,
    handleCreateComment,
    isCreating,
    comments,
    isLoadingComments,
    isFetchingComments,
    refetchComments: refetch,
    pagination: {
      fetchNextPage, // Directly expose fetchNextPage
      hasNextPage,
      isFetchingNextPage: isFetchingComments && hasNextPage, // Adjusted logic for isFetchingNextPage
    },
  };
};

---


### FILE: frontend/src/App.tsx ###
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import AuthGuard from './features/auth/components/AuthGard';
import EmailVerification from './features/auth/pages/EmailVerification';
import Login from './features/auth/pages/Login';
import Register from './features/auth/pages/Register';
import VerificationResult from './features/auth/pages/VerificationResult';
import { CommunityPage } from './features/communities/pages/CommunityPage';
import ExploreCommunitiesPage from './features/communities/pages/ExploreCommunitiesPage';
import MyCommunitiesPage from './features/communities/pages/MyCommunitiesPage';
import FeedPage from './features/feed/pages/FeedPage';
import CreatePostPage from './features/posts/pages/CreatePostPage';
import PostDetailPage from './features/posts/pages/PostDetailPage';
import MainLayout from './layout/MainLayout';
import ModLayout from './layout/ModLayout';
import { ModQueuesPage } from './features/communities/pages/QueuesPage';
import { MembersPage } from './features/community-memberships/pages/MembersPage';
import { ModeratorsPage } from './features/community-memberships/pages/ModeratorsPage';
import { RestrictedUsersPage } from './features/community-restrictions/pages/RestrictedUsersPage';
import { ProfilePage } from './features/profile/pages/ProfilePage';
import { useAuth } from './features/auth/hooks/useAuth';
import SettingsPage from './features/settings/pages/SettingsPage';
import EmailChangeVerifyPage from './pages/EmailChangeVerifyPage';

const SessionLoader = ({ children }: { children: React.ReactNode }) => {
  const { isUserLoading } = useAuth();


  if (isUserLoading) {
    return <div>Loading session...</div>;
  }

  return <>{children}</>;
};


export default function App() {
  return (
    <BrowserRouter>
      <SessionLoader>
        <Routes>
          {/* --- Public Auth Routes (No Sidebars) --- */}
          <Route path="/login" element={<Login />} />
          <Route path="/register" element={<Register />} />
          <Route path="/email-verification" element={<EmailVerification />} />
          <Route path="/verify-email" element={<VerificationResult />} />
          <Route path="/email/change/verify" element={<EmailChangeVerifyPage />} />

          {/* --- Standard User Routes (with LeftSidebar) --- */}
          <Route element={<MainLayout />}>
            <Route path="/" element={<AuthGuard><FeedPage /></AuthGuard>} />
            <Route path="/posts/:id" element={<AuthGuard><PostDetailPage /></AuthGuard>} />
            <Route path="/submit" element={<AuthGuard><CreatePostPage /></AuthGuard>} />
            <Route path="/communities/:communityId" element={<AuthGuard><CommunityPage /></AuthGuard>} />
            <Route path="/my-communities" element={<AuthGuard><MyCommunitiesPage /></AuthGuard>} />
            <Route path="/explore-communities" element={<AuthGuard><ExploreCommunitiesPage /></AuthGuard>} />
            <Route path="/profile/:userId" element={<AuthGuard><ProfilePage /></AuthGuard>} /> {/* Changed Route */}
            <Route path="/settings" element={<AuthGuard><SettingsPage /></AuthGuard>} />
          </Route>

          {/* --- Moderation Routes (with ModSidebar) --- */}
          <Route path="/mod/community/:communityId" element={<AuthGuard><ModLayout /></AuthGuard>}>
            <Route index element={<Navigate to="queues" replace />} />
            <Route path="queues" element={<ModQueuesPage />} />
            <Route path="members" element={<MembersPage />} />
            <Route path="moderators" element={<ModeratorsPage />} />
            <Route path="restricted-users" element={<RestrictedUsersPage />} /> {/* New Route */}
          </Route>
        </Routes>
      </SessionLoader>
    </BrowserRouter>
  );
}
---


### FILE: frontend/src/shared/providers/ToastProvider.tsx ###
import React, { createContext, useContext } from 'react';
import { useToast, type ToastData } from '../hooks/useToast';
import  Toast from '../components/ui/Toast';

interface ToastContextType {
  showToast: (message: string, type: 'success' | 'error' | 'info') => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export const useToastContext = () => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToastContext must be used within a ToastProvider');
  }
  return context;
};

export const ToastProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {
  const { toast, showToast, hideToast } = useToast();

  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}
      {toast && (
        <Toast
          message={toast.message}
          type={toast.type}
          onClose={hideToast}
        />
      )}
    </ToastContext.Provider>
  );
};

---


### FILE: frontend/src/shared/components/ui/Label.tsx ###
import React from 'react';

export interface LabelProps
  extends React.LabelHTMLAttributes<HTMLLabelElement> {}

export const Label = React.forwardRef<
  HTMLLabelElement,
  LabelProps
>(({ className = '', ...props }, ref) => {
  return (
    <label
      ref={ref}
      className={`block text-sm font-medium text-gray-700 ${className}`}
      {...props}
    />
  );
});

Label.displayName = 'Label';

---


### FILE: frontend/src/shared/components/ui/InputError.tsx ###
import React from 'react';

export interface InputErrorProps
  extends React.HTMLAttributes<HTMLParagraphElement> {
  message?: string;
}

export const InputError = React.forwardRef<
  HTMLParagraphElement,
  InputErrorProps
>(({ message, className = '', ...props }, ref) => {
  if (!message) {
    return null;
  }
  return (
    <p
      ref={ref}
      className={`text-sm text-red-500 ${className}`}
      {...props}
    >
      {message}
    </p>
  );
});

InputError.displayName = 'InputError';

---


### FILE: frontend/src/shared/components/ui/Dropdown.tsx ###
import React, { useState, useRef, useEffect } from 'react';

interface DropdownProps {
  trigger: React.ReactNode;
  children: React.ReactNode;
  align?: 'left' | 'right';
  width?: '48';
}

const Dropdown: React.FC<DropdownProps> = ({
  trigger,
  children,
  align = 'right',
  width = '48',
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  const toggleOpen = () => {
    setIsOpen((prev) => !prev);
  };

  const close = () => {
    setIsOpen(false);
  };

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        close();
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const alignmentClasses = align === 'left' ? 'origin-top-left left-0' : 'origin-top-right right-0';
  const widthClasses = width === '48' ? 'w-48' : '';

  return (
    <div className="relative" ref={dropdownRef}>
      <div onClick={toggleOpen}>{trigger}</div>

      {isOpen && (
        <div
          className={`absolute z-50 mt-2 rounded-md shadow-lg ${alignmentClasses} ${widthClasses}`}
          onClick={close}
        >
          <div className="rounded-md ring-1 ring-gray-300  ring-opacity-5 bg-white dark:bg-gray-700">
            {children}
          </div>
        </div>
      )}
    </div>
  );
};

export default Dropdown;

---


### FILE: frontend/src/shared/components/ui/Select.tsx ###
import React, { useState, useRef, useEffect } from 'react';

export interface SelectOption {
  value: string | number;
  label: string;
  disabled?: boolean;
}

export interface SelectProps {
  options: SelectOption[];
  placeholder?: string;
  value?: string | number;
  onChange?: (value: string | number) => void;
  className?: string;
  id?: string; // if you need id
}

export const Select = React.forwardRef<HTMLDivElement, SelectProps>(
  ({ options, placeholder = 'Select...', value, onChange, className }, ref) => {
    const [open, setOpen] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);

    // Close dropdown on outside click
    useEffect(() => {
      const handleClickOutside = (e: MouseEvent) => {
        if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
          setOpen(false);
        }
      };
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const selectedLabel = options.find((o) => o.value === value)?.label;

    return (
      <div
        ref={(node) => {
          containerRef.current = node;
          if (ref && typeof ref === 'function') ref(node);
          else if (ref && 'current' in ref) ref.current = node;
        }}
        className={`relative w-full ${className}`}
      >
        {/* Button */}
        <button
          type="button"
          className="w-full text-left bg-white border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 flex justify-between items-center"
          onClick={() => setOpen((o) => !o)}
        >
          <span className={selectedLabel ? '' : 'text-gray-400'}>
            {selectedLabel || placeholder}
          </span>
          {/* Arrow */}
          <svg
            className={`w-4 h-4 transition-transform duration-150 ${open ? 'rotate-180' : ''}`}
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M6 8l4 4 4-4" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
          </svg>
        </button>

        {/* Dropdown */}
        {open && (
          <ul className="absolute z-50 mt-1 w-full bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-auto text-sm">
            {options.map((option) => (
              <li
                key={String(option.value)}
                className={`px-3 py-2 cursor-pointer hover:bg-blue-100 ${option.disabled ? 'text-gray-400 cursor-not-allowed' : ''
                  }`}
                onClick={() => {
                  if (!option.disabled && onChange) {
                    onChange(option.value); // use option.value directly
                    setOpen(false);
                  }
                }}

              >
                {option.label}
              </li>
            ))}
          </ul>
        )}
      </div>
    );
  }
);

Select.displayName = 'Select';

---


### FILE: frontend/src/shared/components/ui/Toast.tsx ###
import React, { useEffect } from 'react';

export type ToastType = 'success' | 'error' | 'info';

export interface ToastProps {
  message: string;
  type: ToastType;
  onClose: () => void;
}

const toastTypeClasses: Record<ToastType, string> = {
  success: 'bg-green-500/90',
  error: 'bg-red-500/90',
  info: 'bg-blue-500/90',
};

const Toast: React.FC<ToastProps> = ({ message, type, onClose }) => {
  useEffect(() => {
    const timer = setTimeout(onClose, 4000);
    return () => clearTimeout(timer);
  }, [onClose]);

  return (
    <div className="fixed top-6 left-1/2 -translate-x-1/2 z-50 animate-toast">
      <div
        className={`
          px-6 py-3 rounded-full text-sm font-medium text-white
          shadow-lg backdrop-blur
          ${toastTypeClasses[type]}
        `}
      >
        {message}
      </div>
    </div>
  );
};

export default Toast;

---


### FILE: frontend/src/shared/components/ui/TextArea.tsx ###
import React from 'react';

export interface TextareaClasses {
  base?: string;
}

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  classes?: TextareaClasses;
}

export const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  TextareaProps
>(
  (
    {
      classes = {},
      className = '',
      ...props
    },
    ref
  ) => {
    const classNames = [
      // ‚úÖ Tailwind default style
      'block w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm',
      'placeholder-gray-400 ',
      'focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500',
      'disabled:cursor-not-allowed disabled:opacity-50',
      'resize-y',

      // ‚úÖ overrides
      classes.base,
      className,
    ]
      .filter(Boolean)
      .join(' ');

    return (
      <textarea
        ref={ref}
        className={classNames}
        {...props}
      />
    );
  }
);

Textarea.displayName = 'Textarea';

---


### FILE: frontend/src/shared/components/ui/Button.tsx ###
import React from 'react';

export type ButtonVariant = 'default' | 'outline' | 'ghost' | 'destructive' | 'secondary' | 'link' | 'icon';
export type ButtonSize = 'sm' | 'md' | 'lg';

export interface ButtonClasses {
  base?: string;
  variant?: Partial<Record<ButtonVariant, string>>;
  size?: Partial<Record<ButtonSize, string>>;
}

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
  classes?: ButtonClasses;
}

export const Button = React.forwardRef<
  HTMLButtonElement,
  ButtonProps
>(
  (
    {
      variant = 'default',
      size = 'md',
      classes = {},
      className = '',
      ...props
    },
    ref
  ) => {
    const defaultClasses = {
      base: 'inline-flex font-medium items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background',
      variant: {
        default: 'bg-primary-600 text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary-100 text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'underline-offset-4 hover:underline text-primary-600',
        icon: 'h-10 w-10',
      },
      size: {
        sm: 'h-9 px-3 rounded-md',
        md: 'h-10 py-2 px-4',
        lg: 'h-11 px-8 rounded-md',
      },
    };

    const classNames = [
      defaultClasses.base,
      defaultClasses.variant[variant],
      defaultClasses.size[size],
      classes.base,
      classes.variant?.[variant],
      classes.size?.[size],
      className,
    ]
      .filter(Boolean)
      .join(' ');

    return (
      <button
        ref={ref}
        className={classNames}
        {...props}
      />
    );
  }
);

Button.displayName = 'Button';

---


### FILE: frontend/src/shared/components/ui/SearchableSelect.tsx ###
import React, { useEffect, useRef, useState } from 'react';

interface SearchableSelectProps<T> {
  value: string;
  onSearch: (term: string) => void;
  options: T[];
  loading?: boolean;
  onSelect: (item: T) => void;
  getLabel: (item: T) => string;
  renderOption?: (item: T) => React.ReactNode;
  placeholder?: string;
}

const SearchableSelect = <T extends { id: string | number }>({
  value,
  onSearch,
  options,
  loading = false,
  onSelect,
  getLabel,
  renderOption,
  placeholder = 'Search...',
}: SearchableSelectProps<T>) => {
  const [open, setOpen] = useState(false);
  const ref = useRef<HTMLDivElement>(null);

  /* -------------------------- Outside click ------------------------------- */

  useEffect(() => {
    const handler = (e: MouseEvent) => {
      if (ref.current && !ref.current.contains(e.target as Node)) {
        setOpen(false);
      }
    };
    document.addEventListener('mousedown', handler);
    return () => document.removeEventListener('mousedown', handler);
  }, []);

  /* ----------------------------------------------------------------------- */

  return (
    <div ref={ref} className="relative">
      <input
        value={value}
        onChange={(e) => {
          onSearch(e.target.value);
          setOpen(true);
        }}
        placeholder={placeholder}
        className="w-full rounded-md border border-gray-300 px-3 py-2"
      />

      {open && (
        <ul className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white shadow">
          {loading && (
            <li className="px-3 py-2 text-sm text-gray-500">Loading‚Ä¶</li>
          )}

          {!loading && options.length === 0 && (
            <li className="px-3 py-2 text-sm text-gray-500">No results</li>
          )}

          {!loading &&
            options.map((item) => (
              <li
                key={item.id}
                onClick={() => {
                  onSelect(item);
                  onSearch(getLabel(item));
                  setOpen(false);
                }}
                className="cursor-pointer px-3 py-2 hover:bg-primary-600 hover:text-white"
              >
                {renderOption ? renderOption(item) : getLabel(item)}
              </li>
            ))}
        </ul>
      )}
    </div>
  );
};

export default SearchableSelect;

---


### FILE: frontend/src/shared/components/ui/Input.tsx ###
import React from 'react';

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

export const Input = React.forwardRef<
  HTMLInputElement,
  InputProps
>(
  ({ className = '', ...props }, ref) => {
    const baseClasses =
      'block w-full rounded-md border border-gray-300 ' +
      'bg-white px-3 py-2 text-sm ' +
      'placeholder-gray-400 ' +
      'focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ' +
      'disabled:cursor-not-allowed disabled:opacity-50';

    return (
      <input
        ref={ref}
        className={`${baseClasses} ${className}`}
        {...props}
      />
    );
  }
);

Input.displayName = 'Input';

---


### FILE: frontend/src/shared/components/ui/Modal.tsx ###
import React from 'react';
import { createPortal } from 'react-dom';
export type ModalSize = 'sm' | 'md' | 'lg' | 'xl'; // added xl

export interface ModalClasses {
  backdrop?: string;
  container?: string;
  size?: Partial<Record<ModalSize, string>>;
}

export interface ModalProps {
  open: boolean;
  onClose?: () => void;
  size?: ModalSize;
  classes?: ModalClasses;
  children: React.ReactNode;
}

const DEFAULT_CLASSES: Required<ModalClasses> = {
  backdrop:
    'fixed inset-0 z-[999] flex items-center justify-center bg-black/40',
  container:
    'bg-white rounded-xl shadow-xl w-full mx-4',
  size: {
    sm: 'max-w-sm p-4',
    md: 'max-w-lg p-6',
    lg: 'max-w-2xl p-8',
    xl: 'max-w-4xl p-10', // added xl size
  },
};


export const Modal: React.FC<ModalProps> = ({
  open,
  onClose,
  size = 'md',
  classes = {},
  children,
}) => {
  if (!open) return null;

  const backdropClass = [
    DEFAULT_CLASSES.backdrop,
    classes.backdrop,
  ]
    .filter(Boolean)
    .join(' ');

  const containerClass = [
    DEFAULT_CLASSES.container,
    DEFAULT_CLASSES.size[size],
    classes.container,
    classes.size?.[size],
  ]
    .filter(Boolean)
    .join(' ');

  return createPortal(
    <div
      className={backdropClass}
      onClick={onClose}
    >
      <div
        className={containerClass}
        onClick={(e) => e.stopPropagation()}
      >
        {children}
      </div>
    </div>,document.body
  );
};

---


### FILE: frontend/src/shared/components/InputRadio.tsx ###
import React, { type FC } from "react";

interface InputRadioProps {
  checked: boolean;
  onChange: (checked: boolean) => void;
  disabled?: boolean;
  size?: "sm" | "md" | "lg" | "xl" | number; // variant sizes or custom px
  colorClass?: string; // Tailwind class for checked state
  className?: string; // wrapper class
}

const sizeMap: Record<string, string> = {
  sm: "w-4 h-4",   // 16px
  md: "w-6 h-6",   // 24px
  lg: "w-8 h-8",   // 32px
  xl: "w-10 h-10", // 40px
};

export const InputRadio: FC<InputRadioProps> = ({
  checked,
  onChange,
  disabled = false,
  size = "md",
  colorClass = "bg-primary-500",
  className = "",
}) => {
  // Determine dimension
  const dimension =
    typeof size === "number" ? `w-[${size}px] h-[${size}px]` : sizeMap[size] || sizeMap.md;

  return (
    <div
      className={`inline-flex items-center justify-center cursor-pointer select-none
        ${disabled ? "opacity-50 cursor-not-allowed" : ""} ${className}`}
      onClick={() => !disabled && onChange(true)}
    >
      {/* Hidden native input for accessibility */}
      <input type="radio" className="sr-only" checked={checked} disabled={disabled} readOnly />

      {/* Custom circle */}
      <div
        className={`border-2 border-gray-300 rounded-full flex items-center justify-center
          ${checked ? `${colorClass} border-transparent` : ""}
          transition-all duration-150
          ${dimension}
        `}
      >
        {checked && (
          <div
            className="bg-white rounded-full"
            style={{
              width: "50%",
              height: "50%",
            }}
          />
        )}
      </div>
    </div>
  );
};

---


### FILE: frontend/src/shared/stores/hooks.ts ###
import { useDispatch, useSelector } from 'react-redux'
import type { RootState, AppDispatch } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
export const useAppSelector = useSelector.withTypes<RootState>()

---


### FILE: frontend/src/shared/stores/store.ts ###
import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import authReducer from '../../features/auth/stores/authSlice';
import { apiSlice } from '../services/apiSlice';

export const store = configureStore({
  reducer: {
    [apiSlice.reducerPath]: apiSlice.reducer, // Use the base apiSlice reducer
    auth: authReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(apiSlice.middleware), // Use the base apiSlice middleware
});

setupListeners(store.dispatch);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

---


### FILE: frontend/src/shared/utils/date.ts ###
// frontend/src/shared/utils/date.ts

export const timeAgo = (dateString: string): string => {
  if (!dateString) return 'just now'; // Handle cases where dateString might be empty or null

  const now = new Date();
  const postDate = new Date(dateString);
  const seconds = Math.floor((now.getTime() - postDate.getTime()) / 1000);

  const intervals = [
    { label: 'year', seconds: 31536000 },
    { label: 'month', seconds: 2592000 },
    { label: 'week', seconds: 604800 },
    { label: 'day', seconds: 86400 },
    { label: 'hour', seconds: 3600 },
    { label: 'minute', seconds: 60 },
    { label: 'second', seconds: 1 },
  ];

  for (const interval of intervals) {
    const count = Math.floor(seconds / interval.seconds);
    if (count >= 1) {
      return `${count} ${interval.label}${count > 1 ? 's' : ''} ago`;
    }
  }

  return 'just now';
};

---


### FILE: frontend/src/shared/services/apiSlice.ts ###
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

// Create a base query with authentication headers
const baseQuery = fetchBaseQuery({
  baseUrl: 'http://localhost:3000/api/',
  prepareHeaders: (headers, { getState }) => {
    // Assuming your auth slice is named 'auth' and has an 'accessToken' field
    const token = (getState() as any).auth?.accessToken;
    if (token) {
      headers.set('Authorization', `Bearer ${token}`);
    }
    
    return headers;
  },
  credentials: 'include',
});

// Create a base API slice that other API slices can extend
export const apiSlice = createApi({
  reducerPath: 'api',
  baseQuery,
  // Define common tag types here if any, otherwise leave empty
  tagTypes: ['Posts', 'Comments', 'Me', 'Profile', 'Reactions',
     'Communities', 'CommunityMemberships',
     "CommunityMembershipRequests","CommunityRestrictions", "Reports"],
  endpoints: () => ({}), // Empty endpoints as this is a base slice
});

---


### FILE: frontend/src/shared/types/index.ts ###
export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    page: number;
    limit: number;
    totalItems: number;
    totalPages: number;
    itemCount: number;
  };
}

export interface ResponseDto<T> {
  data: T;
  message: string;
}

---


### FILE: frontend/src/shared/hooks/useToast.ts ###
import { useState, useCallback } from 'react';
import type { ToastType } from '../components/ui/Toast';

export interface ToastData {
  message: string;
  type: ToastType;
}

export const useToast = () => {
  const [toast, setToast] = useState<ToastData | null>(null);

  const showToast = useCallback((message: string, type: ToastType) => {
    setToast({ message, type });
  }, []);

  const hideToast = useCallback(() => {
    setToast(null);
  }, []);

  return {
    toast,
    showToast,
    hideToast,
  };
};

---


### FILE: frontend/src/main.tsx ###
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './index.css';
import App from './App';
import { Provider } from 'react-redux';
import { store } from './shared/stores/store';
import { ToastProvider } from './shared/providers/ToastProvider';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <Provider store={store}>
      <ToastProvider>
        <App />
      </ToastProvider>
    </Provider>
  </StrictMode>
);

---

