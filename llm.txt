

--- CONFIGURATION FILES ---


--- BACKEND SOURCE ---


### FILE: backend/src/app.controller.ts ###
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

---


### FILE: backend/src/database/seeds/post.seed.ts ###
import { postFactory } from '../factories/post.factory';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity'; // Import Community entity
import { AppDataSource } from '../../data-source';

export async function seedPosts(users: User[], communities: Community[]) {
  const postRepo = AppDataSource.getRepository(Post);

  const posts: Post[] = Array.from({ length: 30 }).map(() => {
    const author = users[Math.floor(Math.random() * users.length)];
    const community = communities[Math.floor(Math.random() * communities.length)]; // Select a random community
    return postFactory(author, community);
  });

  await postRepo.save(posts);
  console.log('Seeded 100 posts ‚úÖ');

  return posts;
}

if (require.main === module) seedPosts([], []);

---


### FILE: backend/src/database/seeds/reaction.seed.ts ###
import { AppDataSource } from '../../data-source';
import { postReactionFactory } from '../factories/post-reaction.factory';
import { commentReactionFactory } from '../factories/comment-reaction.factory';

import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
export async function seedReactions(
  posts: Post[],
  comments: Comment[],
  users: User[],
): Promise<(PostReaction | CommentReaction)[]> {
  if (!users.length) {
    throw new Error('At least one user is required to seed reactions.');
  }

  const postReactionRepo = AppDataSource.getRepository(PostReaction);
  const commentReactionRepo = AppDataSource.getRepository(CommentReaction);
  const postRepo = AppDataSource.getRepository(Post);
  const commentRepo = AppDataSource.getRepository(Comment);

  const postReactionsToSave: PostReaction[] = [];
  const commentReactionsToSave: CommentReaction[] = [];

  const pickRandomUniqueUsers = (count: number): User[] => {
    const unique = new Set<number>();
    const picked: User[] = [];

    while (unique.size < count && unique.size < users.length) {
      const user = users[Math.floor(Math.random() * users.length)];
      if (!unique.has(user.id)) {
        unique.add(user.id);
        picked.push(user);
      }
    }
    return picked;
  };

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // POSTS
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (const post of posts) {
    const num = Math.floor(Math.random() * 3) + 1;
    for (const user of pickRandomUniqueUsers(num)) {
      postReactionsToSave.push(postReactionFactory(user, post));
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // COMMENTS
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (const comment of comments) {
    const num = Math.floor(Math.random() * 2) + 1;
    for (const user of pickRandomUniqueUsers(num)) {
      commentReactionsToSave.push(commentReactionFactory(user, comment));
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SAVE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const savedPostReactions = await postReactionRepo.save(postReactionsToSave);
  const savedCommentReactions = await commentReactionRepo.save(
    commentReactionsToSave,
  );

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üîÅ REBUILD COUNTERS (THE IMPORTANT PART)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // POSTS
  await postRepo
    .createQueryBuilder()
    .update(Post)
    .set({
      likesCount: () => `
        (
          SELECT COUNT(*)
          FROM post_reactions pr
          WHERE pr.postId = posts.id
            AND pr.type = 'like'
        )
      `,
      dislikesCount: () => `
        (
          SELECT COUNT(*)
          FROM post_reactions pr
          WHERE pr.postId = posts.id
            AND pr.type = 'dislike'
        )
      `,
    })
    .execute();

  // COMMENTS
  await commentRepo
    .createQueryBuilder()
    .update(Comment)
    .set({
      likesCount: () => `
        (
          SELECT COUNT(*)
          FROM comment_reactions cr
          WHERE cr.commentId = comments.id
            AND cr.type = 'like'
        )
      `,
      dislikesCount: () => `
        (
          SELECT COUNT(*)
          FROM comment_reactions cr
          WHERE cr.commentId = comments.id
            AND cr.type = 'dislike'
        )
      `,
    })
    .execute();

  const all = [...savedPostReactions, ...savedCommentReactions];
  console.log(`Seeded ${all.length} reactions ‚úÖ`);
  console.log(`Rebuilt like/dislike counters ‚úÖ`);

  return all;
}

---


### FILE: backend/src/database/seeds/user.seed.ts ###
import { AppDataSource } from '../../data-source';
import { userFactory } from '../factories/user.factory';
import { User } from '../../users/entities/user.entity';
import * as bcrypt from 'bcrypt';
import { use } from 'passport';

export async function seedUsers() {
  const userRepo = AppDataSource.getRepository(User);

  const users: User[] = Array.from({ length: 30 }).map(() => userFactory());

  const user = new User();
  user.name = 'Test User';
  user.email = 'test@example.com';
  user.password = bcrypt.hashSync('password123', 10);
  user.emailVerifiedAt=new Date()

  users.push(user);

  await userRepo.save(users);
  console.log('Seeded 101 users ‚úÖ');

  return users;
}

if (require.main === module) seedUsers();

---


### FILE: backend/src/database/seeds/comment.seed.ts ###
import { AppDataSource } from '../../data-source';
import { commentFactory } from '../factories/comment.factory';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';

export async function seedComments(users: User[], posts: Post[]) {
  const commentRepo = AppDataSource.getRepository(Comment);
  const postRepo = AppDataSource.getRepository(Post);

  // 1. Create initial top-level comments
  const topLevelComments: Comment[] = [];
  for (let i = 0; i < 300; i++) {
    const author = users[Math.floor(Math.random() * users.length)];
    const post = posts[Math.floor(Math.random() * posts.length)];
    topLevelComments.push(commentFactory(author, post));
  }
  await commentRepo.save(topLevelComments);
  console.log(`Seeded ${topLevelComments.length} top-level comments ‚úÖ`);

  // 2. Create replies to top-level comments
  const firstLevelReplies: Comment[] = [];
  for (let i = 0; i < topLevelComments.length / 2; i++) {
    const parentComment = topLevelComments[i];
    const numberOfReplies = Math.floor(Math.random() * 3) + 1; // 1 to 3 replies
    for (let j = 0; j < numberOfReplies; j++) {
      const author = users[Math.floor(Math.random() * users.length)];
      const post = parentComment.post;
      firstLevelReplies.push(commentFactory(author, post, parentComment.id));
    }
  }
  await commentRepo.save(firstLevelReplies);
  console.log(`Seeded ${firstLevelReplies.length} first-level replies ‚úÖ`);

  // 3. Create nested replies (replies to replies)
  const secondLevelReplies: Comment[] = [];
  for (let i = 0; i < firstLevelReplies.length / 3; i++) {
    const parentComment = firstLevelReplies[i];
    const numberOfReplies = Math.floor(Math.random() * 2) + 1; // 1 to 2 replies
    for (let j = 0; j < numberOfReplies; j++) {
      const author = users[Math.floor(Math.random() * users.length)];
      const post = parentComment.post;
      secondLevelReplies.push(commentFactory(author, post, parentComment.id));
    }
  }
  await commentRepo.save(secondLevelReplies);
  console.log(`Seeded ${secondLevelReplies.length} second-level replies ‚úÖ`);

  const allComments = [...topLevelComments, ...firstLevelReplies, ...secondLevelReplies];
  console.log(`Seeded total ${allComments.length} comments ‚úÖ`);

  // Efficiently update commentsCount for all posts using a single query
  await postRepo
    .createQueryBuilder()
    .update(Post)
    .set({
      commentsCount: () =>
        `(SELECT COUNT(*) FROM comments WHERE comments.postId = posts.id)`
    })
    .execute();

  console.log('Updated commentsCount for all posts efficiently ‚úÖ');

  await commentRepo
  .createQueryBuilder()
  .update(Comment)
  .set({
    repliesCount: () =>
      `(SELECT COUNT(*) FROM comments AS c2 WHERE c2.parentId = comments.id)`,
  })
  .execute();
  
  console.log('Updated repliesCount for all comments efficiently ‚úÖ');

  return allComments;
}

if (require.main === module) seedComments([], []);

---


### FILE: backend/src/database/seeds/community-memberships.seed.ts ###
import { AppDataSource } from '../../data-source';
import { communityMembershipFactory } from '../factories/community-memberships.factory';
import { CommunityMembership } from '../../community-memberships/entities/community-memberships.entity';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';

export async function seedCommunityMemberships(
  users: User[],
  communities: Community[],
): Promise<CommunityMembership[]> {
  const membershipRepo = AppDataSource.getRepository(CommunityMembership);
  const communityRepo = AppDataSource.getRepository(Community);

  const memberships: CommunityMembership[] = [];

  for (const user of users) {
    const numMemberships = Math.floor(Math.random() * 3) + 1;
    const shuffled = [...communities].sort(() => 0.5 - Math.random());
    const toSubscribe = shuffled.slice(0, numMemberships);

    for (const community of toSubscribe) {
      const membership = communityMembershipFactory();
      membership.userId = user.id;
      membership.communityId = community.id;
      memberships.push(membership);
    }
  }

  await membershipRepo.save(memberships);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // UPDATE subscribers_count (CORRECT WAY)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  await communityRepo
    .createQueryBuilder()
    .update(Community)
    .set({
      membersCount: () => `
        (
          SELECT COUNT(*)
          FROM community_memberships cs
          WHERE cs.communityId = communities.id
        )
      `,
    })
    .execute();

  console.log(`Seeded ${memberships.length} community memberships ‚úÖ`);
  console.log(`Updated communities.subscribers_count ‚úÖ`);

  return memberships;
}

if (require.main === module) {
  AppDataSource.initialize().then(async () => {
    const userRepo = AppDataSource.getRepository(User);
    const communityRepo = AppDataSource.getRepository(Community);
    const users = await userRepo.find();
    const communities = await communityRepo.find();
    await seedCommunityMemberships(users, communities);
  }).catch(error => console.error('Seeding failed ‚ùå', error));
}

---


### FILE: backend/src/database/seeds/community.seed.ts ###
import { AppDataSource } from '../../data-source';
import { communityFactory } from '../factories/community.factory';
import { Community } from '../../communities/entities/community.entity';
import { User } from '../../users/entities/user.entity';

export async function seedCommunities(users: User[]): Promise<Community[]> {
  const communityRepo = AppDataSource.getRepository(Community);
  const communities: Community[] = Array.from({ length: 8 }).map(() => {
    const community = communityFactory();
    community.owner = users[Math.floor(Math.random() * users.length)];
    community.ownerId = community.owner.id;
    return community;
  });

  await communityRepo.save(communities);
  console.log(`Seeded ${communities.length} communities ‚úÖ`);
  return communities;
}

if (require.main === module) {
  AppDataSource.initialize().then(async () => {
    const userRepo = AppDataSource.getRepository(User);
    const users = await userRepo.find();
    await seedCommunities(users);
  }).catch(error => console.error('Seeding failed ‚ùå', error));
}

---


### FILE: backend/src/database/seeds/index.ts ###
import { seedUsers } from './user.seed';
import { seedPosts } from './post.seed';
import { seedComments } from './comment.seed';
import { seedReactions } from './reaction.seed';
import { seedCommunities } from './community.seed';
import { seedCommunityMemberships } from './community-memberships.seed';
import { AppDataSource } from '../../data-source';

async function main() {
  try {
    await AppDataSource.initialize();
    // Seed users
    const users = await seedUsers();

    // Seed communities
    const communities = await seedCommunities(users);

    // Seed posts
    const posts = await seedPosts(users, communities);

    // Seed comments
    const comments = await seedComments(users, posts);

    // Seed reactions (optional)
    await seedReactions(posts, comments, users);

    // Seed community memberships
    await seedCommunityMemberships(users, communities);

    console.log('Database seeding complete ‚úÖ');
  } catch (error) {
    console.error('Seeding failed ‚ùå', error);
  } finally {
    // Optional: ensure datasource is destroyed if needed
    // await AppDataSource.destroy();
  }
}

main();

---


### FILE: backend/src/database/factories/community-memberships.factory.ts ###
import { faker } from '@faker-js/faker';
import { CommunityMembership } from '../../community-memberships/entities/community-memberships.entity';

export function communityMembershipFactory(): CommunityMembership {
  const membership = new CommunityMembership();
  // userId and communityId will be set when seeding, as they are foreign keys
  // For now, we can just return the basic membership object.
  return membership;
}

---


### FILE: backend/src/database/factories/user.factory.ts ###
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';
import * as bcrypt from 'bcrypt';

export function userFactory(): User {
  const user = new User();

  user.name = faker.person.fullName();
  user.email = faker.internet.email();

  // --- Add bcrypt password ---
  const plainPassword = 'password1'; // or faker.internet.password();
  const saltRounds = 10;

  user.password = bcrypt.hashSync(plainPassword, saltRounds);

  return user;
}

---


### FILE: backend/src/database/factories/comment-reaction.factory.ts ###
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';
import { ReactionType } from '../../reactions/reactions.types';

/**
 * Creates a CommentReaction object.
 */
export function commentReactionFactory(
  user: User,
  comment: Comment,
): CommentReaction {
  const reaction = new CommentReaction();

  reaction.user = user;
  reaction.comment = comment;

  const types = Object.values(ReactionType);
  reaction.type = faker.helpers.arrayElement(types);

  return reaction;
}

---


### FILE: backend/src/database/factories/post.factory.ts ###
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity'; // Import Community entity
import { faker } from '@faker-js/faker';

export function postFactory(author: User, community: Community): Post {
  const post = new Post();
  post.title = faker.lorem.sentence();
  post.content = faker.lorem.paragraph();
  post.author = author;
  post.community = community; // Assign community
  return post;
}

---


### FILE: backend/src/database/factories/comment.factory.ts ###
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';
import { faker } from '@faker-js/faker';

export function commentFactory(author: User, post: Post, parentId?: number): Comment {
  const comment = new Comment();
  comment.content = faker.lorem.sentence();
  comment.author = author;
  comment.post = post;
  comment.repliesCount = 0;
  if (parentId) {
    comment.parentId = parentId;
  }
  return comment;
}

---


### FILE: backend/src/database/factories/post-reaction.factory.ts ###
import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { faker } from '@faker-js/faker';
import { ReactionType } from '../../reactions/reactions.types';

/**
 * Creates a PostReaction object.
 */
export function postReactionFactory(user: User, post: Post): PostReaction {
  const reaction = new PostReaction();

  reaction.user = user;
  reaction.post = post;

  const types = Object.values(ReactionType);
  reaction.type = faker.helpers.arrayElement(types);

  return reaction;
}

---


### FILE: backend/src/database/factories/community.factory.ts ###
import { faker } from '@faker-js/faker';
import { Community } from '../../communities/entities/community.entity';
import { CommunityType } from '../../communities/types';

export function communityFactory(): Community {
  const community = new Community();
  community.name = faker.internet.username();
  community.displayName = faker.company.name();
  community.description = faker.lorem.paragraph();
  community.communityType = faker.helpers.arrayElement(Object.values(CommunityType));
  community.membersCount = faker.number.int({ min: 0, max: 1000 });
  return community;
}

---


### FILE: backend/src/database/migrations/1765931083722-MakePostCommunityMandatory.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class MakePostCommunityMandatory1765931083722 implements MigrationInterface {
    name = 'MakePostCommunityMandatory1765931083722'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
    }

}

---


### FILE: backend/src/database/migrations/1765627185088-AddPictureFieldToUser.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddPictureFieldToUser1765627185088 implements MigrationInterface {
    name = 'AddPictureFieldToUser1765627185088'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "picture" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
        await queryRunner.query(`CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`);
        await queryRunner.query(`DROP TABLE "temporary_users"`);
    }

}

---


### FILE: backend/src/database/migrations/1766443444048-AddCommentsLockedToPost.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommentsLockedToPost1766443444048 implements MigrationInterface {
    name = 'AddCommentsLockedToPost1766443444048'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "commentsLocked" boolean NOT NULL DEFAULT (0), "isApproved" boolean NOT NULL DEFAULT (0), "approvedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, CONSTRAINT "FK_d6947c03c05fca0fa035b19e73d" FOREIGN KEY ("moderatorId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_4927687e8f8ed1b2e4c849ddc82" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_moderators"("moderatorId", "communityId") SELECT "moderatorId", "communityId" FROM "community_moderators"`);
        await queryRunner.query(`DROP TABLE "community_moderators"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_moderators" RENAME TO "community_moderators"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_2d9086cef1ffd5148f90a9fab5d" FOREIGN KEY ("ownerId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "community_moderators" RENAME TO "temporary_community_moderators"`);
        await queryRunner.query(`CREATE TABLE "community_moderators" ("moderatorId" integer NOT NULL, "communityId" integer NOT NULL, PRIMARY KEY ("moderatorId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_moderators"("moderatorId", "communityId") SELECT "moderatorId", "communityId" FROM "temporary_community_moderators"`);
        await queryRunner.query(`DROP TABLE "temporary_community_moderators"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "community_moderators"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
    }

}

---


### FILE: backend/src/database/migrations/1765490375370-refactor-reactions.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class RefactorReactions1765490375370 implements MigrationInterface {
  name = 'RefactorReactions1765490375370';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `,
    );
    await queryRunner.query(
      `CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b8f6756d160de241ea96a768254" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "post_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "post_reactions"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_post_reactions" RENAME TO "post_reactions"`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_ab02238d3deb62cba37aa8047dd" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "comment_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "comment_reactions"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment_reactions" RENAME TO "comment_reactions"`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
    await queryRunner.query(
      `ALTER TABLE "comment_reactions" RENAME TO "temporary_comment_reactions"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `INSERT INTO "comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "temporary_comment_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment_reactions"`);
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
    await queryRunner.query(
      `ALTER TABLE "post_reactions" RENAME TO "temporary_post_reactions"`,
    );
    await queryRunner.query(
      `CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `INSERT INTO "post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "temporary_post_reactions"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post_reactions"`);
    await queryRunner.query(
      `CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `,
    );
    await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
    await queryRunner.query(`DROP TABLE "comment_reactions"`);
    await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
    await queryRunner.query(`DROP TABLE "post_reactions"`);
  }
}

---


### FILE: backend/src/database/migrations/1766774568393-CreateCommunityRestrictionsTable.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateCommunityRestrictionsTable1766774568393 implements MigrationInterface {
    name = 'CreateCommunityRestrictionsTable1766774568393'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "community_restrictions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "restrictionType" varchar CHECK( "restrictionType" IN ('ban','mute') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityId" integer, "userId" integer)`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_restrictions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "restrictionType" varchar CHECK( "restrictionType" IN ('ban','mute') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityId" integer, "userId" integer, CONSTRAINT "FK_066c4afe6f1ba3f2178159967cc" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_7399cce662943e126a61f635e5c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_community_restrictions"("id", "restrictionType", "createdAt", "communityId", "userId") SELECT "id", "restrictionType", "createdAt", "communityId", "userId" FROM "community_restrictions"`);
        await queryRunner.query(`DROP TABLE "community_restrictions"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_restrictions" RENAME TO "community_restrictions"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "community_restrictions" RENAME TO "temporary_community_restrictions"`);
        await queryRunner.query(`CREATE TABLE "community_restrictions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "restrictionType" varchar CHECK( "restrictionType" IN ('ban','mute') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityId" integer, "userId" integer)`);
        await queryRunner.query(`INSERT INTO "community_restrictions"("id", "restrictionType", "createdAt", "communityId", "userId") SELECT "id", "restrictionType", "createdAt", "communityId", "userId" FROM "temporary_community_restrictions"`);
        await queryRunner.query(`DROP TABLE "temporary_community_restrictions"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_restrictions"`);
    }

}

---


### FILE: backend/src/database/migrations/1765821272324-AddLikesDislikesToPostsComments.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddLikesDislikesToPostsComments1765821272324 implements MigrationInterface {
    name = 'AddLikesDislikesToPostsComments1765821272324'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`);
        await queryRunner.query(`DROP TABLE "comment"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment" RENAME TO "comment"`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`ALTER TABLE "comment" RENAME TO "temporary_comment"`);
        await queryRunner.query(`CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`);
        await queryRunner.query(`DROP TABLE "temporary_comment"`);
    }

}

---


### FILE: backend/src/database/migrations/1765628559552-RefactorProfileEntity.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class RefactorProfileEntity1765628559552 implements MigrationInterface {
    name = 'RefactorProfileEntity1765628559552'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"))`);
        await queryRunner.query(`CREATE TABLE "temporary_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_profiles" RENAME TO "profiles"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "profiles" RENAME TO "temporary_profiles"`);
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"))`);
        await queryRunner.query(`INSERT INTO "profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
    }

}

---


### FILE: backend/src/database/migrations/1764720178421-inital.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class Inital1764720178421 implements MigrationInterface {
  name = 'Inital1764720178421';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "user" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar NOT NULL, "email" varchar NOT NULL, CONSTRAINT "UQ_e12875dfb3b1d92d7d7c5377e22" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(`DROP TABLE "user"`);
  }
}

---


### FILE: backend/src/database/migrations/1766320141300-AddStatusToCommunitySubscription.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddStatusToCommunityMembership1766320141300 implements MigrationInterface {
    name = 'AddStatusToCommunityMembership1766320141300'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "status" varchar CHECK( "status" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
    }

}

---


### FILE: backend/src/database/migrations/1766412136598-AddApprovedAtToPosts.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddApprovedAtToPosts1766412136598 implements MigrationInterface {
    name = 'AddApprovedAtToPosts1766412136598'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "isApproved" boolean NOT NULL DEFAULT (0), "approvedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_2d9086cef1ffd5148f90a9fab5d" FOREIGN KEY ("ownerId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "ownerId" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer NOT NULL, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE RESTRICT ON UPDATE NO ACTION, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "ownerId", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
    }

}

---


### FILE: backend/src/database/migrations/1765671180328-AddCommunitiesAndSubscriptions.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommunitiesAndMemberships1765671180328 implements MigrationInterface {
    name = 'AddCommunitiesAndMemberships1765671180328'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"))`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt") SELECT "userId", "communityId", "createdAt" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
    }

}

---


### FILE: backend/src/database/migrations/1765630608057-MakeUsernameNonNullable.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class MakeUsernameNonNullable1765630608057 implements MigrationInterface {
    name = 'MakeUsernameNonNullable1765630608057'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_profiles" RENAME TO "profiles"`);
        await queryRunner.query(`CREATE TABLE "temporary_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar NOT NULL, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "profiles"`);
        await queryRunner.query(`DROP TABLE "profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_profiles" RENAME TO "profiles"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "profiles" RENAME TO "temporary_profiles"`);
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_profiles"`);
        await queryRunner.query(`ALTER TABLE "profiles" RENAME TO "temporary_profiles"`);
        await queryRunner.query(`CREATE TABLE "profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "REL_315ecd98bd1a42dcf2ec4e2e98" UNIQUE ("userId"), CONSTRAINT "UQ_d1ea35db5be7c08520d70dc03f8" UNIQUE ("username"), CONSTRAINT "FK_315ecd98bd1a42dcf2ec4e2e985" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_profiles"`);
    }

}

---


### FILE: backend/src/database/migrations/1766168966958-MakeParentIdNullable.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class MakeParentIdNullable1766168966958 implements MigrationInterface {
    name = 'MakeParentIdNullable1766168966958'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
    }

}

---


### FILE: backend/src/database/migrations/1764783033004-AddReactions.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddReactions1764783033004 implements MigrationInterface {
  name = 'AddReactions1764783033004';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_e58a09ab17e3ce4c47a1a330ae1" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "reaction"`,
    );
    await queryRunner.query(`DROP TABLE "reaction"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_reaction" RENAME TO "reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(
      `ALTER TABLE "reaction" RENAME TO "temporary_reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL)`,
    );
    await queryRunner.query(
      `INSERT INTO "reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "temporary_reaction"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_reaction"`);
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId") SELECT "id", "title", "content", "authorId" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId") SELECT "id", "content", "createdAt", "postId", "authorId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(`DROP TABLE "reaction"`);
  }
}

---


### FILE: backend/src/database/migrations/1766168720979-AddRepliesCountToComment.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddRepliesCountToComment1766168720979 implements MigrationInterface {
    name = 'AddRepliesCountToComment1766168720979'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer NOT NULL, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, "repliesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId", "repliesCount" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
    }

}

---


### FILE: backend/src/database/migrations/1766319450404-AddCommunityTypeToCommunity.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommunityTypeToCommunity1766319450404 implements MigrationInterface {
    name = 'AddCommunityTypeToCommunity1766319450404'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
        await queryRunner.query(`CREATE TABLE "temporary_communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" varchar CHECK( "communityType" IN ('public','restricted','private') ) NOT NULL DEFAULT ('public'), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "communities"`);
        await queryRunner.query(`DROP TABLE "communities"`);
        await queryRunner.query(`ALTER TABLE "temporary_communities" RENAME TO "communities"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "communityType" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
        await queryRunner.query(`ALTER TABLE "communities" RENAME TO "temporary_communities"`);
        await queryRunner.query(`CREATE TABLE "communities" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(50) NOT NULL, "displayName" varchar(100), "description" text, "createdById" integer, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "isPublic" boolean NOT NULL DEFAULT (1), "membersCount" integer NOT NULL DEFAULT (0), CONSTRAINT "UQ_501bb6c8f7c8e8a7d614d9435f6" UNIQUE ("name"), CONSTRAINT "FK_d035f75868bd42e56593ffa4aa7" FOREIGN KEY ("createdById") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "communities"("id", "name", "displayName", "description", "createdById", "createdAt", "isPublic", "membersCount") SELECT "id", "name", "displayName", "description", "createdById", "createdAt", "communityType", "membersCount" FROM "temporary_communities"`);
        await queryRunner.query(`DROP TABLE "temporary_communities"`);
    }

}

---


### FILE: backend/src/database/migrations/1766668524447-AddReportEntity.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddReportEntity1766668524447 implements MigrationInterface {
    name = 'AddReportEntity1766668524447'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "status" varchar CHECK( "status" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "status") SELECT "userId", "communityId", "createdAt", "status" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "status" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`CREATE TABLE "post_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`CREATE TABLE "comment_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "commentId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`CREATE TABLE "user_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "reportedUserId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "role" varchar CHECK( "role" IN ('0','1','2') ) NOT NULL DEFAULT (2), CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('admin','moderator','member') ) NOT NULL DEFAULT ('member'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('admin','moderator','member') ) NOT NULL DEFAULT ('member'), CONSTRAINT "FK_488d1ca96e355e11d83480a8f2c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_6ea82875cc58f4b1b14ebe49717" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("id", "userId", "communityId", "status", "createdAt") SELECT "id", "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_post_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0), CONSTRAINT "FK_4f4c3c25aa849390b9cb7fd6fa1" FOREIGN KEY ("reporterId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b9b9977c4da06492b2491cea20a" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "postId", "communityId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "postId", "communityId", "isPlatformComplaint" FROM "post_reports"`);
        await queryRunner.query(`DROP TABLE "post_reports"`);
        await queryRunner.query(`ALTER TABLE "temporary_post_reports" RENAME TO "post_reports"`);
        await queryRunner.query(`CREATE TABLE "temporary_comment_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "commentId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0), CONSTRAINT "FK_36ab772754faebab9c812565988" FOREIGN KEY ("reporterId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_14ce729bcc2ec2f7c16b11b2d9e" FOREIGN KEY ("commentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "commentId", "communityId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "commentId", "communityId", "isPlatformComplaint" FROM "comment_reports"`);
        await queryRunner.query(`DROP TABLE "comment_reports"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment_reports" RENAME TO "comment_reports"`);
        await queryRunner.query(`CREATE TABLE "temporary_user_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "reportedUserId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0), CONSTRAINT "FK_4c8ff913a6d53469649f6941ece" FOREIGN KEY ("reporterId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_85aa921a0dfd2b7d58cd4cd9450" FOREIGN KEY ("reportedUserId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_user_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "reportedUserId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "reportedUserId", "isPlatformComplaint" FROM "user_reports"`);
        await queryRunner.query(`DROP TABLE "user_reports"`);
        await queryRunner.query(`ALTER TABLE "temporary_user_reports" RENAME TO "user_reports"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "user_reports" RENAME TO "temporary_user_reports"`);
        await queryRunner.query(`CREATE TABLE "user_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "reportedUserId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "user_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "reportedUserId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "reportedUserId", "isPlatformComplaint" FROM "temporary_user_reports"`);
        await queryRunner.query(`DROP TABLE "temporary_user_reports"`);
        await queryRunner.query(`ALTER TABLE "comment_reports" RENAME TO "temporary_comment_reports"`);
        await queryRunner.query(`CREATE TABLE "comment_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "commentId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "comment_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "commentId", "communityId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "commentId", "communityId", "isPlatformComplaint" FROM "temporary_comment_reports"`);
        await queryRunner.query(`DROP TABLE "temporary_comment_reports"`);
        await queryRunner.query(`ALTER TABLE "post_reports" RENAME TO "temporary_post_reports"`);
        await queryRunner.query(`CREATE TABLE "post_reports" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reporterId" integer NOT NULL, "reason" varchar NOT NULL, "description" text, "status" varchar CHECK( "status" IN ('pending','resolved','dismissed') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer NOT NULL, "communityId" integer NOT NULL, "isPlatformComplaint" boolean NOT NULL DEFAULT (0))`);
        await queryRunner.query(`INSERT INTO "post_reports"("id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "postId", "communityId", "isPlatformComplaint") SELECT "id", "reporterId", "reason", "description", "status", "createdAt", "updatedAt", "postId", "communityId", "isPlatformComplaint" FROM "temporary_post_reports"`);
        await queryRunner.query(`DROP TABLE "temporary_post_reports"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("id", "userId", "communityId", "status", "createdAt") SELECT "id", "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('admin','moderator','member') ) NOT NULL DEFAULT ('member'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
        await queryRunner.query(`CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`);
        await queryRunner.query(`DROP TABLE "temporary_users"`);
        await queryRunner.query(`DROP TABLE "user_reports"`);
        await queryRunner.query(`DROP TABLE "comment_reports"`);
        await queryRunner.query(`DROP TABLE "post_reports"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "status" varchar CHECK( "status" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "status") SELECT "userId", "communityId", "createdAt", "role" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "status" varchar CHECK( "status" IN ('active','pending','blocked') ) NOT NULL DEFAULT ('pending'), CONSTRAINT "FK_a0761971a3fcd032c682d45f8a6" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_bcf2842e0032d27fb9d1c830e09" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "status") SELECT "userId", "communityId", "createdAt", "status" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
    }

}

---


### FILE: backend/src/database/migrations/1765214825123-addVerifrokesTable.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddVerifrokesTable1765214825123 implements MigrationInterface {
  name = 'AddVerifrokesTable1765214825123';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "email_verification_tokens" ("id" varchar PRIMARY KEY NOT NULL, "token" varchar NOT NULL, "userId" integer NOT NULL, "expiresAt" datetime NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "UQ_3d1613f95c6a564a3b588d161ae" UNIQUE ("token"))`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE "email_verification_tokens"`);
  }
}

---


### FILE: backend/src/database/migrations/1765927724937-AddCommentsCountToPost.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddCommentsCountToPost1765927724937 implements MigrationInterface {
    name = 'AddCommentsCountToPost1765927724937'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "commentsCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount" FROM "post"`);
        await queryRunner.query(`DROP TABLE "post"`);
        await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
        await queryRunner.query(`CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "communityId" integer, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_eff802f635e95c8aef1998b4843" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt", "communityId", "likesCount", "dislikesCount" FROM "temporary_post"`);
        await queryRunner.query(`DROP TABLE "temporary_post"`);
    }

}

---


### FILE: backend/src/database/migrations/1765377593735-AddOauthcols.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddOauthcols1765377593735 implements MigrationInterface {
  name = 'AddOauthcols1765377593735';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt") SELECT "id", "name", "email", "password", "emailVerifiedAt" FROM "users"`,
    );
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
    await queryRunner.query(
      `CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`,
    );
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_users"`);
    await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt") SELECT "id", "name", "email", "password", "emailVerifiedAt" FROM "temporary_users"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_users"`);
  }
}

---


### FILE: backend/src/database/migrations/1765457240708-addResetPasswordTokenTable.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddResetPasswordTokenTable1765457240708 implements MigrationInterface {
  name = 'AddResetPasswordTokenTable1765457240708';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "password_reset_tokens" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "token" varchar NOT NULL, "expiresAt" datetime NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_d6a19d4b4f6c62dcd29daa497e" ON "password_reset_tokens" ("userId") `,
    );
    await queryRunner.query(
      `CREATE INDEX "IDX_ab673f0e63eac966762155508e" ON "password_reset_tokens" ("token") `,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP INDEX "IDX_ab673f0e63eac966762155508e"`);
    await queryRunner.query(`DROP INDEX "IDX_d6a19d4b4f6c62dcd29daa497e"`);
    await queryRunner.query(`DROP TABLE "password_reset_tokens"`);
  }
}

---


### FILE: backend/src/database/migrations/1766756846428-AddOwnerRoleToMemeberships.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddOwnerRoleToMemeberships1766756846428 implements MigrationInterface {
    name = 'AddOwnerRoleToMemeberships1766756846428'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('owner','admin','moderator','member') ) NOT NULL DEFAULT ('member'), CONSTRAINT "FK_6ea82875cc58f4b1b14ebe49717" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_488d1ca96e355e11d83480a8f2c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "community_memberships"`);
        await queryRunner.query(`DROP TABLE "community_memberships"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_memberships" RENAME TO "community_memberships"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "community_memberships" RENAME TO "temporary_community_memberships"`);
        await queryRunner.query(`CREATE TABLE "community_memberships" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "role" varchar CHECK( "role" IN ('admin','moderator','member') ) NOT NULL DEFAULT ('member'), CONSTRAINT "FK_6ea82875cc58f4b1b14ebe49717" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_488d1ca96e355e11d83480a8f2c" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_memberships"("userId", "communityId", "createdAt", "role") SELECT "userId", "communityId", "createdAt", "role" FROM "temporary_community_memberships"`);
        await queryRunner.query(`DROP TABLE "temporary_community_memberships"`);
    }

}

---


### FILE: backend/src/database/migrations/1764871406438-addingColsToUser.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddingColsToUser1764871406438 implements MigrationInterface {
  name = 'AddingColsToUser1764871406438';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "temporary_reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "reaction"`,
    );
    await queryRunner.query(`DROP TABLE "reaction"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_reaction" RENAME TO "reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_e58a09ab17e3ce4c47a1a330ae1" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "reaction"`,
    );
    await queryRunner.query(`DROP TABLE "reaction"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_reaction" RENAME TO "reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "comment"`,
    );
    await queryRunner.query(`DROP TABLE "comment"`);
    await queryRunner.query(
      `ALTER TABLE "temporary_comment" RENAME TO "comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "temporary_post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "post"`,
    );
    await queryRunner.query(`DROP TABLE "post"`);
    await queryRunner.query(`ALTER TABLE "temporary_post" RENAME TO "post"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(
      `ALTER TABLE "reaction" RENAME TO "temporary_reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "temporary_reaction"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_reaction"`);
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "post" RENAME TO "temporary_post"`);
    await queryRunner.query(
      `CREATE TABLE "post" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "views" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c6fb082a3114f35d0cc27c518e0" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "post"("id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "views", "createdAt", "updatedAt", "deletedAt" FROM "temporary_post"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_post"`);
    await queryRunner.query(
      `ALTER TABLE "comment" RENAME TO "temporary_comment"`,
    );
    await queryRunner.query(
      `CREATE TABLE "comment" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "authorId" integer NOT NULL, "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "parentId" integer, CONSTRAINT "FK_e3aebe2bd1c53467a07109be596" FOREIGN KEY ("parentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_94a85bb16d24033a2afdd5df060" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_276779da446413a0d79598d4fbd" FOREIGN KEY ("authorId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "comment"("id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId") SELECT "id", "content", "createdAt", "postId", "authorId", "updatedAt", "deletedAt", "parentId" FROM "temporary_comment"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_comment"`);
    await queryRunner.query(
      `ALTER TABLE "reaction" RENAME TO "temporary_reaction"`,
    );
    await queryRunner.query(
      `CREATE TABLE "reaction" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "postId" integer, "commentId" integer, "userId" integer NOT NULL, CONSTRAINT "FK_e58a09ab17e3ce4c47a1a330ae1" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4584f851fc6471f517d9dad8966" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_dc3aeb83dc815f9f22ebfa7785f" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`,
    );
    await queryRunner.query(
      `INSERT INTO "reaction"("id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId") SELECT "id", "type", "createdAt", "updatedAt", "postId", "commentId", "userId" FROM "temporary_reaction"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_reaction"`);
  }
}

---


### FILE: backend/src/database/migrations/1765209236854-AddEmailVerifiedColumn.ts ###
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddEmailVerifiedColumn1765209236854 implements MigrationInterface {
  name = 'AddEmailVerifiedColumn1765209236854';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, "emailVerifiedAt" datetime, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "temporary_users"("id", "name", "email", "password") SELECT "id", "name", "email", "password" FROM "users"`,
    );
    await queryRunner.query(`DROP TABLE "users"`);
    await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
    await queryRunner.query(
      `CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar NOT NULL, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`,
    );
    await queryRunner.query(
      `INSERT INTO "users"("id", "name", "email", "password") SELECT "id", "name", "email", "password" FROM "temporary_users"`,
    );
    await queryRunner.query(`DROP TABLE "temporary_users"`);
  }
}

---


### FILE: backend/src/database/migrations/1765929661449-RenameTablesToPlural.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class RenameTablesToPlural1765929661449 implements MigrationInterface {
    name = 'RenameTablesToPlural1765929661449'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`CREATE TABLE "temporary_post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "post_reactions"`);
        await queryRunner.query(`DROP TABLE "post_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_post_reactions" RENAME TO "post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`CREATE TABLE "temporary_comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "comment_reactions"`);
        await queryRunner.query(`DROP TABLE "comment_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment_reactions" RENAME TO "comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer)`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`);
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`CREATE TABLE "temporary_post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b8f6756d160de241ea96a768254" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "post_reactions"`);
        await queryRunner.query(`DROP TABLE "post_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_post_reactions" RENAME TO "post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`CREATE TABLE "temporary_comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_ab02238d3deb62cba37aa8047dd" FOREIGN KEY ("commentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "comment_reactions"`);
        await queryRunner.query(`DROP TABLE "comment_reactions"`);
        await queryRunner.query(`ALTER TABLE "temporary_comment_reactions" RENAME TO "comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`CREATE TABLE "temporary_comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer, CONSTRAINT "FK_e44ddaaa6d058cb4092f83ad61f" FOREIGN KEY ("postId") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_4548cc4a409b8651ec75f70e280" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_8770bd9030a3d13c5f79a7d2e81" FOREIGN KEY ("parentId") REFERENCES "comments" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "comments"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`ALTER TABLE "temporary_comments" RENAME TO "comments"`);
        await queryRunner.query(`CREATE TABLE "temporary_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, CONSTRAINT "FK_c5a322ad12a7bf95460c958e80e" FOREIGN KEY ("authorId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_e5f99a0b3edb7e1867f44b2cf4c" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE SET NULL ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "posts"`);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`ALTER TABLE "temporary_posts" RENAME TO "posts"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "posts" RENAME TO "temporary_posts"`);
        await queryRunner.query(`CREATE TABLE "posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "communityId" integer, "commentsCount" integer NOT NULL DEFAULT (0), "views" integer NOT NULL DEFAULT (0), "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime)`);
        await queryRunner.query(`INSERT INTO "posts"("id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt") SELECT "id", "title", "content", "authorId", "communityId", "commentsCount", "views", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt" FROM "temporary_posts"`);
        await queryRunner.query(`DROP TABLE "temporary_posts"`);
        await queryRunner.query(`ALTER TABLE "comments" RENAME TO "temporary_comments"`);
        await queryRunner.query(`CREATE TABLE "comments" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "content" varchar NOT NULL, "authorId" integer NOT NULL, "likesCount" integer NOT NULL DEFAULT (0), "dislikesCount" integer NOT NULL DEFAULT (0), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), "deletedAt" datetime, "postId" integer, "parentId" integer)`);
        await queryRunner.query(`INSERT INTO "comments"("id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId") SELECT "id", "content", "authorId", "likesCount", "dislikesCount", "createdAt", "updatedAt", "deletedAt", "postId", "parentId" FROM "temporary_comments"`);
        await queryRunner.query(`DROP TABLE "temporary_comments"`);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`ALTER TABLE "comment_reactions" RENAME TO "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "temporary_comment_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`ALTER TABLE "post_reactions" RENAME TO "temporary_post_reactions"`);
        await queryRunner.query(`CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "temporary_post_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
        await queryRunner.query(`DROP TABLE "posts"`);
        await queryRunner.query(`DROP TABLE "comments"`);
        await queryRunner.query(`DROP INDEX "IDX_4f7d4bdbc66f63d75b26740a4a"`);
        await queryRunner.query(`ALTER TABLE "comment_reactions" RENAME TO "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE TABLE "comment_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "commentId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_b9fbc058a6dd52aec6c76f9b58a" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_ab02238d3deb62cba37aa8047dd" FOREIGN KEY ("commentId") REFERENCES "comment" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "comment_reactions"("id", "type", "commentId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "commentId", "userId", "createdAt", "updatedAt" FROM "temporary_comment_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_comment_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_4f7d4bdbc66f63d75b26740a4a" ON "comment_reactions" ("commentId", "userId") `);
        await queryRunner.query(`DROP INDEX "IDX_452ad3c5abe99f67a3b482f65e"`);
        await queryRunner.query(`ALTER TABLE "post_reactions" RENAME TO "temporary_post_reactions"`);
        await queryRunner.query(`CREATE TABLE "post_reactions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "type" varchar CHECK( "type" IN ('like','dislike') ) NOT NULL, "postId" integer NOT NULL, "userId" integer NOT NULL, "createdAt" datetime NOT NULL DEFAULT (datetime('now')), "updatedAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_d7d9db2320c356f8d32eae9d752" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE CASCADE ON UPDATE NO ACTION, CONSTRAINT "FK_b8f6756d160de241ea96a768254" FOREIGN KEY ("postId") REFERENCES "post" ("id") ON DELETE CASCADE ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "post_reactions"("id", "type", "postId", "userId", "createdAt", "updatedAt") SELECT "id", "type", "postId", "userId", "createdAt", "updatedAt" FROM "temporary_post_reactions"`);
        await queryRunner.query(`DROP TABLE "temporary_post_reactions"`);
        await queryRunner.query(`CREATE UNIQUE INDEX "IDX_452ad3c5abe99f67a3b482f65e" ON "post_reactions" ("postId", "userId") `);
    }

}

---


### FILE: backend/src/database/migrations/1765628229160-CreateUserProfileAndLinkToUser.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateUserProfileAndLinkToUser1765628229160 implements MigrationInterface {
    name = 'CreateUserProfileAndLinkToUser1765628229160'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "user_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_7bdaa0714f4c1087a926a2d8369" UNIQUE ("username"), CONSTRAINT "REL_8481388d6325e752cd4d7e26c6" UNIQUE ("userId"))`);
        await queryRunner.query(`CREATE TABLE "temporary_users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "temporary_users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "users"`);
        await queryRunner.query(`DROP TABLE "users"`);
        await queryRunner.query(`ALTER TABLE "temporary_users" RENAME TO "users"`);
        await queryRunner.query(`CREATE TABLE "temporary_user_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_7bdaa0714f4c1087a926a2d8369" UNIQUE ("username"), CONSTRAINT "REL_8481388d6325e752cd4d7e26c6" UNIQUE ("userId"), CONSTRAINT "FK_8481388d6325e752cd4d7e26c6d" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_user_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "user_profiles"`);
        await queryRunner.query(`DROP TABLE "user_profiles"`);
        await queryRunner.query(`ALTER TABLE "temporary_user_profiles" RENAME TO "user_profiles"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "user_profiles" RENAME TO "temporary_user_profiles"`);
        await queryRunner.query(`CREATE TABLE "user_profiles" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "username" varchar, "bio" text, "picture" varchar, "userId" integer, CONSTRAINT "UQ_7bdaa0714f4c1087a926a2d8369" UNIQUE ("username"), CONSTRAINT "REL_8481388d6325e752cd4d7e26c6" UNIQUE ("userId"))`);
        await queryRunner.query(`INSERT INTO "user_profiles"("id", "username", "bio", "picture", "userId") SELECT "id", "username", "bio", "picture", "userId" FROM "temporary_user_profiles"`);
        await queryRunner.query(`DROP TABLE "temporary_user_profiles"`);
        await queryRunner.query(`ALTER TABLE "users" RENAME TO "temporary_users"`);
        await queryRunner.query(`CREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(100) NOT NULL, "password" varchar, "emailVerifiedAt" datetime, "provider" varchar CHECK( "provider" IN ('google','github') ), "providerId" varchar, "picture" varchar, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"))`);
        await queryRunner.query(`INSERT INTO "users"("id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId") SELECT "id", "name", "email", "password", "emailVerifiedAt", "provider", "providerId" FROM "temporary_users"`);
        await queryRunner.query(`DROP TABLE "temporary_users"`);
        await queryRunner.query(`DROP TABLE "user_profiles"`);
    }

}

---


### FILE: backend/src/database/migrations/1766761884496-RemoveIdFromMembRequests.ts ###
import { MigrationInterface, QueryRunner } from "typeorm";

export class RemoveIdFromMembRequests1766761884496 implements MigrationInterface {
    name = 'RemoveIdFromMembRequests1766761884496'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "temporary_community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "temporary_community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "temporary_community_membership_requests" RENAME TO "community_membership_requests"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), PRIMARY KEY ("userId", "communityId"))`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')))`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
        await queryRunner.query(`ALTER TABLE "community_membership_requests" RENAME TO "temporary_community_membership_requests"`);
        await queryRunner.query(`CREATE TABLE "community_membership_requests" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "userId" integer NOT NULL, "communityId" integer NOT NULL, "status" varchar CHECK( "status" IN ('pending','accepted','rejected') ) NOT NULL DEFAULT ('pending'), "createdAt" datetime NOT NULL DEFAULT (datetime('now')), CONSTRAINT "FK_c2cdfa8ac8820dca58f4a706773" FOREIGN KEY ("communityId") REFERENCES "communities" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT "FK_f41b77e974eb717317d0b8d6469" FOREIGN KEY ("userId") REFERENCES "users" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION)`);
        await queryRunner.query(`INSERT INTO "community_membership_requests"("userId", "communityId", "status", "createdAt") SELECT "userId", "communityId", "status", "createdAt" FROM "temporary_community_membership_requests"`);
        await queryRunner.query(`DROP TABLE "temporary_community_membership_requests"`);
    }

}

---


### FILE: backend/src/community-memberships/types.ts ###
export enum CommunityMembershipRole {
  OWNER = 'owner',        // top-level owner (creator / transferable)
  ADMIN = 'admin',        // delegated community admins / managers
  MODERATOR = 'moderator',
  MEMBER = 'member',
}

---


### FILE: backend/src/community-memberships/community-memberships.controller.ts ###
import {
  Controller,
  Post,
  Param,
  ParseIntPipe,
  Delete,
  UseGuards,
  Get,
  Query,
} from '@nestjs/common';
import { CommunityMembershipsService } from './community-memberships.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { User } from '../users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { CommunityMembershipQueryDto } from './dto/community-memberships-query.dto';
import { CommunityMembershipResponseDto } from './dto/community-memberships-response.dto';

@Controller()
export class CommunityMembershipsController {
  constructor(
    private readonly communityMembershipsService: CommunityMembershipsService,
  ) { }


  // Unified GET endpoint
  @Get('community-memberships')
  async findMemberships(
   @Query() query: CommunityMembershipQueryDto,
  ): Promise<PaginatedResponseDto<CommunityMembershipResponseDto>> {
    

    const { data, count } = await this.communityMembershipsService.findMemberships({
      userId:query.userId,
      communityId:query.communityId ,
      page:query.page ,
      limit : query.limit
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(CommunityMembershipResponseDto.fromEntity), paginationMeta);
  }


  
@UseGuards(JwtAuthGuard)
  @Delete('users/me/communities/:communityId/memberships')
  async deleteMembership(
    @Param('communityId', ParseIntPipe) communityId: number,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    await this.communityMembershipsService.deleteMembership(communityId, user.id);
    return new ResponseDto(true);
  }
}


---


### FILE: backend/src/community-memberships/community-memberships.service.ts ###
import {
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm'; // Added DataSource
import { User } from '../users/entities/user.entity';
// import { CommunitiesService } from '../communities/communities.service'; // This import is removed
import { Community } from '../communities/entities/community.entity'; // Added Community entity

import { CommunityMembership } from './entities/community-memberships.entity';

interface MembershipQuery {
  userId?: number;
  communityId?: number;
  page?: number;
  limit?: number;
}

@Injectable()
export class CommunityMembershipsService {
  constructor(
    @InjectRepository(CommunityMembership)
    private readonly membershipsRepository: Repository<CommunityMembership>,
    // private readonly communitiesService: CommunitiesService, // This is removed
    @InjectRepository(User)
    private readonly usersRepository: Repository<User>,
    @InjectRepository(Community) // Injected Community repository
    private readonly communityRepository: Repository<Community>,
    private dataSource: DataSource, // Injected DataSource
  ) { }


  async findMemberships(query: MembershipQuery): Promise<{ data: CommunityMembership[]; count: number }> {
    const where: any = {};
    const relations: string[] = [];

    if (query.userId) {
      where.userId = query.userId;
      relations.push('community');
    }

    if (query.communityId) {
      where.communityId = query.communityId;
      relations.push('user');
    }

    const options: any = { where, relations };

    // Pagination
    if (query.page !== undefined && query.limit !== undefined) {
      const page = Math.max(1, query.page);
      const limit = Math.max(1, query.limit);
      options.skip = (page - 1) * limit;
      options.take = limit;
    }

    const [data, count] = await this.membershipsRepository.findAndCount(options);
    return { data, count };
  }

  async findOne(userId: number, communityId: number): Promise<CommunityMembership | null> {
    return this.membershipsRepository.findOne({
      where: { userId, communityId },
    });
  }
  
  async deleteMembership(communityId: number, userId: number) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // Check community existence
      const community = await queryRunner.manager.findOne(Community, { where: { id: communityId } });
      if (!community) throw new NotFoundException(`Community ${communityId} not found`);

      // Check user existence via UsersService
      const userExists = await queryRunner.manager.exists(User, {
        where: { id: userId },
      });
      if (!userExists) {
        throw new NotFoundException(`User ${userId} not found`);
      }

      const existingMembership = await queryRunner.manager.findOne(CommunityMembership, {
        where: {
          userId: userId,
          communityId: community.id,
        },
      });

      if (!existingMembership) {
        throw new NotFoundException(
          `User ${userId} is not member of to community ${community.id}`,
        );
      }

      await queryRunner.manager.remove(existingMembership);

      // Decrement membersCount directly using the repository within the transaction
      await queryRunner.manager.decrement(Community, { id: community.id }, 'membersCount', 1);

      await queryRunner.commitTransaction();
      return { message: 'Left community successfully' };
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }



}

---


### FILE: backend/src/community-memberships/entities/community-memberships.entity.ts ###
import {
  Column,
  CreateDateColumn,
  Entity,
  ManyToOne,
  PrimaryColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';
import { CommunityMembershipRole } from '../types';

@Entity('community_memberships')
export class CommunityMembership {
  @PrimaryColumn()
  userId: number;

  @PrimaryColumn()
  communityId: number;

  @ManyToOne(() => User, (user) => user.communityMemberships)
  user: User;

  @ManyToOne(() => Community, (community) => community.memberships)
  community: Community;

  @Column({
    type: 'simple-enum',
    enum: CommunityMembershipRole,
    default: CommunityMembershipRole.MEMBER,
  })
  role: CommunityMembershipRole;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: backend/src/community-memberships/community-memberships.module.ts ###
import { Module } from '@nestjs/common';
import { CommunityMembershipsService } from './community-memberships.service';
import { CommunityMembershipsController } from './community-memberships.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CommunitiesModule } from '../communities/communities.module';
import { UsersModule } from 'src/users/users.module';
import { User } from 'src/users/entities/user.entity';
import { Community } from '../communities/entities/community.entity';
import { CommunityMembership } from './entities/community-memberships.entity';

@Module({
  imports: [TypeOrmModule.forFeature([CommunityMembership, User, Community]), 
  CommunitiesModule],
  controllers: [CommunityMembershipsController],
  providers: [CommunityMembershipsService],
  exports: [CommunityMembershipsService],
})
export class CommunityMembershipsModule {}

---


### FILE: backend/src/community-memberships/dto/community-memberships-query.dto.ts ###
import { IsBoolean, IsNumber, IsOptional, IsString } from 'class-validator';
import { PaginationDto } from '../../common/dto/pagination.dto';
import { Transform } from 'class-transformer';

export class CommunityMembershipQueryDto extends PaginationDto {
  @IsOptional()
  @IsNumber()
  userId?: number;

  @IsOptional()
  @IsNumber()
  communityId?: number;

 
}

---


### FILE: backend/src/community-memberships/dto/community-memberships-response.dto.ts ###
import { Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { CommunityResponseDto } from '../../communities/dto/community-response.dto';
import { CommunityMembership } from '../entities/community-memberships.entity';
import { CommunityMembershipRole } from '../types';

export class CommunityMembershipResponseDto {
  @Expose()
  userId: number;

  @Expose()
  communityId: number;

  @Expose()
  @Type(() => UserResponseDto)
  user: UserResponseDto;

  @Expose()
  @Type(() => CommunityResponseDto)
  community: CommunityResponseDto;

 @Expose()
  role: CommunityMembershipRole;

  @Expose()
  createdAt: Date;

  static fromEntity(
    entity: CommunityMembership,
  ): CommunityMembershipResponseDto {
    return plainToInstance(CommunityMembershipResponseDto, entity);
  }
}

---


### FILE: backend/src/main.ts ###
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { useContainer } from 'class-validator';
import { NestExpressApplication } from '@nestjs/platform-express';
import { join } from 'path';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  // Use validation pipe globally
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true, // auto-convert types
      transformOptions: {
        enableImplicitConversion: true, // allows automatic type conversion
      },
    }),
  );
     app.setGlobalPrefix('api'); // all routes will now start with /api

app.enableCors({
  origin: '*', // allow any origin
});

  // Get ConfigService instance
  const configService = app.get(ConfigService);
  const port = configService.get<number>('PORT') ?? 3000;

  // Serve static files from the 'uploads' directory
  app.useStaticAssets(join(__dirname, '..', 'uploads'), {
    prefix: '/uploads/',
  });

  await app.listen(port);
  console.log(`Application is running on: http://localhost:${port}`);
}
bootstrap();

---


### FILE: backend/src/users/pipes/user.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { UsersService } from '../users.service';
import { User } from '../entities/user.entity';

@Injectable()
export class UserPipe implements PipeTransform<string, Promise<User>> {
  constructor(private readonly usersService: UsersService) {}

  async transform(value: string): Promise<User> {
    return this.usersService.findOneById(+value);
  }
}

---


### FILE: backend/src/users/users.service.ts ###
// src/users/users.service.ts
import { BadRequestException, ConflictException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Brackets, Not, Repository } from 'typeorm';
import * as bcrypt from 'bcrypt';
import { User } from './entities/user.entity';
import { ProfileService } from '../profile/profile.service'; // Import ProfileService

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private readonly repo: Repository<User>,
  ) {}

  async findAll(
    page = 1,
    limit = 10,
    search?: string,
    provider?: 'google' | 'github',
  ): Promise<{ data: User[]; count: number }> {
    const query = this.repo.createQueryBuilder('user').leftJoinAndSelect('user.profile', 'profile'); // Eagerly load profile

    if (search) {
      query.where(
        new Brackets((qb) => {
          qb.where('user.name LIKE :search', {
            search: `%${search}%`,
          }).orWhere('user.email LIKE :search', { search: `%${search}%` })
          .orWhere('profile.username LIKE :search', { search: `%${search}%` }); // Search in profile username
        }),
      );
    }

    if (provider) {
      query.andWhere('user.provider = :provider', { provider });
    }

    query.orderBy('user.createdAt', 'DESC');

    const [data, count] = await query
      .take(limit)
      .skip((page - 1) * limit)
      .getManyAndCount();

    return { data, count };
  }


  private async find(where: any, message: string): Promise<User> {
    const user = await this.repo.findOne({ where, relations: ['profile'] }); // Eagerly load profile
    if (!user) throw new NotFoundException(message);
    return user;
  }


  async findOneById(id: number): Promise<User> {
    return this.find({ id }, `User with ID ${id} not found.`);
  }

  async findByEmail(email: string): Promise<User> {
    return this.find({ email }, `User with email ${email} not found.`);
  }


async createUser({
  name,
  email,
  password,
  provider,
  providerId,
  emailVerifiedAt,
}: {
  name: string;
  email: string;
  password?: string | null;
  provider?: 'google' | 'github' | null;
  providerId?: string | null;
  emailVerifiedAt?: Date | null;
}): Promise<User> {

  const emailExists = await this.repo.exists({ where: { email } });
  if (emailExists) {
    throw new ConflictException('Email already in use');
  }

  if (provider && password) {
    throw new BadRequestException(
      'Password-based accounts cannot have a provider',
    );
  }

  if (provider && !providerId) {
    throw new BadRequestException('providerId is required when provider is set');
  }

  const user = this.repo.create({
    name,
    email,
    provider: provider ?? null,
    providerId: providerId ?? null,
    emailVerifiedAt:
      emailVerifiedAt ?? (password ? null : new Date()),
    password: password
      ? await bcrypt.hash(password, 10)
      : null,
  });

  return this.repo.save(user);
}
 async updateUser({
  user,
  name,
  email,
  password,
  provider,
  providerId,
  emailVerifiedAt,
}: {
  user: User;
  name?: string;
  email?: string;
  password?: string | null;
  provider?: 'google' | 'github' | null;
  providerId?: string | null;
  emailVerifiedAt?: Date | null;
}): Promise<User> {
  
  if (email !== undefined && email !== user.email) {
    const emailExists = await this.repo.exists({
      where: {
        email,
        id: Not(user.id),
      },
    });

    if (emailExists) {
      throw new ConflictException('Email already in use');
    }
  }

  if (provider !== undefined && password !== undefined) {
    throw new BadRequestException(
      'Cannot update provider and password together',
    );
  }

  if (provider !== undefined && provider && !providerId) {
    throw new BadRequestException(
      'providerId is required when provider is set',
    );
  }

  Object.assign(user, {
    ...(name !== undefined && { name }),
    ...(email !== undefined && { email }),
    ...(provider !== undefined && { provider }),
    ...(providerId !== undefined && { providerId }),
    ...(emailVerifiedAt !== undefined && { emailVerifiedAt }),
  });

  if (password !== undefined) {
    user.password = password
      ? await bcrypt.hash(password, 10)
      : null;
  }

  return this.repo.save(user);
}


  async markEmailAsVerified(id: number): Promise<void> {
    const user = await this.findOneById(id);

    if (!user.emailVerifiedAt) {
      user.emailVerifiedAt = new Date();
      await this.repo.save(user);
    }
  }
}
---


### FILE: backend/src/users/dtos/user-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsString, IsEnum } from 'class-validator';

export class UserQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  search?: string; // Filter by name or email

  @IsOptional()
  @IsEnum(['google', 'github'])
  provider?: 'google' | 'github';
}

---


### FILE: backend/src/users/dtos/user-response.dto.ts ###
import { Exclude, Expose, plainToInstance } from 'class-transformer';
import { User } from '../entities/user.entity';

@Exclude()
export class UserResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly name: string;
  @Expose() readonly email: string;
  @Expose() readonly emailVerifiedAt: Date | null;
  @Expose() readonly provider: string | null;

  static fromEntity(entity: User): UserResponseDto {
    return plainToInstance(UserResponseDto, entity, {
      excludeExtraneousValues: true,
    });
  }
}

---


### FILE: backend/src/users/users.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  imports: [TypeOrmModule.forFeature([User])], // Add ProfileModule here
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService], // Export the service so it can be injected elsewhere
})
export class UsersModule {}

---


### FILE: backend/src/users/entities/user.entity.ts ###
// src/users/entities/user.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToMany,
  OneToOne,
  JoinColumn,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { Comment } from '../../comments/entities/comment.entity';
import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { Profile } from '../../profile/entities/profile.entity'; // Import Profile
import { Community } from '../../communities/entities/community.entity';
import { CommunityMembership } from '../../community-memberships/entities/community-memberships.entity';
import { CommunityMembershipRequest } from '../../community-membership-requests/entities/community-membership-request.entity';
import { PostReport } from '../../reports/entities/post-report.entity';
import { CommunityRestriction } from '../../community-restrictions/entities/community-restriction.entity';
import { CommentReport } from '../../reports/entities/comment-report.entity'; // NEW IMPORT
import { UserReport } from '../../reports/entities/user-report.entity'; // NEW IMPORT


export enum UserRole {
  SUPER_ADMIN,
  ADMIN,
  USER
}

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 100 })
  name: string;

  @Column({ type: 'varchar', length: 100, unique: true })
  email: string;

  @Column({ type: 'varchar', nullable: true })
  password: string | null;

  @Column({ type: 'datetime', nullable: true, default: null })
  emailVerifiedAt: Date | null; // üëà NEW FIELD

  @Column({
    type: 'simple-enum',
    enum: ['google', 'github'],
    nullable: true,
    default: null,
  })
  provider: 'google' | 'github' | null;

  @Column({ type: 'varchar', nullable: true })
  providerId: string | null; // Google's profile.id

  // One-to-one relation with Profile
  @OneToOne(() => Profile, (profile) => profile.user)
  profile: Profile;

  @Column({
    type: 'simple-enum', // sqlite compatible
    enum: UserRole,
    default: UserRole.USER,
  })
  role: UserRole;

  // Relations
  @OneToMany(() => Post, (post) => post.author)
  posts: Post[];

  @OneToMany(() => Comment, (comment) => comment.author)
  comments: Comment[];

  @OneToMany(() => PostReaction, (reaction) => reaction.user)
  postReactions: PostReaction[];

  @OneToMany(() => CommentReaction, (reaction) => reaction.user)
  commentReactions: CommentReaction[];

  @OneToMany(() => Community, (community) => community.owner)
  createdCommunities: Community[];

  @OneToMany(
    () => CommunityMembership,
    (communityMembership) => communityMembership.user,
  )
  communityMemberships: CommunityMembership[];

  @OneToMany(
    () => CommunityMembershipRequest,
    (request) => request.user,
  )
  communityMembershipRequests: CommunityMembershipRequest[];

  @OneToMany(() => PostReport, (postReport) => postReport.reporter)
  postReports: PostReport[];

  @OneToMany(() => CommentReport, (commentReport) => commentReport.reporter) // NEW RELATION
  commentReports: CommentReport[];

  @OneToMany(() => UserReport, (userReport) => userReport.reporter)
  reportedUserReports: UserReport[];

  @OneToMany(() => UserReport, (userReport) => userReport.reportedUser)
  userReports: UserReport[];

  @OneToMany(
    () => CommunityRestriction,
    (restriction) => restriction.user,
  )
  communityRestrictions: CommunityRestriction[];
}
---


### FILE: backend/src/users/users.controller.ts ###
import { Controller, Get, Query } from '@nestjs/common';
import { UsersService } from './users.service';
import { UserQueryDto } from './dtos/user-query.dto';
import { UserResponseDto } from './dtos/user-response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  async findAll(@Query() query: UserQueryDto): Promise<PaginatedResponseDto<UserResponseDto>> {
    const { data, count } = await this.usersService.findAll(
      query.page,
      query.limit,
      query.search,
      query.provider,
    );

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(UserResponseDto.fromEntity), paginationMeta);
  }
}

---


### FILE: backend/src/community-membership-requests/community-membership-requests.controller.ts ###
import {
  Controller,
  Post,
  Param,
  ParseIntPipe,
  UseGuards,
  Delete,
  Get,
  Query,
} from '@nestjs/common';
import { CommunityMembershipRequestsService } from './community-membership-requests.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { GetUser } from '../decorators/user.decorator';
import { User } from '../users/entities/user.entity';
import { ResponseDto } from 'src/common/dto/response.dto';
import { CommunityMembershipRequestResponseDto } from './dto/community-membership-request-response.dto';
import { CommunityMembershipRequestQueryDto } from './dto/community-membership-request-query.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';

@UseGuards(JwtAuthGuard)
@Controller('communities/:communityId/membership-requests')
export class CommunityMembershipRequestsController {
  constructor(
    private readonly requestsService: CommunityMembershipRequestsService,
  ) {}

  /** List all pending requests for a community (for admins/mods) */
  @Get()
  async listRequests(
    @Param('communityId', ParseIntPipe) communityId: number,
    @Query() query: CommunityMembershipRequestQueryDto,
  ): Promise<PaginatedResponseDto<CommunityMembershipRequestResponseDto>> {
    const { data, count } = await this.requestsService.findMany({
      ...query,
      communityId,
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(
      data.map(CommunityMembershipRequestResponseDto.fromEntity),
      paginationMeta,
    );
  }

  /** Create a join request (or auto-join if public) for the logged-in user */
  @Post()
  async createRequest(
    @Param('communityId', ParseIntPipe) communityId: number,
    @GetUser() user: User,
  ) {
    return this.requestsService.createMembershipRequest(user.id, communityId);
  }

@Delete('me')
removeOwnRequest(
  @Param('communityId', ParseIntPipe) communityId: number,
  @GetUser() user: User,
) {
  return this.requestsService.removeOwnRequest(user.id, communityId);
}

@Delete(':userId')
removeRequest(
  @Param('communityId', ParseIntPipe) communityId: number,
  @Param('userId', ParseIntPipe) userId: number,
  @GetUser() actor: User,
) {
  return this.requestsService.removeMembershipRequest(
    actor.id,
    userId,
    communityId,
  );
}

}

---


### FILE: backend/src/community-membership-requests/community-membership-requests.module.ts ###
import { Module } from '@nestjs/common';
import { CommunityMembershipRequestsService } from './community-membership-requests.service';
import { CommunityMembershipRequestsController } from './community-membership-requests.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CommunityMembershipRequest } from './entities/community-membership-request.entity';
import { CommunityMembership } from '../community-memberships/entities/community-memberships.entity';
import { User } from '../users/entities/user.entity';
import { Community } from '../communities/entities/community.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      CommunityMembershipRequest,
      CommunityMembership,
      User,
      Community,
    ]),
  ],
  controllers: [CommunityMembershipRequestsController],
  providers: [CommunityMembershipRequestsService],
})
export class CommunityMembershipRequestsModule {}

---


### FILE: backend/src/community-membership-requests/community-membership-requests.service.ts ###
import {
  BadRequestException,
  ForbiddenException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  CommunityMembershipRequest,
  CommunityMembershipRequestStatus,
} from './entities/community-membership-request.entity';
import { Brackets, DataSource, In, Repository } from 'typeorm';
import { CommunityMembership } from '../community-memberships/entities/community-memberships.entity';
import { User } from '../users/entities/user.entity';
import { Community } from '../communities/entities/community.entity';
import { CommunityMembershipRole } from '../community-memberships/types';
import { CommunityType } from '../communities/types';
import {
  CommunityMembershipRequestQueryDto,
  CommunityMembershipRequestSort,
} from './dto/community-membership-request-query.dto';

@Injectable()
export class CommunityMembershipRequestsService {
  constructor(
    @InjectRepository(CommunityMembershipRequest)
    private readonly requestRepository: Repository<CommunityMembershipRequest>,
    @InjectRepository(CommunityMembership)
    private readonly membershipRepository: Repository<CommunityMembership>,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(Community)
    private readonly communityRepository: Repository<Community>,
    private dataSource: DataSource,
  ) {}

  async findMany(
    queryDto: CommunityMembershipRequestQueryDto,
  ): Promise<{ data: CommunityMembershipRequest[]; count: number }> {
    const { page, limit, userId, communityId, status, sort } = queryDto;

    const queryBuilder = this.requestRepository
      .createQueryBuilder('request')
      .leftJoinAndSelect('request.user', 'user')
      .leftJoinAndSelect('request.community', 'community');

    if (userId) {
      queryBuilder.andWhere('request.userId = :userId', { userId });
    }

    if (communityId) {
      queryBuilder.andWhere('request.communityId = :communityId', { communityId });
    }

    if (status) {
      queryBuilder.andWhere('request.status = :status', { status });
    }

    if (sort === CommunityMembershipRequestSort.NEWEST) {
      queryBuilder.orderBy('request.createdAt', 'DESC');
    } else if (sort === CommunityMembershipRequestSort.OLDEST) {
      queryBuilder.orderBy('request.createdAt', 'ASC');
    } else {
      queryBuilder.orderBy('request.createdAt', 'DESC'); // Default sort
    }

    const [data, count] = await queryBuilder
      .take(limit)
      .skip((page - 1) * limit)
      .getManyAndCount();

    return { data, count };
  }

  async createMembershipRequest(userId: number, communityId: number) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const user = await queryRunner.manager.findOne(User, { where: { id: userId } });
      if (!user) {
        throw new NotFoundException('User not found');
      }

      const community = await queryRunner.manager.findOne(Community, {
        where: { id: communityId },
        select: ['id', 'ownerId', 'communityType'], // Select communityType
      });
      if (!community) {
        throw new NotFoundException('Community not found');
      }

      const existingMembership = await queryRunner.manager.findOne(CommunityMembership, {
        where: { userId, communityId },
      });
      if (existingMembership) {
        throw new BadRequestException('User is already a member of this community');
      }

      // If community is public, create membership directly
      if (community.communityType === CommunityType.PUBLIC) {
        const membership = queryRunner.manager.create(CommunityMembership, {
          userId,
          communityId,
          role: CommunityMembershipRole.MEMBER, // Default role for auto-membership
        });
        await queryRunner.manager.save(membership);
        await queryRunner.manager.increment(Community, { id: community.id }, 'membersCount', 1);
        await queryRunner.commitTransaction();
        return membership;
      } else {
        // For restricted or private communities, create a pending request
        const existingRequest = await queryRunner.manager.findOne(CommunityMembershipRequest, {
          where: { userId, communityId, status: CommunityMembershipRequestStatus.PENDING },
        });
        if (existingRequest) {
          throw new BadRequestException('Pending request already exists');
        }

        const request = queryRunner.manager.create(CommunityMembershipRequest, {
          userId,
          communityId,
        });
        await queryRunner.manager.save(request);
        await queryRunner.commitTransaction();
        return request;
      }
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }
async acceptMembershipRequest(
  actorId: number,
  userId: number,
  communityId: number,
) {
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();

  try {
    // 1. Fetch pending request
    const request = await queryRunner.manager.findOne(
      CommunityMembershipRequest,
      {
        where: {
          userId,
          communityId,
          status: CommunityMembershipRequestStatus.PENDING,
        },
      },
    );

    if (!request) {
      throw new NotFoundException('Pending membership request not found');
    }

    // 2. Authorization: owner OR admin
  await this.canManageMembershipRequests(actorId,communityId)


    // 3. Create membership (idempotent-safe)
    await queryRunner.manager.insert(CommunityMembership, {
      userId,
      communityId,
      role: CommunityMembershipRole.MEMBER,
    });

    // 4. Mark request accepted
    await queryRunner.manager.update(
      CommunityMembershipRequest,
      { userId, communityId },
      { status: CommunityMembershipRequestStatus.ACCEPTED },
    );

    // 5. Increment members count
    await queryRunner.manager.increment(
      Community,
      { id: communityId },
      'membersCount',
      1,
    );

    await queryRunner.commitTransaction();
    return true;
  } catch (err) {
    await queryRunner.rollbackTransaction();
    throw err;
  } finally {
    await queryRunner.release();
  }
}

async removeMembershipRequest(
  actorId: number,
  userId: number,
  communityId: number,
) {
  // 1Ô∏è‚É£ Check pending request exists
  const request = await this.requestRepository.findOne({
    where: {
      userId,
      communityId,
      status: CommunityMembershipRequestStatus.PENDING,
    },
  });

  if (!request) {
    throw new NotFoundException('Pending membership request not found');
  }

  // 2Ô∏è‚É£ Check actor role in THIS community
 await this.canManageMembershipRequests(actorId,communityId)

  // 3Ô∏è‚É£ Delete request
   await this.requestRepository.delete({ userId: request.userId,communityId:communityId });

  return true;
}
async removeOwnRequest(
  userId: number,
  communityId: number,
): Promise<boolean> {
  const request = await this.requestRepository.findOne({
    where: {
      userId,
      communityId,
      status: CommunityMembershipRequestStatus.PENDING,
    },
  });

  if (!request) {
    throw new NotFoundException('Pending membership request not found');
  }

  await this.requestRepository.delete({
    userId,
    communityId,
    status: CommunityMembershipRequestStatus.PENDING,
  });

  return true;
}
  private async canManageMembershipRequests(actorId: number, communityId: number) {
    const membership = await this.membershipRepository.findOne({
      where: {
        userId: actorId,
        communityId,
        role: In([CommunityMembershipRole.OWNER, CommunityMembershipRole.ADMIN,CommunityMembershipRole.MODERATOR]),
      },
    });

    if (!membership) {
      throw new ForbiddenException('You are not allowed to manage membership requests for this community');
    }

    return membership; // optional, in case you want actor info
  }
 }

---


### FILE: backend/src/community-membership-requests/entities/community-membership-request.entity.ts ###
import {
  CreateDateColumn,
  Entity,
  ManyToOne,
  Column,
  PrimaryColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';

export enum CommunityMembershipRequestStatus {
  PENDING = 'pending',
  ACCEPTED = 'accepted',
  REJECTED = 'rejected',
}

@Entity('community_membership_requests')
export class CommunityMembershipRequest {
  // Composite primary key: userId + communityId
  @PrimaryColumn()
  userId: number;

  @PrimaryColumn()
  communityId: number;

  @ManyToOne(() => User, (user) => user.communityMembershipRequests)
  user: User;

  @ManyToOne(() => Community, (community) => community.membershipRequests)
  community: Community;

  @Column({
    type: 'simple-enum',
    enum: CommunityMembershipRequestStatus,
    default: CommunityMembershipRequestStatus.PENDING,
  })
  status: CommunityMembershipRequestStatus;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: backend/src/community-membership-requests/dto/community-membership-request-response.dto.ts ###
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { CommunityResponseDto } from '../../communities/dto/community-response.dto';
import { CommunityMembershipRequest, CommunityMembershipRequestStatus } from '../entities/community-membership-request.entity';

@Exclude()
export class CommunityMembershipRequestResponseDto {
  @Expose() readonly id: number;

  @Expose() readonly userId: number;
  @Expose() readonly communityId: number;

  @Expose() @Type(() => UserResponseDto) readonly user: UserResponseDto;
  @Expose() @Type(() => CommunityResponseDto) readonly community: CommunityResponseDto;

  @Expose() readonly status: CommunityMembershipRequestStatus;
  @Expose() readonly createdAt: Date;

  static fromEntity(entity: CommunityMembershipRequest): CommunityMembershipRequestResponseDto {
    return plainToInstance(
      CommunityMembershipRequestResponseDto,
      {
        ...entity,
        user: entity.user ? UserResponseDto.fromEntity(entity.user) : null,
        community: entity.community ? CommunityResponseDto.fromEntity(entity.community) : null,
      },
      { excludeExtraneousValues: true },
    );
  }
}

---


### FILE: backend/src/community-membership-requests/dto/community-membership-request-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsInt, IsEnum } from 'class-validator';
import { Type } from 'class-transformer';
import { CommunityMembershipRequestStatus } from '../entities/community-membership-request.entity';

export enum CommunityMembershipRequestSort {
  NEWEST = 'newest',
  OLDEST = 'oldest',
}

export class CommunityMembershipRequestQueryDto extends PaginationDto {
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  userId?: number;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  communityId?: number;

  @IsOptional()
  @IsEnum(CommunityMembershipRequestStatus)
  status?: CommunityMembershipRequestStatus;

  @IsOptional()
  @IsEnum(CommunityMembershipRequestSort)
  sort?: CommunityMembershipRequestSort;
}

---


### FILE: backend/src/reactions/pipes/post-reaction.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { ReactionsService } from '../reactions.service';
import { PostReaction } from '../entities/post-reaction.entity';

@Injectable()
export class PostReactionPipe implements PipeTransform<
  string,
  Promise<PostReaction>
> {
  constructor(private readonly reactionsService: ReactionsService) {}

  async transform(value: string): Promise<PostReaction> {
    return this.reactionsService.findPostReactionById(+value);
  }
}

---


### FILE: backend/src/reactions/pipes/comment-reaction.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { ReactionsService } from '../reactions.service';
import { CommentReaction } from '../entities/comment-reaction.entity';

@Injectable()
export class CommentReactionPipe implements PipeTransform<
  string,
  Promise<CommentReaction>
> {
  constructor(private readonly reactionsService: ReactionsService) {}

  async transform(value: string): Promise<CommentReaction> {
    return this.reactionsService.findCommentReactionById(+value);
  }
}

---


### FILE: backend/src/reactions/reactions.controller.ts ###
import {
  Controller,
  Post,
  Get,
  Body,
  Param,
  Delete,
  UseGuards,
  NotFoundException,
  Query,
  Patch,
} from '@nestjs/common';
import { ReactionsService } from './reactions.service';
import { CreateReactionDto } from './dto/create-reaction.dto';
import { UpdateReactionDto } from './dto/update-reaction.dto';
import { User } from 'src/users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { Action } from 'src/casl/casl.types';
import { PostReaction } from './entities/post-reaction.entity';
import { CommentReaction } from './entities/comment-reaction.entity';
import { Post as PostEntity } from '../posts/entities/post.entity';
import { Comment as CommentEntity } from '../comments/entities/comment.entity';
import { CaslService } from 'src/casl/casl.service';
import { ReactionResponseDto } from './dto/reaction-response.dto';
import { PostReactionPipe } from './pipes/post-reaction.pipe';
import { CommentReactionPipe } from './pipes/comment-reaction.pipe';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { ReactionQueryDto } from './dto/reaction-query.dto';
import { CommentPipe } from 'src/comments/pipes/comment.pipe';
import { PostPipe } from 'src/posts/pipes/post.pipe';


@Controller()
export class ReactionsController {
  constructor(
    private readonly reactionsService: ReactionsService,
    private readonly caslService: CaslService,
  ) {}

  @Post('posts/:postId/reactions')
  @UseGuards(JwtAuthGuard)
  async createPostReaction(
    @Param('postId', PostPipe) post: PostEntity,
    @Body() dto: CreateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Create, PostReaction);
    const reaction = await this.reactionsService.create(
     {   type :dto.type,
      userId :user.id,
      postId: post.id,}
    );
    return new ResponseDto(ReactionResponseDto.fromEntity(reaction));
  }

  @Get('posts/:postId/reactions')
  async getPostReactions(
    @Param('postId', PostPipe) post: PostEntity,
    @Query() query: ReactionQueryDto,
  ): Promise<PaginatedResponseDto<ReactionResponseDto>> {
    const { data, count } = await this.reactionsService.findByPost({ postId: post.id, page: query.page, limit: query.limit });
    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );
    return new PaginatedResponseDto(data.map(ReactionResponseDto.fromEntity), paginationMeta);
  }

  @Patch('posts/:postId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async updatePostReaction(
    @Param('reactionId', PostReactionPipe) reaction: PostReaction,
    @Body() dto: UpdateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Update, reaction);
    const updatedReaction = await this.reactionsService.updatePostReaction({
       id:reaction.id,
       type:dto.type});
    return new ResponseDto(ReactionResponseDto.fromEntity(updatedReaction));
  }

  @Post('comments/:commentId/reactions')
  @UseGuards(JwtAuthGuard)
  async createCommentReaction(
    @Param('commentId', CommentPipe) comment: CommentEntity,
    @Body() dto: CreateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Create, CommentReaction);
    const reaction = await this.reactionsService.create(
   {   type :dto.type,
      userId :user.id,
      commentId: comment.id,}
    );
    return new ResponseDto(ReactionResponseDto.fromEntity(reaction));
  }

  @Get('comments/:commentId/reactions')
  async getCommentReactions(
    @Param('commentId', CommentPipe) comment: CommentEntity,
    @Query() query: ReactionQueryDto,
  ): Promise<PaginatedResponseDto<ReactionResponseDto>> {
    const { data, count } = await this.reactionsService.findByComment({ commentId: comment.id, page: query.page, limit: query.limit });
    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );
    return new PaginatedResponseDto(data.map(ReactionResponseDto.fromEntity), paginationMeta);
  }

  @Patch('comments/:commentId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async updateCommentReaction(
    @Param('reactionId', CommentReactionPipe) reaction: CommentReaction,
    @Body() dto: UpdateReactionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<ReactionResponseDto>> {
    this.caslService.enforce(user, Action.Update, reaction);
    const updatedReaction = await this.reactionsService.updateCommentReaction({ id:reaction.id,
      type: dto.type});
    return new ResponseDto(ReactionResponseDto.fromEntity(updatedReaction));
  }

  @Delete('posts/:postId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async deletePostReaction(
    @Param('reactionId', PostReactionPipe) reaction: PostReaction,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, reaction);
    await this.reactionsService.deletePostReaction(reaction.id);
    return new ResponseDto(true);
  }

  @Delete('comments/:commentId/reactions/:reactionId')
  @UseGuards(JwtAuthGuard)
  async deleteCommentReaction(
    @Param('reactionId', CommentReactionPipe) reaction: CommentReaction,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, reaction);
    await this.reactionsService.deleteCommentReaction(reaction.id);
    return new ResponseDto(true);
  }
}

---


### FILE: backend/src/reactions/reactions.types.ts ###
export enum ReactionType {
  LIKE = 'like',
  DISLIKE = 'dislike',
}

---


### FILE: backend/src/reactions/reactions.service.ts ###
import {
  Injectable,
  BadRequestException,
  ForbiddenException,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm'; // Added DataSource

import { PostReaction } from './entities/post-reaction.entity';
import { CommentReaction } from './entities/comment-reaction.entity';
import { ReactionType } from './reactions.types';
// import { PostsService } from 'src/posts/posts.service'; // Removed
// import { CommentsService } from 'src/comments/comments.service'; // Removed
import { UpdateReactionDto } from './dto/update-reaction.dto';
import { Post } from 'src/posts/entities/post.entity'; // Added Post entity
import { Comment } from 'src/comments/entities/comment.entity'; // Added Comment entity

@Injectable()
export class ReactionsService {
  constructor(
    @InjectRepository(PostReaction)
    private readonly postReactionRepo: Repository<PostReaction>,

    @InjectRepository(CommentReaction)
    private readonly commentReactionRepo: Repository<CommentReaction>,

    // private readonly postsService: PostsService, // Removed
    // private readonly commentsService: CommentsService, // Removed
    @InjectRepository(Post) // Injected Post repository
    private readonly postRepo: Repository<Post>,
    @InjectRepository(Comment) // Injected Comment repository
    private readonly commentRepo: Repository<Comment>,
    private dataSource: DataSource, // Injected DataSource
  ) { }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // CREATE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async create({
    type,
    userId,
    postId,
    commentId,
  }: {
    type: ReactionType;
    userId: number;
    postId?: number;
    commentId?: number;
  }) {
    if (!Object.values(ReactionType).includes(type)) {
      throw new BadRequestException('Invalid reaction type');
    }

    if (!!postId === !!commentId) {
      throw new BadRequestException(
        'Reaction must target either a post or a comment (not both)',
      );
    }

    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      if (postId) {
        const post = await queryRunner.manager.findOne(Post, { where: { id: postId } });
        if (!post) throw new NotFoundException(`Post with ID ${postId} not found`);

        const existing = await queryRunner.manager.findOne(PostReaction, {
          where: { userId, postId },
        });
        
        if (existing) {
          throw new ForbiddenException(
            'You already reacted to this post',
          );
        }

        const newReaction = queryRunner.manager.create(PostReaction, { type, userId, postId });
        await queryRunner.manager.save(newReaction);

        if (newReaction.type === ReactionType.LIKE) {
          await queryRunner.manager.increment(Post, { id: postId }, 'likesCount', 1);
        } else {
          await queryRunner.manager.increment(Post, { id: postId }, 'dislikesCount', 1);
        }
        await queryRunner.commitTransaction();
        return newReaction;
      }
      else if (commentId) {
        const comment = await queryRunner.manager.findOne(Comment, { where: { id: commentId } });
        if (!comment) throw new NotFoundException(`Comment with ID ${commentId} not found`);

        const existing = await queryRunner.manager.findOne(CommentReaction, {
          where: { userId, commentId },
        });

        if (existing) {
          throw new ForbiddenException(
            'You already reacted to this comment',
          );
        }

        const newReaction = queryRunner.manager.create(CommentReaction, { type, userId, commentId });
        await queryRunner.manager.save(newReaction);

        if (newReaction.type === ReactionType.LIKE) {
          await queryRunner.manager.increment(Comment, { id: commentId }, 'likesCount', 1);
        } else {
          await queryRunner.manager.increment(Comment, { id: commentId }, 'dislikesCount', 1);
        }
        await queryRunner.commitTransaction();
        return newReaction;
      }
      throw new BadRequestException(
        'Reaction must target either a post or a comment',
      );
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }  async findByPost({
    postId,
    page = 1,
    limit = 10,
  }: {
    postId: number;
    page?: number;
    limit?: number;
  }): Promise<{ data: PostReaction[]; count: number }> {
    const skip = (page - 1) * limit;

    const [data, count] = await this.postReactionRepo.findAndCount({
      where: { postId },
      relations: ['user'],
      select: {
        id: true,
        type: true,
        createdAt: true,
        user: { id: true, name: true },
      },
      skip,
      take: limit,
    });

    return { data, count };
  }

  async findByComment({
    commentId,
    page = 1,
    limit = 10,
  }: {
    commentId: number;
    page?: number;
    limit?: number;
  }): Promise<{ data: CommentReaction[]; count: number }> {
    const skip = (page - 1) * limit;

    const [data, count] = await this.commentReactionRepo.findAndCount({
      where: { commentId },
      relations: ['user'],
      select: {
        id: true,
        type: true,
        createdAt: true,
        user: { id: true, name: true },
      },
      skip,
      take: limit,
    });

    return { data, count };
  }

  async getUserReactionOnPost(
    userId: number,
    postId: number,
  ) {
    return this.postReactionRepo.findOne({ where: { userId, postId } });
  }

  async findPostReactionById(id: number): Promise<PostReaction> {
    const reaction = await this.postReactionRepo.findOne({ where: { id } });
    if (!reaction) {
      throw new NotFoundException('Post reaction not found');
    }
    return reaction;
  }

  async findCommentReactionById(id: number): Promise<CommentReaction> {
    const reaction = await this.commentReactionRepo.findOne({ where: { id } });
    if (!reaction) {
      throw new NotFoundException('Comment reaction not found');
    }
    return reaction;
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // UPDATE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 async updatePostReaction({
  id,
  type
}: {
  id: number;
  type: ReactionType;
}) {
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();

  try {
    const reaction = await queryRunner.manager.findOne(PostReaction, { where: { id } });
    if (!reaction) throw new NotFoundException('Post reaction not found');
    
    // Return early if no change
    if (reaction.type === type) {
      await queryRunner.commitTransaction();
      return reaction;
    }

    const oldType = reaction.type;
    const newType = type;
    const postId = reaction.postId;

    // Update counters based on change
    if (oldType === ReactionType.LIKE) {
      await queryRunner.manager.decrement(Post, { id: postId }, 'likesCount', 1);
    } else if (oldType === ReactionType.DISLIKE) {
      await queryRunner.manager.decrement(Post, { id: postId }, 'dislikesCount', 1);
    }

    if (newType === ReactionType.LIKE) {
      await queryRunner.manager.increment(Post, { id: postId }, 'likesCount', 1);
    } else if (newType === ReactionType.DISLIKE) {
      await queryRunner.manager.increment(Post, { id: postId }, 'dislikesCount', 1);
    }

    // Update reaction type
    reaction.type = newType;
    await queryRunner.manager.save(reaction);

    await queryRunner.commitTransaction();
    return reaction;
  } catch (err) {
    await queryRunner.rollbackTransaction();
    throw err;
  } finally {
    await queryRunner.release();
  }
}

async updateCommentReaction({
  id,
  type
}: {
  id: number;
  type: ReactionType;
}) {
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();

  try {
    const reaction = await queryRunner.manager.findOne(CommentReaction, { where: { id } });
    if (!reaction) throw new NotFoundException('Comment reaction not found');

    // Return early if no change
    if (reaction.type === type) {
      await queryRunner.commitTransaction();
      return reaction;
    }

    const oldType = reaction.type;
    const newType = type;
    const commentId = reaction.commentId;

    // Update counters based on change
    if (oldType === ReactionType.LIKE) {
      await queryRunner.manager.decrement(Comment, { id: commentId }, 'likesCount', 1);
    } else if (oldType === ReactionType.DISLIKE) {
      await queryRunner.manager.decrement(Comment, { id: commentId }, 'dislikesCount', 1);
    }

    if (newType === ReactionType.LIKE) {
      await queryRunner.manager.increment(Comment, { id: commentId }, 'likesCount', 1);
    } else if (newType === ReactionType.DISLIKE) {
      await queryRunner.manager.increment(Comment, { id: commentId }, 'dislikesCount', 1);
    }

    // Update reaction type
    reaction.type = newType;
    await queryRunner.manager.save(reaction);

    await queryRunner.commitTransaction();
    return reaction;
  } catch (err) {
    await queryRunner.rollbackTransaction();
    throw err;
  } finally {
    await queryRunner.release();
  }
}
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // DELETE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async deletePostReaction(id: number) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const reaction = await queryRunner.manager.findOne(PostReaction, { where: { id } });
      if (!reaction) {
        throw new NotFoundException('Post reaction not found');
      }

      const result = await queryRunner.manager.delete(PostReaction, id);
      if (result.affected) {
        // No need to fetch post explicitly, can directly decrement
        if (reaction.type === ReactionType.LIKE) {
          await queryRunner.manager.decrement(Post, { id: reaction.postId }, 'likesCount', 1);
        } else {
          await queryRunner.manager.decrement(Post, { id: reaction.postId }, 'dislikesCount', 1);
        }
      }
      await queryRunner.commitTransaction();
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }
  async deleteCommentReaction(id: number) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const reaction = await queryRunner.manager.findOne(CommentReaction, { where: { id } });
      if (!reaction) {
        throw new NotFoundException('Comment reaction not found');
      }

      const result = await queryRunner.manager.delete(CommentReaction, id);
      if (result.affected) {
        // No need to fetch comment explicitly, can directly decrement
        if (reaction.type === ReactionType.LIKE) {
          await queryRunner.manager.decrement(Comment, { id: reaction.commentId }, 'likesCount', 1);
        } else {
          await queryRunner.manager.decrement(Comment, { id: reaction.commentId }, 'dislikesCount', 1);
        }
      }
      await queryRunner.commitTransaction();
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }}

---


### FILE: backend/src/reactions/reactions.module.ts ###
import { Module } from '@nestjs/common';
import { ReactionsService } from './reactions.service';
import { ReactionsController } from './reactions.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PostReaction } from './entities/post-reaction.entity';
import { CommentReaction } from './entities/comment-reaction.entity';
import { CaslModule } from 'src/casl/casl.module';
import { PostsModule } from 'src/posts/posts.module';
import { CommentsModule } from 'src/comments/comments.module';

import { Post } from 'src/posts/entities/post.entity';
import { Comment } from 'src/comments/entities/comment.entity';

@Module({
  providers: [ReactionsService],
  controllers: [ReactionsController],
  imports: [
    TypeOrmModule.forFeature([PostReaction, CommentReaction, Post, Comment]),
    CaslModule,
    PostsModule,
    CommentsModule,
  ],
  exports: [ReactionsService],
})
export class ReactionsModule {}

---


### FILE: backend/src/reactions/entities/post-reaction.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  Index,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { ReactionType } from '../../reactions/reactions.types'; // Assuming ReactionType is still needed and will be moved or re-defined

@Entity('post_reactions')
@Index(['postId', 'userId'], { unique: true }) // Ensure a user can only react once to a post
export class PostReaction {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'simple-enum',
    enum: ReactionType,
  })
  type: ReactionType;

  @ManyToOne(() => Post, (post) => post.reactions, { onDelete: 'CASCADE' })
  post: Post;

  @Column()
  postId: number;

  @ManyToOne(() => User, (user) => user.postReactions, { onDelete: 'CASCADE' })
  user: User;

  @Column()
  userId: number;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

---


### FILE: backend/src/reactions/entities/comment-reaction.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  Index,
} from 'typeorm';
import { Comment } from '../../comments/entities/comment.entity'; // Corrected path
import { User } from '../../users/entities/user.entity';
import { ReactionType } from '../../reactions/reactions.types'; // Assuming ReactionType is still needed and will be moved or re-defined

@Entity('comment_reactions')
@Index(['commentId', 'userId'], { unique: true }) // Ensure a user can only react once to a comment
export class CommentReaction {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'simple-enum',
    enum: ReactionType,
  })
  type: ReactionType;

  @ManyToOne(() => Comment, (comment) => comment.reactions, {
    onDelete: 'CASCADE',
  })
  comment: Comment;

  @Column()
  commentId: number;

  @ManyToOne(() => User, (user) => user.commentReactions, {
    onDelete: 'CASCADE',
  })
  user: User;

  @Column()
  userId: number;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

---


### FILE: backend/src/reactions/dto/reaction-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsEnum, IsInt } from 'class-validator';
import { Type } from 'class-transformer';
import { ReactionType } from '../reactions.types';

export class ReactionQueryDto extends PaginationDto {
  @IsOptional()
  @IsEnum(ReactionType)
  type?: ReactionType;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  userId?: number;
}

---


### FILE: backend/src/reactions/dto/reaction-response.dto.ts ###
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { PostReaction } from '../entities/post-reaction.entity';
import { CommentReaction } from '../entities/comment-reaction.entity';
import { ReactionType } from '../reactions.types';

@Exclude()
export class ReactionResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly type: ReactionType;
  @Expose() @Type(() => UserResponseDto) readonly user: UserResponseDto;
  @Expose() postId?: number;
  @Expose() commentId?: number;
  @Expose() readonly createdAt: Date;

  static fromEntity(
    entity: PostReaction | CommentReaction,
  ): ReactionResponseDto {
    const dto = plainToInstance(
      ReactionResponseDto,
      {
        ...entity,
        user: entity.user ? UserResponseDto.fromEntity(entity.user) : null,
      },
      { excludeExtraneousValues: true },
    );

    if ('postId' in entity) {
      dto.postId = entity.postId;
      dto.commentId = undefined; // Ensure commentId is not set if it's a post reaction
    } else if ('commentId' in entity) {
      dto.commentId = entity.commentId;
      dto.postId = undefined; // Ensure postId is not set if it's a comment reaction
    }

    return dto;
  }
}

---


### FILE: backend/src/reactions/dto/update-reaction.dto.ts ###
import { IsEnum } from 'class-validator';
import { ReactionType } from '../reactions.types';

export class UpdateReactionDto {
  @IsEnum(ReactionType)
  type: ReactionType;
}
---


### FILE: backend/src/reactions/dto/create-reaction.dto.ts ###
import { IsEnum } from 'class-validator';
import { ReactionType } from '../reactions.types';

export class CreateReactionDto {
  @IsEnum(ReactionType)
  type: ReactionType;
}

---


### FILE: backend/src/common/dto/pagination-meta.dto.ts ###

export class PaginationMetaDto {
  page: number;

  limit: number;

  totalItems: number;

  totalPages: number;

  itemCount: number;

  constructor(page: number, limit: number, totalItems: number, itemCount: number) {
    this.page = page;
    this.limit = limit;
    this.totalItems = totalItems;
    this.itemCount = itemCount;
    this.totalPages = Math.ceil(this.totalItems / this.limit);
  }
}

---


### FILE: backend/src/common/dto/response.dto.ts ###

export class ResponseDto<T> {
  data: T;

  message?: string;

  meta?: {
    count?: number;
    total?: number;
    [key: string]: any;
  };

  constructor(data: T, message?: string, meta?: { count?: number; total?: number; [key: string]: any }) {
    this.data = data;
    this.message = message;
    this.meta = meta;
  }
}

---


### FILE: backend/src/common/dto/pagination.dto.ts ###
import { Type } from 'class-transformer';
import { IsInt, Min, IsOptional } from 'class-validator';

export class PaginationDto {
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page: number = 1; // default 1

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  limit: number = 10; // default 10
}

---


### FILE: backend/src/common/dto/paginated-response.dto.ts ###
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { PaginationMetaDto } from './pagination-meta.dto';
import { ResponseDto } from './response.dto';

export class PaginatedResponseDto<T> extends ResponseDto<T[]> {
  data: T[];

  @Type(() => PaginationMetaDto)
  @ValidateNested()
  meta: PaginationMetaDto;

  constructor(data: T[], meta: PaginationMetaDto) {
    super(data,undefined, meta);
    this.data = data;
    this.meta = meta;
  }
}

---


### FILE: backend/src/reports/reports.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ReportsService } from './reports.service';
import { ReportsController } from './reports.controller';
import { CommentReport } from './entities/comment-report.entity';
import { PostReport } from './entities/post-report.entity';
import { UserReport } from './entities/user-report.entity';
import { Post } from 'src/posts/entities/post.entity';
import { User } from 'src/users/entities/user.entity';
import { Comment } from 'src/comments/entities/comment.entity';
import { CaslModule } from 'src/casl/casl.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([
      CommentReport,
      PostReport,
      UserReport,
      Post,
      User,
      Comment,
    ]),
    CaslModule,
  ],
  controllers: [ReportsController],
  providers: [ReportsService],
})
export class ReportsModule {}

---


### FILE: backend/src/reports/reports.controller.ts ###
import { Controller, Post, Body, UseGuards, Patch, Param, Get, Query } from '@nestjs/common';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';
import { CreateReportDto } from './dto/create-report.dto';
import { UpdateReportDto } from './dto/update-report.dto';
import { ReportsService } from './reports.service';
import { ReportQueryDto } from './dto/report-query.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { ReportResponseDto } from './dto/report-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { ResponseDto } from 'src/common/dto/response.dto';

@Controller('reports')
@UseGuards(JwtAuthGuard)
export class ReportsController {
  constructor(private readonly reportsService: ReportsService) {}

  @Post()
  async createReport(
    @Body() createReportDto: CreateReportDto,
    @GetUser() user: User,
  ) {
    return this.reportsService.create(createReportDto, user);
  }

  @Get()
  async findAll(
    @Query() query: ReportQueryDto & { communityId?: number },
    @GetUser() user: User,
  ): Promise<PaginatedResponseDto<ReportResponseDto>> {
    const { data, count } = await this.reportsService.findAll({
      ...query,
      userId: user.id,
    });
    const paginationMeta = new PaginationMetaDto(query.page, query.limit, count, data.length); // Use defaulted values
    return new PaginatedResponseDto(data.map(ReportResponseDto.fromEntity), paginationMeta);
  }

  @Get(':id')
  async findOne(@Param('id') id: number, @Query('entityType') entityType: 'comment' | 'post' | 'user'): Promise<ResponseDto<ReportResponseDto>> {
    const report = await this.reportsService.findOne(id, entityType);
    return new ResponseDto(ReportResponseDto.fromEntity(report));
  }

  @Patch(':id')
  async updateReportStatus(
    @Param('id') id: number,
    @Body() updateReportDto: UpdateReportDto,
  ) {
    // TODO: Add authorization check for moderators
    return this.reportsService.updateStatus(id, updateReportDto.status, updateReportDto.entityType);
  }
}

---


### FILE: backend/src/reports/entities/comment-report.entity.ts ###
import {
  Entity,
  Column,
  ManyToOne,
} from 'typeorm';
import { Comment } from '../../comments/entities/comment.entity';
import { BaseReport } from './base-report.entity';
import { User } from '../../users/entities/user.entity';

@Entity('comment_reports')
export class CommentReport extends BaseReport {
  @ManyToOne(() => User, (user) => user.commentReports, { onDelete: 'CASCADE' })
  reporter: User;

  @Column()
  commentId: number;

    @Column()
  communityId: number;

  @ManyToOne(() => Comment, (comment) => comment.reports, { onDelete: 'CASCADE' })
  comment: Comment;

  @Column({ default: false })
  isPlatformComplaint: boolean;
}
---


### FILE: backend/src/reports/entities/post-report.entity.ts ###
import {
  Entity,
  Column,
  ManyToOne,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { BaseReport } from './base-report.entity';
import { User } from '../../users/entities/user.entity'; // User import not needed here as reporter is inherited

@Entity('post_reports')
export class PostReport extends BaseReport {

 @ManyToOne(() => User, (user) => user.postReports, { onDelete: 'CASCADE' })
  reporter: User;

  @Column()
  postId: number;


  @Column()
  communityId: number;

  @ManyToOne(() => Post, (post) => post.reports, { onDelete: 'CASCADE' })
  post: Post;

  @Column({ default: false })
  isPlatformComplaint: boolean;
}
---


### FILE: backend/src/reports/entities/user-report.entity.ts ###
import {
  Entity,
  Column,
  ManyToOne,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { BaseReport } from './base-report.entity';

@Entity('user_reports')
export class UserReport extends BaseReport {
  @ManyToOne(() => User, (user) => user.reportedUserReports, { onDelete: 'CASCADE' })
  reporter: User;

  @Column()
  reportedUserId: number;

  @ManyToOne(() => User, (user) => user.userReports, { onDelete: 'CASCADE' })
  reportedUser: User;

  @Column({ default: false })
  isPlatformComplaint: boolean;
}
---


### FILE: backend/src/reports/entities/base-report.entity.ts ###
import {
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';

export enum ReportStatus {
  PENDING = 'pending',
  RESOLVED = 'resolved',
  DISMISSED = 'dismissed',
}

export abstract class BaseReport {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  reporterId: number;
/*
  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  reporter: User;
*/
  @Column()
  reason: string;

  @Column({ type: 'text', nullable: true })
  description: string;

  @Column({
    type: 'simple-enum',
    enum: ReportStatus,
    default: ReportStatus.PENDING,
  })
  status: ReportStatus;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

}

---


### FILE: backend/src/reports/reports.service.ts ###
import {
  Injectable,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User, UserRole } from 'src/users/entities/user.entity';
import { Comment } from 'src/comments/entities/comment.entity';
import { Post } from 'src/posts/entities/post.entity';
import { CommentReport } from './entities/comment-report.entity';
import { PostReport } from './entities/post-report.entity';
import { UserReport } from './entities/user-report.entity';
import { ReportStatus } from './entities/base-report.entity';


const PLATFORM_COMPLAINT_REASONS = [
  'HARASSMENT',
  'VIOLENCE',
  'HATE_CONTENT',
  'MINOR_ABUSE_OR_SEXUALIZATION',
  'PII',
  'INVOLUNTARY_PORN',
  'PROHIBITED_SALES',
  'IMPERSONATION',
  'MANIPULATED_CONTENT',
  'COPYRIGHT',
  'TRADEMARK',
  'SELF_HARM',
  'SPAM',
  'CONTRIBUTOR_PROGRAM',
];

@Injectable()
export class ReportsService {
  constructor(
    @InjectRepository(CommentReport)
    private readonly commentReportRepository: Repository<CommentReport>,

    @InjectRepository(PostReport)
    private readonly postReportRepository: Repository<PostReport>,

    @InjectRepository(UserReport)
    private readonly userReportRepository: Repository<UserReport>,

    @InjectRepository(Comment)
    private readonly commentsRepository: Repository<Comment>,

    @InjectRepository(Post)
    private readonly postsRepository: Repository<Post>,

    @InjectRepository(User)
    private readonly usersRepository: Repository<User>,


  ) { }

  async create(
    {
      entityType,
      entityId,
      reason,
      description,
    }: {
      entityType: 'comment' | 'post' | 'user';
      entityId: number;
      reason: string;
      description?: string;
    },
    reporter: User,
  ) {
    const isPlatformComplaint = PLATFORM_COMPLAINT_REASONS.includes(
      reason.toUpperCase(),
    );

    if (entityType === 'comment') {
      const entity = await this.commentsRepository.findOne({
        where: { id: entityId },
      });
      if (!entity) throw new NotFoundException('Comment not found');

      const existingReport = await this.commentReportRepository.findOne({
        where: { commentId: entityId, reporterId: reporter.id },
      });
      if (existingReport) {
        throw new ConflictException('You have already reported this comment');
      }

      const report = this.commentReportRepository.create({
        reporterId: reporter.id,
        commentId: entityId,
        reason,
        description,
        isPlatformComplaint,
      });
      return this.commentReportRepository.save(report);
    }

    if (entityType === 'post') {
      const entity = await this.postsRepository.findOne({
        where: { id: entityId },
      });
      if (!entity) throw new NotFoundException('Post not found');

      const existingReport = await this.postReportRepository.findOne({
        where: { postId: entityId, reporterId: reporter.id },
      });
      if (existingReport) {
        throw new ConflictException('You have already reported this post');
      }

      const report = this.postReportRepository.create({
        reporterId: reporter.id,
        postId: entityId,
        reason,
        description,
        isPlatformComplaint,
        communityId: (entity as Post).communityId,
      });
      return this.postReportRepository.save(report);
    }

    if (entityType === 'user') {
      const entity = await this.usersRepository.findOne({
        where: { id: entityId },
      });
      if (!entity) throw new NotFoundException('User not found');

      if (entity.id === reporter.id) {
        throw new ConflictException('You cannot report yourself');
      }

      const existingReport = await this.userReportRepository.findOne({
        where: { reportedUserId: entityId, reporterId: reporter.id },
      });
      if (existingReport) {
        throw new ConflictException('You have already reported this user');
      }

      const report = this.userReportRepository.create({
        reporterId: reporter.id,
        reportedUserId: entityId,
        reason,
        description,
        isPlatformComplaint,
      });
      return this.userReportRepository.save(report);
    }
  }

  async findAll({
    page = 1,
    limit = 10,
    status,
    entityType,
    reporterId,
    userId,
    communityId,
  }: {
    page?: number;
    limit?: number;
    status?: ReportStatus;
    entityType?: 'comment' | 'post' | 'user';
    reporterId?: number;
    userId: number;
    communityId?: number;
  }): Promise<{ data: (CommentReport | PostReport | UserReport)[]; count: number }> {
    const offset = (page - 1) * limit;


    const user = await this.usersRepository.findOne({
      where: { id: userId },
    });

    if (!user) {
      throw new NotFoundException(`User ${userId} not found`);
    }


    const parameters: any[] = [];
    let paramIndex = 1;

    const buildSelectQuery = (
      tableName: string,
      type: string,
      specificIdColumn: string,
    ) => {
      const whereClauses: string[] = [];

      if (status) {
        whereClauses.push(`status = $${paramIndex++}`);
        parameters.push(status);
      }

      if (reporterId) {
        whereClauses.push(`"reporterId" = $${paramIndex++}`);
        parameters.push(reporterId);
      }

      if (user.role == UserRole.ADMIN) {
        whereClauses.push(`"isPlatformComplaint" = TRUE`);
      } else {
        whereClauses.push(`"isPlatformComplaint" = FALSE`);
      }

      if (entityType && entityType !== type) return null;

      const where =
        whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';

      return `
        SELECT
          id,
          "reporterId",
          reason,
          description,
          status,
          "createdAt",
          "updatedAt",
          "isPlatformComplaint",
          "communityId",
          ${specificIdColumn} AS "entitySpecificId",
          '${type}' AS "entityType"
        FROM ${tableName}
        ${where}
      `;
    };

    const unionQueries = [
      buildSelectQuery('comment_reports', 'comment', 'commentId'),
      buildSelectQuery('post_reports', 'post', 'postId'),
      buildSelectQuery('user_reports', 'user', 'reportedUserId'),
    ].filter(Boolean);

    if (!unionQueries.length) {
      return { data: [], count: 0 };
    }

    const unionAllQuery = unionQueries.join(' UNION ALL ');

    const countQuery = `SELECT COUNT(*) FROM (${unionAllQuery}) AS union_counts`;
    const countResult = await this.commentReportRepository.query(
      countQuery,
      parameters,
    );
    const count = parseInt(countResult[0].count, 10);

    const dataQuery = `
      ${unionAllQuery}
      ORDER BY "createdAt" DESC
      LIMIT $${paramIndex++} OFFSET $${paramIndex++}
    `;
    parameters.push(limit, offset);

    const raw = await this.commentReportRepository.query(
      dataQuery,
      parameters,
    );

    const data = raw.map(item => ({
      id: item.id,
      reporterId: item.reporterId,
      reason: item.reason,
      description: item.description,
      status: item.status,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
      isPlatformComplaint: item.isPlatformComplaint,
      communityId: item.communityId,
      entityType: item.entityType,
      commentId: item.entityType === 'comment' ? item.entitySpecificId : undefined,
      postId: item.entityType === 'post' ? item.entitySpecificId : undefined,
      reportedUserId:
        item.entityType === 'user' ? item.entitySpecificId : undefined,
    }));

    return { data, count };
  }

  async findOne(
    id: number,
    entityType: 'comment' | 'post' | 'user',
  ): Promise<CommentReport | PostReport | UserReport> {
    let repository: Repository<any>;

    if (entityType === 'comment') repository = this.commentReportRepository;
    else if (entityType === 'post') repository = this.postReportRepository;
    else repository = this.userReportRepository;

    const report = await repository.findOne({ where: { id } });
    if (!report) {
      throw new NotFoundException(`Report ${id} not found`);
    }
    return report;
  }

  async updateStatus(
    id: number,
    status: ReportStatus,
    entityType: 'comment' | 'post' | 'user',
  ) {
    const report = await this.findOne(id, entityType);

    if (report.status === status) {
      throw new ConflictException(
        `Report is already with status "${status}"`,
      );
    }

    report.status = status;

    if (entityType === 'comment') {
      return this.commentReportRepository.save(report);
    }
    if (entityType === 'post') {
      return this.postReportRepository.save(report);
    }
    return this.userReportRepository.save(report);
  }
}

---


### FILE: backend/src/reports/dto/create-report.dto.ts ###
import { IsString, IsIn, IsNumber, IsOptional } from 'class-validator';

export class CreateReportDto {
  @IsString()
  reason: string;

  @IsIn(['comment', 'post', 'user'])
  entityType: 'comment' | 'post' | 'user';

  @IsNumber()
  entityId: number;

  @IsString()
  @IsOptional()
  description?: string;
}

---


### FILE: backend/src/reports/dto/report-response.dto.ts ###
import { ReportStatus } from '../entities/base-report.entity';
import { CommentReport } from '../entities/comment-report.entity';
import { PostReport } from '../entities/post-report.entity';
import { UserReport } from '../entities/user-report.entity';

export class ReportResponseDto {
  id: number;
  reason: string;
  description: string | null;
  status: ReportStatus;
  reporterId: number;
  createdAt: Date;
  updatedAt: Date;
  entityType: 'comment' | 'post' | 'user';
  commentId?: number;
  postId?: number;
  reportedUserId?: number;

  static fromEntity(
    report: CommentReport | PostReport | UserReport,
  ): ReportResponseDto {
    const dto = new ReportResponseDto();
    dto.id = report.id;
    dto.reason = report.reason;
    dto.description = report.description;
    dto.status = report.status;
    dto.reporterId = report.reporterId;
    dto.createdAt = report.createdAt;
    dto.updatedAt = report.updatedAt;

    if (report instanceof CommentReport) {
      dto.entityType = 'comment';
      dto.commentId = report.commentId;
    } else if (report instanceof PostReport) {
      dto.entityType = 'post';
      dto.postId = report.postId;
    } else if (report instanceof UserReport) {
      dto.entityType = 'user';
      dto.reportedUserId = report.reportedUserId;
    }

    return dto;
  }
}

---


### FILE: backend/src/reports/dto/report-query.dto.ts ###
import { IsOptional, IsIn, IsNumber, IsEnum } from 'class-validator';
import { ReportStatus } from '../entities/base-report.entity';
import { Transform } from 'class-transformer';
import { PaginationDto } from 'src/common/dto/pagination.dto';

export class ReportQueryDto extends PaginationDto {

  @IsOptional()
  @IsEnum(ReportStatus)
  status?: ReportStatus;

  @IsOptional()
  @IsIn(['comment', 'post', 'user'])
  entityType?: 'comment' | 'post' | 'user';

  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  @IsNumber()
  reporterId?: number;

  @IsOptional()
  @Transform(({ value }) => parseInt(value, 10))
  @IsNumber()
  communityId?: number;
}

---


### FILE: backend/src/reports/dto/update-report.dto.ts ###
import { IsEnum, IsIn } from 'class-validator';
import { ReportStatus } from '../entities/base-report.entity';

export class UpdateReportDto {
  @IsEnum(ReportStatus)
  status: ReportStatus;

  @IsIn(['comment', 'post', 'user'])
  entityType: 'comment' | 'post' | 'user';
}

---


### FILE: backend/src/decorators/user.decorator.ts ###
// src/decorators/current-user.decorator.ts
import {
  createParamDecorator,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { User } from 'src/users/entities/user.entity';

export const GetUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): User => {
    const request = ctx.switchToHttp().getRequest();

    // This comes from JwtStrategy.validate() ‚Üí req.user
    const user: User | undefined = request.user;

    if (!user) {
      throw new UnauthorizedException(
        'No authenticated user found. Token ff may be missing or invalid.',
      );
    }

    return user;
  },
);

---


### FILE: backend/src/email-verification/email-verification.controller.ts ###
import {
  Controller,
  Post,
  Body,
  BadRequestException,
  Query,
  Get,
  Res,
} from '@nestjs/common';
import { EmailVerificationService } from './email-verification.service';
import { SendVerificationDto } from './dto/send-verification.dto';
import { UsersService } from '../users/users.service';
import { ResponseDto } from 'src/common/dto/response.dto';
import type { Response } from 'express';
import { ConfigService } from '@nestjs/config';

@Controller('email')
export class EmailVerificationController {
  constructor(
    private readonly service: EmailVerificationService,
    private readonly usersService: UsersService,
    private readonly configService: ConfigService,
  ) { }

  @Post('resend')
  async resend(@Body() dto: SendVerificationDto): Promise<ResponseDto<null>> {
    const user = await this.usersService.findByEmail(dto.email);
    if (user && !user.emailVerifiedAt) {
      await this.service.sendVerificationEmail(user);
    }
    return new ResponseDto(null, 'If the email exists and is not verified, a new verification link has been sent.');
  }

  @Get('verify')
  async verify(
    @Query('token') token: string,
    @Res() res: Response,
  ): Promise<void> {
    const frontendUrl = this.configService.getOrThrow<string>(
      'FRONTEND_URL');
    const redirectUrl = new URL(`${frontendUrl}/verify-email`);

    if (!token) {
      redirectUrl.searchParams.set('error', 'Token is required');
      return res.redirect(redirectUrl.toString());
    }

    try {
      const userId = await this.service.verifyToken(token);
      await this.usersService.markEmailAsVerified(userId);

      redirectUrl.searchParams.set('success', '1');
      redirectUrl.searchParams.set( 'message',
        'Email verified successfully',
      );
    } catch (err) {
      const message =
        err instanceof BadRequestException
          ? err.message
          : 'Invalid or expired verification token';
      redirectUrl.searchParams.set('error', '1');
      redirectUrl.searchParams.set('message', message);
    }

    return res.redirect(redirectUrl.toString());
  }

}

---


### FILE: backend/src/email-verification/entities/email-verification-token.entity.ts ###
// src/email-verification/entities/email-verification-token.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
} from 'typeorm';

@Entity('email_verification_tokens')
export class EmailVerificationToken {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  token: string;

  @Column()
  userId: number;

  @Column()
  expiresAt: Date;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: backend/src/email-verification/email-verification.service.ts ###
import {
  Injectable,
  BadRequestException,
  InternalServerErrorException,
  Inject,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { randomUUID } from 'crypto';
import { EmailVerificationToken } from './entities/email-verification-token.entity';
import { User } from 'src/users/entities/user.entity';
import type { IMailService } from 'src/mail/interfaces/mail-service.interface';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class EmailVerificationService {
  constructor(
    @InjectRepository(EmailVerificationToken)
    private readonly tokenRepo: Repository<EmailVerificationToken>,
    private readonly configService: ConfigService,
    @Inject('IMailService')
    private readonly mailService: IMailService,
  ) {
    this.EXPIRATION_MS = this.configService.get<number>(
      'EMAIL_VERIFICATION_TOKEN_EXPIRATION',
      15 * 60 * 1000,
    );
  }
  EXPIRATION_MS: number;

  private async deleteExistingTokens(userId: number): Promise<void> {
    await this.tokenRepo.delete({ userId });
  }

  async generateToken(userId: number): Promise<string> {
    await this.deleteExistingTokens(userId);

    const token = randomUUID();
    const record = this.tokenRepo.create({
      token,
      userId,
      expiresAt: new Date(Date.now() + this.EXPIRATION_MS),
    });

    await this.tokenRepo.save(record);
    return token;
  }

  private generateVerificationLink(token: string): string {
    // You can move APP_DOMAIN to ConfigService if needed
    const domain = this.configService.get<string>('APP_DOMAIN'); // e.g. https://myapp.com
    const path = '/api/email/verify';
    return `${domain}${path}?token=${token}`;
  }

  async sendVerificationEmail(user: User): Promise<void> {
    const token = await this.generateToken(user.id);
    const verifyUrl = this.generateVerificationLink(token);

    try {
      await this.mailService.sendEmail(
        user.email,
        'Verify Your Email',
        'verify-email', // templateName (templates/verify-email.hbs)
        { name: user.name, verifyUrl }, // context for the template
      );
    } catch (err) {
      console.error('Error sending verification email:', err);
      throw new InternalServerErrorException(
        'Failed to send verification email',
      );
    }
  }

  async verifyToken(token: string): Promise<number> {
    const record = await this.tokenRepo.findOne({ where: { token } });

    if (!record) throw new BadRequestException('Invalid token');
    if (record.expiresAt < new Date()) {
      await this.tokenRepo.delete({ token });
      throw new BadRequestException('Token expired');
    }

    await this.tokenRepo.delete({ token });
    return record.userId;
  }
}

---


### FILE: backend/src/email-verification/dto/verify-email.dto.ts ###
export class VerifyEmailDto {
  token: string;
}

---


### FILE: backend/src/email-verification/dto/send-verification.dto.ts ###
import { IsEmail, IsNotEmpty } from 'class-validator';

export class SendVerificationDto {
  @IsNotEmpty()
  @IsEmail()
  email: string; // ‚úÖ Use email, a public identifier
}

---


### FILE: backend/src/email-verification/email-verification.module.ts ###
// src/email-verification/email-verification.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { EmailVerificationService } from './email-verification.service';
import { EmailVerificationController } from './email-verification.controller';
import { EmailVerificationToken } from './entities/email-verification-token.entity';
import { UsersModule } from 'src/users/users.module';
import { MailModule } from 'src/mail/mail.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([EmailVerificationToken]),
    UsersModule,
    MailModule,
  ],
  controllers: [EmailVerificationController],
  providers: [EmailVerificationService],
  exports: [EmailVerificationService],
})
export class EmailVerificationModule {}

---


### FILE: backend/src/casl/casl.types.ts ###
export enum Action {
  Manage = 'manage',
  Create = 'create',
  Read = 'read',
  Update = 'update',
  Delete = 'delete',
}

---


### FILE: backend/src/casl/casl.service.ts ###
import { Injectable, ForbiddenException } from '@nestjs/common';
// 1. Import 'Subjects' from your CASL ability factory
import {
  CaslAbilityFactory,
  AppAbility,
  Subjects,
} from './casl-ability.factory';
import { Action } from './casl.types';

@Injectable()
export class CaslService {
  constructor(private readonly caslAbilityFactory: CaslAbilityFactory) {}

  /**
   * Private helper method to create the ability object.
   */
  private getAbility(user: any): AppAbility {
    return this.caslAbilityFactory.createForUser(user);
  }

  /**
   * Checks if user can perform an action on a specific resource.
   * Throws ForbiddenException if not allowed.
   */
  // 2. Add 'extends Subjects' constraint to generic type T
  enforce<T extends Subjects>(user: any, action: Action, resource: T): void {
    const ability = this.getAbility(user);

    if (!ability.can(action, resource)) {
      throw new ForbiddenException(
        'You are not allowed to perform this action',
      );
    }
  }

  /**
   * Returns true/false without throwing.
   */
  // 3. Add 'extends Subjects' constraint to generic type T
  can<T extends Subjects>(user: any, action: Action, resource: T): boolean {
    const ability = this.getAbility(user);

    return ability.can(action, resource);
  }
}

---


### FILE: backend/src/casl/policies.guard.ts ###
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { CaslAbilityFactory, AppAbility } from './casl-ability.factory';
import { CHECK_POLICIES_KEY } from './check-policies.decorator';
import { PolicyHandler } from './policy-handler.interface';

@Injectable()
export class PoliciesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private caslAbilityFactory: CaslAbilityFactory,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const policyHandlers =
      this.reflector.get<PolicyHandler[]>(
        CHECK_POLICIES_KEY,
        context.getHandler(),
      ) || [];

    const { user } = context.switchToHttp().getRequest();

    const ability = this.caslAbilityFactory.createForUser(user);

    return policyHandlers.every((handler) =>
      this.execPolicyHandler(handler, ability),
    );
  }

  private execPolicyHandler(handler: PolicyHandler, ability: AppAbility) {
    if (typeof handler === 'function') {
      return handler(ability);
    }
    return handler.handle(ability);
  }
}

---


### FILE: backend/src/casl/casl-ability.factory.ts ###
import {
  AbilityBuilder,
  createMongoAbility,
  MongoAbility,
  InferSubjects,
  ExtractSubjectType,
} from '@casl/ability';
import { Injectable } from '@nestjs/common';
import { User } from '../users/entities/user.entity';
import { Post } from '../posts/entities/post.entity';
import { Comment } from '../comments/entities/comment.entity';
import { PostReaction } from '../reactions/entities/post-reaction.entity';
import { CommentReaction } from '../reactions/entities/comment-reaction.entity';
import { Action } from './casl.types';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembershipRole } from 'src/community-memberships/types';
import { CommunityType } from 'src/communities/types';

export type Subjects =
  | InferSubjects<
    | typeof Post
    | typeof Comment
    | typeof PostReaction
    | typeof CommentReaction
    | typeof User
    | typeof Community
  >
  | 'all';

export type AppAbility = MongoAbility<[Action, Subjects]>;

@Injectable()
export class CaslAbilityFactory {
  createForUser(user: User) {
    const { can, cannot, build } = new AbilityBuilder<AppAbility>(
      createMongoAbility,
    );

    // ---- Post Permissions ----
    can(Action.Read, Post); // any post
    can(Action.Create, Post);
    can(Action.Update, Post, { authorId: user.id }); // only own
    can(Action.Delete, Post, { authorId: user.id });

    // ---- Comment Permissions ----
    can(Action.Read, Comment);
    can(Action.Create, Comment);
    can(Action.Update, Comment, { authorId: user.id });
    can(Action.Delete, Comment, { authorId: user.id });

    // ---- Reaction Permissions ----
    // PostReaction
    can(Action.Create, PostReaction);
    can(Action.Delete, PostReaction, { userId: user.id });
    can(Action.Update, PostReaction, { userId: user.id });


    // CommentReaction
    can(Action.Create, CommentReaction);
    can(Action.Delete, CommentReaction, { userId: user.id });
    can(Action.Update, CommentReaction, { userId: user.id });

    can(Action.Delete, Community, { ownerId: user.id });
    can(Action.Update, Community, { ownerId: user.id });



    return build({
      detectSubjectType: (item) =>
        item.constructor as ExtractSubjectType<Subjects>,
    });
  }
}

---


### FILE: backend/src/casl/casl.module.ts ###
import { Module } from '@nestjs/common';
import { CaslAbilityFactory } from './casl-ability.factory';
import { CaslService } from './casl.service';

@Module({
  providers: [CaslAbilityFactory, CaslService],
  exports: [CaslAbilityFactory, CaslService],
})
export class CaslModule {}

---


### FILE: backend/src/casl/policy-handler.interface.ts ###
import { AppAbility } from '../casl/casl-ability.factory';

interface IPolicyHandler {
  handle(ability: AppAbility): boolean;
}

type PolicyHandlerCallback = (ability: AppAbility) => boolean;

export type PolicyHandler = IPolicyHandler | PolicyHandlerCallback;

---


### FILE: backend/src/casl/check-policies.decorator.ts ###
import { SetMetadata } from '@nestjs/common';
import { PolicyHandler } from './policy-handler.interface';

export const CHECK_POLICIES_KEY = 'check_policy';
export const CheckPolicies = (...handlers: PolicyHandler[]) =>
  SetMetadata(CHECK_POLICIES_KEY, handlers);

---


### FILE: backend/src/casl/index.ts ###
export * from './casl.types';
export * from './casl-ability.factory';
export * from './policy-handler.interface';
export * from './check-policies.decorator';
export * from './policies.guard';
export * from './casl.module';

---


### FILE: backend/src/posts/pipes/post.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { PostsService } from '../posts.service';
import { Post } from '../entities/post.entity';

@Injectable()
export class PostPipe implements PipeTransform<string, Promise<Post>> {
  constructor(private readonly postsService: PostsService) {}

  async transform(value: string): Promise<Post> {
    const post = await this.postsService.findOne(+value);

    if (!post) {
      throw new NotFoundException('Post not found');
    }

    return post;
  }
}

---


### FILE: backend/src/posts/posts.module.ts ###
import { Module } from '@nestjs/common';
import { PostsService } from './posts.service';
import { PostsController } from './posts.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Post } from './entities/post.entity';
import { CaslModule } from 'src/casl/casl.module';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';

@Module({
  imports: [TypeOrmModule.forFeature(
    [Post, Community, CommunityMembership]),
    CaslModule,

  ],
  providers: [PostsService],
  controllers: [PostsController],
  exports: [PostsService],
})
export class PostsModule { }

---


### FILE: backend/src/posts/posts.service.ts ###
import { BadRequestException, ForbiddenException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Brackets, Repository } from 'typeorm';
import { Post } from './entities/post.entity';
import { PostSort } from './dto/post-query.dto';
import { CommunityType } from 'src/communities/types';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';
import { CommunityMembershipRole } from 'src/community-memberships/types';

@Injectable()
export class PostsService {
  constructor(
    @InjectRepository(Post)
    private postsRepository: Repository<Post>,
    @InjectRepository(Community)
    private readonly communityRepository: Repository<Community>,

    @InjectRepository(CommunityMembership)
    private readonly membershipRepository: Repository<CommunityMembership>) 
    { }
  async findAll(
    options: {
      page?: number;
      limit?: number;
      search?: string;
      authorId?: number;
      sort?: PostSort;
      startDate?: Date;
      endDate?: Date;
      currentUserId?: number;
      communityId?: number;
    },
  ): Promise<{
    data: Post[];
    count: number;
  }> {
    const {
      page = 1,
      limit = 10,
      search,
      authorId,
      sort,
      startDate,
      endDate,
      currentUserId,
      communityId,
    } = options;

    const query = this.postsRepository
      .createQueryBuilder('post')
      .leftJoinAndSelect('post.author', 'author')
      .leftJoinAndSelect('post.community', 'community')
      .where('post.isApproved = :approved', { approved: true });

    if (currentUserId) {
      query.leftJoinAndMapOne(
        'post.userReaction',
        'post.reactions',
        'userReaction',
        'userReaction.userId = :currentUserId',
        { currentUserId },
      );
    }

    if (search) {
      query.where(
        new Brackets((qb) => {
          qb.where('post.title LIKE :search', {
            search: `%${search}%`,
          }).orWhere('post.content LIKE :search', { search: `%${search}%` });
        }),
      );
    }

    if (authorId) {
      query.andWhere('post.author.id = :authorId', { authorId });
    }

    if (communityId) {
      query.andWhere('post.community.id = :communityId', { communityId });
    }

    if (startDate) {
      query.andWhere('post.createdAt >= :startDate', { startDate });
    }


    if (endDate) {
      query.andWhere('post.createdAt <= :endDate', { endDate });
    }

    if (sort === PostSort.POPULAR) {
      query
        .leftJoin('post.reactions', 'allReactions') // Join all reactions for the post
        .addSelect('COUNT(allReactions.id)', 'reactionCount')
        .groupBy('post.id')
        .orderBy('reactionCount', 'DESC');
    } else if (sort === PostSort.NEWEST) {
      query.orderBy('post.createdAt', 'DESC');
    } else if (sort === PostSort.OLDEST) {
      query.orderBy('post.createdAt', 'ASC');
    } else {
      query.orderBy('post.createdAt', 'DESC');
    }

    // Community visibility rules
    if (!currentUserId) {
      // Not logged in ‚Üí hide PRIVATE communities and show only approved posts
      query.andWhere('community.communityType != :privateType', {
        privateType: 'private',
      });
      query.andWhere('post.isApproved = :isApproved', { isApproved: true });
    } else {
      query.andWhere(
        new Brackets((qb) => {
          qb.where('community.communityType != :privateType', {
            privateType: 'private',
          }).orWhere(
            `EXISTS (
          SELECT 1
          FROM community_memberships cs
          WHERE cs.communityId = community.id
          AND cs.userId = :currentUserId
        )`,
          );
        }),
      ).setParameter('privateType', 'private')
        .setParameter('currentUserId', currentUserId);
    }

    const [data, count] = await query
      .take(limit)
      .skip((page - 1) * limit)
      .getManyAndCount();



    return { data: data, count };
  }


  async findOne(id: number, currentUserId?: number): Promise<Post | null> {
    // Start building query
    const query = this.postsRepository.createQueryBuilder('post')
      .leftJoinAndSelect('post.author', 'author')
      .leftJoinAndSelect('post.comments', 'comments')
      .leftJoinAndSelect('post.community', 'community');

    // Optionally join user's reaction if currentUserId is provided
    if (currentUserId) {
      query.leftJoinAndMapOne(
        'post.userReaction',
        'post.reactions',
        'userReaction',
        'userReaction.userId = :currentUserId',
        { currentUserId },
      );
    }

    // Filter by post ID
    query.where('post.id = :id', { id });

    // TODO: Implement actual admin check based on user roles
    const isAdmin = false; // Placeholder for admin check

    if (!currentUserId || !isAdmin) {
      query.andWhere('post.isApproved = :isApproved', { isApproved: true });
    }

    // Execute query
    const post = await query.getOne();
    return post;
  }

  async create(
    { title, content, authorId, communityId, isApproved }: { title: string; content: string; authorId: number; communityId: number; isApproved?: boolean },
  ): Promise<Post> {
    const community = await this.communityRepository.findOneBy({ id: communityId });
    if (!community) {
      throw new NotFoundException(`Community with ID ${communityId} not found`);
    }
    // Check if user can contribute based on community rules
    await this.assertUserCanPostToCommunity(authorId, community);

    const post = this.postsRepository.create({
      title,
      content,
      authorId,
      community,
      isApproved: isApproved !== undefined ? isApproved : false, // Set isApproved based on provided value or default to false
    });
    return this.postsRepository.save(post);
  }
  async update(
    postUpdateData: {
      id: number;
      title?: string;
      content?: string;
    },
  ): Promise<Post> {
    const post = await this.postsRepository.findOneBy({ id: postUpdateData.id });
    if (!post) {
      throw new NotFoundException('Post not found');
    }

    if (postUpdateData.title !== undefined) post.title = postUpdateData.title;
    if (postUpdateData.content !== undefined) post.content = postUpdateData.content;

    return this.postsRepository.save(post);
  }

  async remove(id: number): Promise<boolean> {
    const post = await this.postsRepository.findOneBy({ id });
    if (!post) {
      throw new NotFoundException('Post not found'); // TODO: Use a more specific NestJS exception
    }
    const res = await this.postsRepository.remove(post);
    return !!res;
  }


  async updatePostApprovalStatus(postId: number, isApproved: boolean,userId:number): Promise<Post> {
    const post = await this.postsRepository.findOneBy({ id: postId });
    if (!post) {
      throw new NotFoundException('Post not found');
    }

    post.isApproved = isApproved;
    post.approvedAt = isApproved ? new Date() : null;
    return this.postsRepository.save(post);
  }

  async updateCommentsLockedStatus(postId: number, commentsLocked: boolean): Promise<Post> {
    const post = await this.postsRepository.findOneBy({ id: postId });
    if (!post) {
      throw new NotFoundException('Post not found');
    }
    post.commentsLocked = commentsLocked;
    return this.postsRepository.save(post);
  }






  async incrementViews(postId: number): Promise<void> {
    await this.postsRepository.increment({ id: postId }, 'views', 1);
  }

  async assertUserCanPostToCommunity(
    userId: number,
    community: Community,
  ): Promise<void> {
    switch (community.communityType) {
      case CommunityType.PUBLIC:
        return;

      case CommunityType.RESTRICTED:
      case CommunityType.PRIVATE:
        const isActive = await this.membershipRepository.exist({
          where: {
            userId,
            communityId: community.id,
          },
        });

        if (!isActive) {
          throw new ForbiddenException('You cannot post in this community');
        }
        return;

      default:
        throw new ForbiddenException('Posting not allowed');
    }
  }


}

---


### FILE: backend/src/posts/entities/post.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToMany,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
} from 'typeorm';
import { Comment } from '../../comments/entities/comment.entity';
import { User } from '../../users/entities/user.entity';
import { PostReaction } from '../../reactions/entities/post-reaction.entity';
import { Community } from '../../communities/entities/community.entity';
import { ReactionType } from 'src/reactions/reactions.types';
import { PostReport } from '../../reports/entities/post-report.entity';

@Entity('posts')
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @Column()
  content: string;

  @ManyToOne(() => User, (user) => user.posts, {
    nullable: false,
    onDelete: 'CASCADE',
  })
  author: User;
  // FK explicite
  @Column()
  authorId: number;

  @ManyToOne(() => Community, (community) => community.posts, {
    nullable: false,
    onDelete: 'RESTRICT',
  })
  community: Community;

  @Column({ nullable: false })
  communityId: number;

  @Column({ default: 0 })
  commentsCount: number;

  @OneToMany(() => Comment, (comment) => comment.post)
  comments: Comment[];

  @Column({ default: 0 })
  views: number;

  @OneToMany(() => PostReaction, (reaction) => reaction.post)
  reactions: PostReaction[];

  @Column({ default: 0 })
  likesCount: number;

  @Column({ default: 0 })
  dislikesCount: number;

  @Column({ default: false })
  commentsLocked: boolean;

  @Column({ default: false })
  isApproved: boolean;

  @Column({ type: 'datetime', nullable: true })
  approvedAt: Date | null;

  @OneToMany(() => PostReport, (postReport) => postReport.post)
  reports: PostReport[];

  userReaction?: { id: number; type: ReactionType };
  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @DeleteDateColumn()
  deletedAt: Date;
}

---


### FILE: backend/src/posts/posts.controller.ts ###
import {
  Controller,
  Get,
  Post as HttpPost,
  Body,
  Param,
  Patch,
  Delete,
  UseGuards,
  Query,
  Req,
  NotFoundException,
} from '@nestjs/common';
import { PostsService } from './posts.service';
import { CreatePostDto } from './dto/create-post.dto';
import { UpdatePostDto } from './dto/update-post.dto';
import { UpdatePostApprovalDto } from './dto/update-post-approval.dto'; // Import the new DTO
import { UpdateCommentsLockedDto } from './dto/update-comments-locked.dto';
import { Post as PostEntity } from './entities/post.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { PostPipe } from 'src/posts/pipes/post.pipe';
import { Action } from 'src/casl/casl.types';
import { CaslService } from 'src/casl/casl.service';
import { PostResponseDto } from './dto/post-response.dto';
import { PostQueryDto } from './dto/post-query.dto';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { OptionalJwtAuthGuard } from 'src/auth/guards/optional-jwt-auth.guard';
import type { Request } from 'express';
import { CommunityType } from 'src/communities/types';
import { CommunityMembershipRole } from 'src/community-memberships/types';

@Controller('posts')
export class PostsController {
  constructor(
    private readonly postsService: PostsService,
    private readonly caslService: CaslService,
  ) { }

  @Get()
  @UseGuards(JwtAuthGuard)
  async findAll(@Query() query: PostQueryDto,
    @Req() req: any
  ): Promise<PaginatedResponseDto<PostResponseDto>> {

    const { data, count } = await this.postsService.findAll({
      page: query.page,
      limit: query.limit,
      search: query.search,
      authorId: query.authorId,
      sort: query.sort,
      startDate: query.startDate,
      endDate: query.endDate,
      currentUserId: req.user?.id ?? undefined,
      communityId: query.communityId,
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(PostResponseDto.fromEntity), paginationMeta);
  }

  @Get(':id')
  @UseGuards(OptionalJwtAuthGuard)
  async findOne(
    @Param('id') id: string,
    @GetUser() user?: User, // Get user if authenticated
  ): Promise<ResponseDto<PostResponseDto>> {
    const postId = +id;
    const post = await this.postsService.findOne(postId, user?.id); // Pass currentUserId

    if (!post) {
      throw new NotFoundException(`Post not found`);
    }

    this.postsService.incrementViews(postId);
    return new ResponseDto(PostResponseDto.fromEntity(post));
  }

  @HttpPost()
  @UseGuards(JwtAuthGuard)
  async create(
    @Body() dto: CreatePostDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<PostResponseDto>> {
    this.caslService.enforce(user, Action.Create, PostEntity);
    const post = await this.postsService.create({
      title: dto.title,
      content: dto.content,
      authorId: user.id,
      communityId: dto.communityId,
    });
    return new ResponseDto(PostResponseDto.fromEntity(post));
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', PostPipe) post: PostEntity,
    @Body() dto: UpdatePostDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<PostResponseDto>> {
    this.caslService.enforce(user, Action.Update, post);
    const updatedPost = await this.postsService.update({
      id: post.id,
      title: dto.title,
      content: dto.content,
    });
    return new ResponseDto(PostResponseDto.fromEntity(updatedPost));
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  async remove(@Param('id', PostPipe) post: PostEntity, @GetUser() user: User): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, post);
    const success = await this.postsService.remove(post.id);
    return new ResponseDto(success);
  }

  @Patch(':id/approve')
  @UseGuards(JwtAuthGuard)
  // TODO: Add admin role guard here
  async updatePostApprovalStatus(
    @Param('id', PostPipe) post: PostEntity,
    @Body() dto: UpdatePostApprovalDto, // Use the new DTO
    @GetUser() user: User, // For potential admin check
  ): Promise<ResponseDto<PostResponseDto>> {
    const updatedPost = await this.postsService.updatePostApprovalStatus(post.id, dto.isApproved,user.id);
    return new ResponseDto(PostResponseDto.fromEntity(updatedPost));
  }

  @Patch(':id/comments-locked')
  @UseGuards(JwtAuthGuard)
  // TODO: Add proper authorization using caslService.enforce
  async updateCommentsLockedStatus(
    @Param('id', PostPipe) post: PostEntity,
    @Body() dto: UpdateCommentsLockedDto,
    @GetUser() user: User, // For authorization check
  ): Promise<ResponseDto<PostResponseDto>> {
    this.caslService.enforce(user, Action.Update, post); // Enforce update on commentsLocked field
    const updatedPost = await this.postsService.updateCommentsLockedStatus(post.id, dto.commentsLocked);
    return new ResponseDto(PostResponseDto.fromEntity(updatedPost));
  }


  }

---


### FILE: backend/src/posts/dto/update-post.dto.ts ###
// src/posts/dto/update-post.dto.ts

import { PartialType } from '@nestjs/mapped-types'; // <-- 1. Make sure this is imported
import { CreatePostDto } from './create-post.dto'; // <-- 2. Make sure you import CreatePostDto

// 3. Extend PartialType of your base DTO
export class UpdatePostDto extends PartialType(CreatePostDto) {
  // If you need to add custom validation or properties, they go here.
  // Otherwise, leave the body empty.
}

---


### FILE: backend/src/posts/dto/update-comments-locked.dto.ts ###
import { IsBoolean } from 'class-validator';

export class UpdateCommentsLockedDto {
  @IsBoolean()
  commentsLocked: boolean;
}

---


### FILE: backend/src/posts/dto/post-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsString, IsInt, IsEnum, IsISO8601 } from 'class-validator';
import { Type } from 'class-transformer';

export enum PostSort {
  NEWEST = 'newest',
  POPULAR = 'popular',
  OLDEST = 'oldest',
}

export class PostQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  search?: string; // Filter by title or content

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  authorId?: number;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  communityId?: number;

  @IsOptional()
  @IsEnum(PostSort)
  sort?: PostSort;

  @IsOptional()
  @IsISO8601()
  @Type(() => Date)
  startDate?: Date;

  @IsOptional()
  @IsISO8601()
  @Type(() => Date)
  endDate?: Date;
}

---


### FILE: backend/src/posts/dto/post-response.dto.ts ###
// src/posts/dto/post-response.dto.ts
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { Post } from '../entities/post.entity';
import { ReactionResponseDto } from 'src/reactions/dto/reaction-response.dto';
import { CommunityResponseDto } from 'src/communities/dto/community-response.dto';

@Exclude()
export class PostResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly title: string;
  @Expose() readonly content: string;
  @Expose() readonly views: number;
  @Expose() readonly createdAt: Date;
  @Expose() readonly updatedAt: Date;

  @Expose() @Type(() => UserResponseDto) readonly author: UserResponseDto;
  
  @Expose() @Type(() => CommunityResponseDto) readonly community?: CommunityResponseDto;

  @Expose() readonly commentsCount: number;
  @Expose() readonly likesCount: number;
  @Expose() readonly dislikesCount: number;
  
  @Expose() @Type(() => ReactionResponseDto) 
  readonly userReaction?: ReactionResponseDto | null;

  static fromEntity(entity: Post & { userReaction?: any }): PostResponseDto {
    return plainToInstance(
      PostResponseDto,
      {
        ...entity,
        author: entity.author ? UserResponseDto.fromEntity(entity.author) : null,
        community: entity.community ? CommunityResponseDto.fromEntity(entity.community) : null,
        commentsCount: entity.commentsCount,
        userReaction: entity.userReaction ? ReactionResponseDto.fromEntity(entity.userReaction) : null,
      },
      { excludeExtraneousValues: true },
    );
  }
}
---


### FILE: backend/src/posts/dto/update-post-approval.dto.ts ###
import { IsBoolean, IsNotEmpty } from 'class-validator';

export class UpdatePostApprovalDto {
  @IsBoolean()
  @IsNotEmpty()
  isApproved: boolean;
}

---


### FILE: backend/src/posts/dto/create-post.dto.ts ###
import { IsString, IsNotEmpty, IsInt, IsBoolean, IsOptional } from 'class-validator';
import { Type } from 'class-transformer';

export class CreatePostDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsString()
  @IsNotEmpty()
  content: string;

  @IsInt()
  @IsNotEmpty()
  @Type(() => Number)
  communityId: number;

  @IsBoolean()
  @IsOptional()
  isApproved?: boolean;
}

---


### FILE: backend/src/auth/auth.service.ts ###
// src/auth/auth.service.ts
import {
  BadRequestException,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService } from '../users/users.service';
import * as bcrypt from 'bcrypt';
import { User } from 'src/users/entities/user.entity';

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UsersService,
    private readonly jwt: JwtService,
    private readonly config: ConfigService,
  ) {}

  // -------------------------------------------------------------------------
  // Register (local account)
  // -------------------------------------------------------------------------
  async register(name: string, email: string, password: string): Promise<User> {
    return this.userService.createUser(
     { name,
      email,
      password, }
    );
  }

  // -------------------------------------------------------------------------
  // Validate credentials (used by LocalStrategy)
  // -------------------------------------------------------------------------
 // In auth.service.ts, update the validateUser method:
async validateUser(email: string, password: string): Promise<User> {
  const user = await this.userService.findByEmail(email);
  
  // If user doesn't exist or has no password (social-only account)
  if (!user || !user.password) {
    throw new UnauthorizedException('Invalid credentials');
  }
  
  const isMatch = await bcrypt.compare(password, user.password);
  
  if (!isMatch) {
    throw new UnauthorizedException('Invalid credentials');
  }
  
  return user;
}

  // -------------------------------------------------------------------------
  // Sign in (called after successful local or refresh validation)
  // -------------------------------------------------------------------------
  async signIn(user: User) {
    return this.generateTokens(user);
  }

  // -------------------------------------------------------------------------
  // Google OAuth login / link
  // -------------------------------------------------------------------------
  async googleLogin(oauthUser: {
    email: string;
    fullName?: string;
    id: string;
    picture?: string;
  }): Promise<User> {
    if (!oauthUser?.email) {
      throw new BadRequestException('Google account has no accessible email');
    }

    let user: User | null = null;

    try {
      user = await this.userService.findByEmail(oauthUser.email);
    } catch {
      user = null; // not found
    }

    if (!user) {
      // First time ‚Üí create new user
     return this.userService.createUser({
  name: oauthUser.fullName ?? oauthUser.email.split('@')[0],
  email: oauthUser.email,
  password: undefined, // no password
  provider: 'google',
  providerId: oauthUser.id,
  emailVerifiedAt: new Date(), // email already verified by Google
});

    }

    // Existing user ‚Üí make sure provider data is up-to-date
    return this.userService.updateUser({user ,
      name: oauthUser.fullName ?? user.name,
      provider: 'google',
      providerId: oauthUser.id,
      emailVerifiedAt: user.emailVerifiedAt ?? new Date(),
    });
  }

  // -------------------------------------------------------------------------
  // Refresh token flow
  // -------------------------------------------------------------------------
  async renewTokens(refreshToken: string) {
    const payload = this.jwt.verify(refreshToken, {
      secret: this.config.get<string>('JWT_REFRESH_SECRET'), // use ConfigService
    });
    const user = await this.userService.findOneById(payload.sub);
    return this.generateTokens(user);
  }

  // -------------------------------------------------------------------------
  // Token generation (shared)
  // -------------------------------------------------------------------------
  private generateTokens(user: User) {
    const payload = { sub: user.id, email: user.email };

    const accessToken = this.jwt.sign(payload, {
      secret: this.config.get<string>('JWT_ACCESS_SECRET'),
      expiresIn: this.config.getOrThrow('JWT_ACCESS_EXPIRES_IN'),
    });

    const refreshToken = this.jwt.sign(payload, {
      secret: this.config.get<string>('JWT_REFRESH_SECRET'),
      expiresIn: this.config.getOrThrow('JWT_REFRESH_EXPIRES_IN'),
    });

    return { accessToken, refreshToken };
  }
}
---


### FILE: backend/src/auth/dtos/register.dto.ts ###
import { IsEmail, IsString, MinLength } from 'class-validator';

export class RegisterDto {
  
  @IsEmail()
  email: string;

  @IsString()
   name: string;

  @IsString()
  @MinLength(6)
  password: string;
}

---


### FILE: backend/src/auth/dtos/login.dto.ts ###
import { IsEmail, IsString, MinLength } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(6)
  password: string;
}

---


### FILE: backend/src/auth/dtos/refresh.dto.ts ###
import { IsString, IsNotEmpty } from 'class-validator';

export class RefreshDto {
  @IsString()
  @IsNotEmpty()
  refreshToken: string;
}

---


### FILE: backend/src/auth/auth.controller.ts ###
import {
  Controller,
  Post,
  Body,
  UseGuards,
  Get,
  Req,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto } from './dtos/register.dto';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { JwtRefreshGuard } from './guards/jwt-refresh.guard';
import { EmailVerificationService } from 'src/email-verification/email-verification.service';
import { AuthGuard } from '@nestjs/passport';
import { UserResponseDto } from 'src/users/dtos/user-response.dto';
import { User } from 'src/users/entities/user.entity';
import { RefreshDto } from './dtos/refresh.dto';
import { ResponseDto } from 'src/common/dto/response.dto';

@Controller('auth')
export class AuthController {
  constructor(
    private readonly authService: AuthService,
    private readonly emailVerificationService: EmailVerificationService,
  ) {}

  @Post('register')
  async register(@Body() dto: RegisterDto): Promise<ResponseDto<UserResponseDto>> {
    const user = await this.authService.register(
      dto.name,
      dto.email,
      dto.password,
    );
    await this.emailVerificationService.sendVerificationEmail(user);
    return new ResponseDto(UserResponseDto.fromEntity(user), 'Registration successful. Please verify your email.');
  }

  @UseGuards(LocalAuthGuard)
  @Post('login')
  async login(@Req() req: { user: User }): Promise<ResponseDto<{ user: UserResponseDto; accessToken: string; refreshToken: string }>> {
    if (!req.user.emailVerifiedAt) {
      await this.emailVerificationService.sendVerificationEmail(req.user);

      throw new UnauthorizedException(
        'Email not verified. Verification email sent.',
      );
    }
    const tokens = await this.authService.signIn(req.user);
    return new ResponseDto({
      user: UserResponseDto.fromEntity(req.user),
      ...tokens,
    });
  }

  @UseGuards(JwtRefreshGuard)
  @Post('refresh')
  async refresh(@Body() dto: RefreshDto, @Req() req): Promise<ResponseDto<{ user: UserResponseDto; accessToken: string; refreshToken: string }>> {
    const tokens = await this.authService.renewTokens(dto.refreshToken);
    return new ResponseDto({
      user: UserResponseDto.fromEntity(req.user),
      ...tokens,
    });
  }

  // Step 1: Redirect to Google OAuth
  @Get('google')
  @UseGuards(AuthGuard('google'))
  async googleAuth() {
    // Passport automatically redirects to Google
  }

  // Step 2: Google callback ‚Üí GoogleStrategy.validate() ‚Üí req.user
  @Get('google/callback')
  @UseGuards(AuthGuard('google'))
  async googleCallback(@Req() req: { user: any }): Promise<ResponseDto<{ user: UserResponseDto; accessToken: string; refreshToken: string }>> {
    const user = await this.authService.googleLogin(req.user);
    const tokens = await this.authService.signIn(user);
    return new ResponseDto({
      user: UserResponseDto.fromEntity(user),
      ...tokens,
    });
  }
}

---


### FILE: backend/src/auth/auth.module.ts ###
import { Module } from '@nestjs/common';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';

import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';

import { UsersModule } from '../users/users.module';
import { JwtStrategy } from './strategies/jwt.strategy';
import { JwtRefreshStrategy } from './strategies/jwt-refresh.strategy';
import { LocalStrategy } from './strategies/local.strategy';
import { EmailVerificationModule } from 'src/email-verification/email-verification.module';
import { GoogleStrategy } from './strategies/google.strategy';
import { ConfigService } from '@nestjs/config';

@Module({
  imports: [
    UsersModule,
    PassportModule,
 JwtModule.registerAsync({
  inject: [ConfigService],
  useFactory: (config: ConfigService) => {
    const secret = config.getOrThrow<string>('JWT_ACCESS_SECRET');
    const expiresIn = config.getOrThrow('JWT_ACCESS_EXPIRES_IN');

    return {
      secret,
      signOptions: { expiresIn },
    };
  },
})
 ,
    EmailVerificationModule,
  ],
  controllers: [AuthController],
  providers: [
    AuthService,
    LocalStrategy,
    JwtStrategy,
    JwtRefreshStrategy,
    GoogleStrategy,
  ],
  exports: [AuthService],
})
export class AuthModule {}

---


### FILE: backend/src/auth/guards/optional-jwt-auth.guard.ts ###
import { Injectable, ExecutionContext } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class OptionalJwtAuthGuard extends AuthGuard('jwt') {
  // Only run passport when there's an Authorization header (or cookie extractor)
  canActivate(context: ExecutionContext) {
    const req = context.switchToHttp().getRequest();
    const authHeader = req.headers?.authorization;

    // If no auth header, allow anonymously
    if (!authHeader) {
      return true;
    }

    // If header exists, run the normal jwt guard which will call validate()
    return super.canActivate(context) as boolean | Promise<boolean>;
  }

  // handleRequest receives (err, user, info)
  handleRequest(err: any, user: any, info: any) {
    // log details to debug why authentication failed
    if (info) {
      console.log('OptionalJwtAuthGuard - passport info:', info);
    }
    if (err) {
      // real error (e.g. DB lookup failed) ‚Äî rethrow
      throw err;
    }

    // If passport failed to authenticate it may pass `false` or `undefined` here.
    // We want to silence that and allow anonymous access, so return null in that case.
    if (!user) {
      return null;
    }

    // Auth succeeded
    return user;
  }
}

---


### FILE: backend/src/auth/guards/jwt-refresh.guard.ts ###
import { AuthGuard } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtRefreshGuard extends AuthGuard('jwt-refresh') {}

---


### FILE: backend/src/auth/guards/jwt-auth.guard.ts ###
import { AuthGuard } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

---


### FILE: backend/src/auth/guards/local-auth.guard.ts ###
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

---


### FILE: backend/src/auth/strategies/local.strategy.ts ###
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { AuthService } from '../auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy, 'local') {
  constructor(private readonly authService: AuthService) {
    super({ usernameField: 'email' });
  }

  async validate(email: string, password: string) {
  try {
      const user = await this.authService.validateUser(email, password);
   
      return user;
    } catch (exception) {
      // Optional: log the original error for debugging
      console.error('Auth validation error:', exception);

      // Throw generic message to client
      throw new UnauthorizedException('Invalid credentials');
    }
  
  }
}

---


### FILE: backend/src/auth/strategies/google.strategy.ts ###
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, VerifyCallback } from 'passport-google-oauth20';
import { AuthService } from '../auth.service';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  constructor(
    private readonly authService: AuthService,
    private readonly config: ConfigService,
  ) {
    super({
      clientID: config.get<string>('GOOGLE_CLIENT_ID'),
      clientSecret: config.get<string>('GOOGLE_CLIENT_SECRET'),
      callbackURL: config.get<string>('GOOGLE_CALLBACK_URL'),
      scope: ['email', 'profile'],
      passReqToCallback: false,
    });
  }

  // profile comes from Google; map to our OAuthUser shape
  async validate(
    accessToken: string,
    refreshToken: string,
    profile: any,
    done: VerifyCallback,
  ): Promise<any> {
    try {
      const emailObj = (profile.emails && profile.emails[0]) || {
        value: undefined,
      };
      const oauthUser = {
        provider: 'google',
        providerId: profile.id,
        email: emailObj.value,
        name: profile.displayName,
      };

      // return the object that will be available as req.user
      return done(null, oauthUser);
    } catch (err) {
      return done(err as Error, false);
    }
  }
}

---


### FILE: backend/src/auth/strategies/jwt.strategy.ts ###
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService } from 'src/users/users.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy, 'jwt') {
  constructor(
    config: ConfigService,
    private readonly userService: UsersService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: config.getOrThrow<string>('JWT_ACCESS_SECRET'),
    });
  }

  // Hypothetical improvement
  async validate(payload: { sub: number; email: string }) {
    // 1. Check database for active user
    const user = await this.userService.findOneById(payload.sub);

    // 2. Reject if user doesn't exist (e.g., account was deleted)
    if (!user) {
      throw new UnauthorizedException();
    }

    // 3. Attach user object to req.user
    return user;
  }
}

---


### FILE: backend/src/auth/strategies/jwt-refresh.strategy.ts ###
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { UsersService } from 'src/users/users.service';

@Injectable()
export class JwtRefreshStrategy extends PassportStrategy(
  Strategy,
  'jwt-refresh',
) {
  constructor(
    config: ConfigService,
    private readonly userService: UsersService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromBodyField('refreshToken'),
      secretOrKey: config.getOrThrow<string>('JWT_REFRESH_SECRET'),
    });
  }

  async validate(payload: { sub: number; email: string }) {
    // 1. Check database for active user
    const user = await this.userService.findOneById(payload.sub);

    // 2. Reject if user doesn't exist (e.g., account was deleted)
    if (!user) {
      throw new UnauthorizedException();
    }

    // 3. Attach user object to req.user
    return user;
  }
}

---


### FILE: backend/src/reset-password/password-reset.controller.ts ###
import { Controller, Post, Body, Inject } from '@nestjs/common';
import { PasswordResetService } from './password-reset.service';
import { ForgotDto } from './dto/forgot.dto';
import { ResetDto } from './dto/reset.dto';
import { UsersService } from '../users/users.service';
import type { IMailService } from 'src/mail/interfaces/mail-service.interface';
import { ConfigService } from '@nestjs/config';

@Controller('reset-password')
export class PasswordResetController {
  constructor(
    private resetService: PasswordResetService,
    private usersService: UsersService,
    @Inject('IMailService') private mailService: IMailService,
    private config: ConfigService,
  ) {}

  @Post('forgot')
  async forgot(@Body() dto: ForgotDto) {
    try {
      const user = await this.usersService.findByEmail(dto.email);
      if (!user) return { message: 'Email sent if account exists' };

      const { token } = await this.resetService.generateToken(user.id);

      const resetLink = this.resetService.generateResetLink(token);
      await this.mailService.sendEmail(
        user.email,
        'Reset Your Password',
        'reset-password',
        { name: user.name, resetLink },
      );

      return { message: 'Email sent if account exists' };
    } catch (err) {
      console.log(err);

      return { message: 'Email sent if account exists' };
    }
  }

  @Post('reset')
  async reset(@Body() dto: ResetDto) {
    const userId = await this.resetService.validateToken(dto.token);
    const user = await this.usersService.findOneById(userId);

    await this.usersService.updateUser( 
      { user,
         password: dto.password });
    return { message: 'Password updated' };
  }
}

---


### FILE: backend/src/reset-password/reset-password.module.ts ###
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PasswordResetToken } from './entities/password-reset-token.entity';
import { PasswordResetService } from './password-reset.service';
import { PasswordResetController } from './password-reset.controller';
import { UsersModule } from '../users/users.module';
import { MailModule } from 'src/mail/mail.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([PasswordResetToken]),
    MailModule,
    UsersModule,
  ],
  controllers: [PasswordResetController],
  providers: [PasswordResetService],
  exports: [PasswordResetService],
})
export class ResetPasswordModule {}

---


### FILE: backend/src/reset-password/password-reset.service.ts ###
import { Injectable, BadRequestException } from '@nestjs/common';
import { PasswordResetToken } from './entities/password-reset-token.entity';
import { Repository, MoreThan } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { randomBytes } from 'crypto';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class PasswordResetService {
  private  TOKEN_EXPIRATION_MINUTES : number;

  constructor(
    @InjectRepository(PasswordResetToken)
    private repo: Repository<PasswordResetToken>,
    private config: ConfigService,
  ) {
    this.TOKEN_EXPIRATION_MINUTES=config.get<number>("TOKEN_EXPIRATION_MINUTES") ?? 15
  }

  /** Public API **/

  async generateToken(userId: number) {
    const token = this.generateTokenValue();
    const expiresAt = this.calculateExpiration();

    await this.saveToken(userId, token, expiresAt);

    return { token, expiresAt };
  }

  async validateToken(token: string) {
    const tokenRow = await this.findValidToken(token);

    if (!tokenRow) throw new BadRequestException('Invalid or expired token');

    await this.deleteToken(tokenRow.id);

    return tokenRow.userId;
  }

  public generateResetLink(token: string): string {
    const frontendUrl = this.config.get<string>(
      'APP_DOMAIN',
      'http://localhost:3000',
    );
    const resetPath = '/reset-password';
    return `${frontendUrl}${resetPath}?token=${token}`;
  }
  /** Private helpers **/

  private generateTokenValue(): string {
    return randomBytes(32).toString('hex');
  }

  private calculateExpiration(): Date {
    const now = new Date();
    return new Date(now.getTime() + this.TOKEN_EXPIRATION_MINUTES * 60_000);
  }

  private async saveToken(userId: number, token: string, expiresAt: Date) {
    const entity = this.repo.create({ userId, token, expiresAt });
    await this.repo.save(entity);
  }

  private async findValidToken(
    token: string,
  ): Promise<PasswordResetToken | null> {
    return this.repo.findOne({
      where: { token, expiresAt: MoreThan(new Date()) },
    });
  }

  private async deleteToken(id: number) {
    await this.repo.delete(id);
  }
}

---


### FILE: backend/src/reset-password/entities/password-reset-token.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  Index,
} from 'typeorm';

@Entity({ name: 'password_reset_tokens' })
export class PasswordResetToken {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  @Index()
  userId: number;

  @Column()
  @Index()
  token: string;

  @Column()
  expiresAt: Date;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: backend/src/reset-password/dto/reset.dto.ts ###
import { IsString, MinLength } from 'class-validator';

export class ResetDto {
  @IsString()
  token: string;

  @IsString()
  @MinLength(8)
  password: string;
}

---


### FILE: backend/src/reset-password/dto/forgot.dto.ts ###
import { IsEmail } from 'class-validator';

export class ForgotDto {
  @IsEmail()
  email: string;
}

---


### FILE: backend/src/communities/types.ts ###
export enum CommunityType {
  PUBLIC = 'public',
  RESTRICTED = 'restricted',
  PRIVATE = 'private',
}

---


### FILE: backend/src/communities/communities.service.ts ###
import {
  ConflictException,
  ForbiddenException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Not, Repository } from 'typeorm';
import { Community } from './entities/community.entity';
import { CommunityType } from './types';
import { User } from '../users/entities/user.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';
import { CommunityMembershipRole } from 'src/community-memberships/types';
import { CommunityMembershipRequest } from 'src/community-membership-requests/entities/community-membership-request.entity';
import { CommunityMembershipRequestStatus } from 'src/community-membership-requests/entities/community-membership-request.entity';
import { DataSource } from 'typeorm';

@Injectable()
export class CommunitiesService {
  constructor(    
    private dataSource: DataSource,
    @InjectRepository(Community)
    private readonly communitiesRepository: Repository<Community>,
    @InjectRepository(Community)
    private readonly communityRepository: Repository<Community>,
    @InjectRepository(CommunityMembership)
    private readonly membershipRepository: Repository<CommunityMembership>,
    @InjectRepository(CommunityMembershipRequest)
    private readonly membershipRequestRepository: Repository<CommunityMembershipRequest>,
  ) { }

  findAll(query: {
    limit?: number;
    page?: number;
    name?: string;
    displayName?: string;
    communityType?: CommunityType;
    sort?: string;
  }) {
    const { limit = 10, page = 1, name, displayName, communityType, sort } = query;
    const queryBuilder = this.communitiesRepository
      .createQueryBuilder('community')
      .leftJoinAndSelect('community.owner', 'owner')
      .take(limit)
      .skip((page - 1) * limit);

    if (name) queryBuilder.andWhere('community.name LIKE :name', { name: `%${name}%` });
    if (displayName) queryBuilder.andWhere('community.displayName LIKE :displayName', { displayName: `%${displayName}%` });
    if (communityType !== undefined) queryBuilder.andWhere('community.communityType = :communityType', { communityType });
    if (sort === 'popular') queryBuilder.orderBy('community.membersCount', 'DESC');

    return queryBuilder.getManyAndCount();
  }
  async create(data: {
    userId: number;
    name: string;
    displayName?: string;
    description?: string;
    communityType?: CommunityType;
  }) {
    return this.dataSource.transaction(async (manager) => {
      const existingCommunity = await manager.findOne(Community, {
        where: { name: data.name },
      });
      if (existingCommunity) {
        throw new ConflictException('Community with this name already exists.');
      }

      if (!data.displayName) data.displayName = data.name;

      const community = manager.create(Community, {
        ...data,
        owner: { id: data.userId },
      });
      const savedCommunity = await manager.save(community);

      const membership = manager.create(CommunityMembership, {
        userId: data.userId,
        communityId: savedCommunity.id,
        role: CommunityMembershipRole.OWNER,
      });
      await manager.save(membership);

      return savedCommunity;
    });
  }

  async findOne(id: number, user?: User): Promise<Community> {
    const community = await this.communitiesRepository.findOne({
      where: { id },
      relations: ['owner'],
    });

    if (!community) throw new NotFoundException(`Community with ID ${id} not found.`);

    await this.assertUserCanViewCommunity(user?.id, community);

    if (user) {
      const isMember = await this.membershipRepository.exist({
        where: {
          userId: user.id,
          communityId: community.id,
        },
      });
      console.log(isMember);
      

      if (isMember) {
        community.userMembershipStatus = 'member';
      } else {
        const pendingRequest = await this.membershipRequestRepository.findOne({
          where: {
            userId: user.id,
            communityId: community.id,
            status: CommunityMembershipRequestStatus.PENDING,
          },
        });

        if (pendingRequest) {
          community.userMembershipStatus = 'pending';
        } else {
          community.userMembershipStatus = 'none';
        }
      }
    } else {
      community.userMembershipStatus = 'none';
    }

    return community;
  }


  async update(data: {
    id: number;
    name?: string;
    displayName?: string;
    description?: string;
    communityType?: CommunityType;
    membersCount?: number;
  }) {
    const { id, name } = data;

    if (name) {
      const existing = await this.communitiesRepository.findOne({
        where: { name, id: Not(id) },
      });
      if (existing) throw new ConflictException('Community name already exists.');
    }

    const community = await this.communitiesRepository.preload(data);
    if (!community) throw new NotFoundException(`Community with ID ${id} not found.`);

    return this.communitiesRepository.save(community);
  }

  async remove(id: number) {
    const community = await this.findOne(id);
    await this.communitiesRepository.remove(community);
  }


  async assertUserCanViewCommunity(
    userId: number | undefined,
    community: Community,
  ): Promise<void> {
    switch (community.communityType) {
      case CommunityType.PUBLIC:
      case CommunityType.RESTRICTED:
        return;

      case CommunityType.PRIVATE:
        if (!userId) {
          throw new ForbiddenException('Login required to view this community');
        }

        const isMember = await this.membershipRepository.exist({
          where: {
            userId,
            communityId: community.id,
          },
        });

        if (!isMember) {
          throw new ForbiddenException('You are not a member of this community');
        }
        return;

      default:
        throw new ForbiddenException('Community is not accessible');
    }
  }

}

---


### FILE: backend/src/communities/entities/community.entity.ts ###
import {
  Column,
  CreateDateColumn,
  Entity,
  ManyToOne,
  OneToMany,
  PrimaryGeneratedColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Post } from '../../posts/entities/post.entity';
import { CommunityMembership } from '../../community-memberships/entities/community-memberships.entity';
import { CommunityMembershipRequest } from '../../community-membership-requests/entities/community-membership-request.entity';
import { CommunityRestriction } from '../../community-restrictions/entities/community-restriction.entity';
import { CommunityType } from '../types';

@Entity('communities')
export class Community {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 50, unique: true })
  name: string;

  @Column({ type: 'varchar', length: 100, nullable: true })
  displayName: string;

  @Column({ type: 'text', nullable: true })
  description: string;

  @ManyToOne(() => User, (user) => user.createdCommunities)
  owner: User;

  @Column({ nullable: true })
  ownerId: number;

  @CreateDateColumn()
  createdAt: Date;

  @Column({ type: 'simple-enum', enum : CommunityType, default: CommunityType.PUBLIC })
  communityType: CommunityType;

  @Column({ type: 'integer', default: 0 })
  membersCount: number;

  userMembershipStatus?: 'member' | 'pending' | 'none';

  @OneToMany(() => Post, (post) => post.community)
  posts: Post[];

  @OneToMany(
    () => CommunityMembership,
    (membership) => membership.community,
  )
  memberships: CommunityMembership[];

  @OneToMany(
    () => CommunityMembershipRequest,
    (request) => request.community,
  )
  membershipRequests: CommunityMembershipRequest[];

  @OneToMany(
    () => CommunityRestriction,
    (restriction) => restriction.community,
  )
  restrictions: CommunityRestriction[];
}

---


### FILE: backend/src/communities/communities.controller.ts ###
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  ParseIntPipe,
  UseGuards,
} from '@nestjs/common';
import { CommunitiesService } from './communities.service';
import { CreateCommunityDto } from './dto/create-community.dto';
import { UpdateCommunityDto } from './dto/update-community.dto';
import { CommunityQueryDto } from './dto/community-query.dto';
import { CommunityResponseDto } from './dto/community-response.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { User } from '../users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { OptionalJwtAuthGuard } from 'src/auth/guards/optional-jwt-auth.guard';

@Controller('communities')
export class CommunitiesController {
  constructor(private readonly communitiesService: CommunitiesService) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  async create(
    @Body() createCommunityDto: CreateCommunityDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommunityResponseDto>> {
    const community = await this.communitiesService.create({
       userId :user.id ,
      name: createCommunityDto.name,
      displayName: createCommunityDto.displayName,
      description: createCommunityDto.description,
      communityType: createCommunityDto.communityType,
    });
    return new ResponseDto(CommunityResponseDto.fromEntity(community));
  }

  @Get()
  async findAll(@Query() query: CommunityQueryDto): Promise<PaginatedResponseDto<CommunityResponseDto>> {
    const [communities, count] = await this.communitiesService.findAll({
      limit: query.limit,
      page: query.page,
      name: query.name,
      displayName: query.displayName,
      communityType: query.communityType,
      sort: query.sort,
    });

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      communities.length,
    );

    return new PaginatedResponseDto(communities.map(c => CommunityResponseDto.fromEntity(c)), paginationMeta);
  }

  @Get(':id')
  @UseGuards(OptionalJwtAuthGuard)
  async findOne(@Param('id', ParseIntPipe) id: number ,
  @GetUser() user :User)
  : Promise<ResponseDto<CommunityResponseDto>> {
    const community = await this.communitiesService.findOne(id,user);
    return new ResponseDto(CommunityResponseDto.fromEntity(community));
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateCommunityDto: UpdateCommunityDto,
  ): Promise<ResponseDto<CommunityResponseDto>> {
    const community = await this.communitiesService.update(  {
      id,
      name: updateCommunityDto.name,
      displayName: updateCommunityDto.displayName,
      description: updateCommunityDto.description,
      communityType: updateCommunityDto.communityType,
    });
    return new ResponseDto(CommunityResponseDto.fromEntity(community));
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  async remove(@Param('id', ParseIntPipe) id: number): Promise<ResponseDto<void>> {
    const success = await this.communitiesService.remove(id);
    return new ResponseDto(success);
  }
}

---


### FILE: backend/src/communities/communities.module.ts ###
import { Module } from '@nestjs/common';
import { CommunitiesService } from './communities.service';
import { CommunitiesController } from './communities.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Community } from './entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';

import { CommunityMembershipRequest } from 'src/community-membership-requests/entities/community-membership-request.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Community, CommunityMembership, CommunityMembershipRequest])],
  controllers: [CommunitiesController],
  providers: [CommunitiesService],
  exports: [CommunitiesService],
})
export class CommunitiesModule {}

---


### FILE: backend/src/communities/dto/create-community.dto.ts ###
import {
  IsEnum,
  IsOptional,
  IsString,
  Length,
  Matches,
} from 'class-validator';
import { CommunityType } from '../types';

export class CreateCommunityDto {
  @IsString()
  @Length(3, 50)
  @Matches(/^[a-z0-9\-]+$/, {
    message: 'Name can only contain lowercase letters, numbers, and hyphens.',
  })
  name: string;

  @IsOptional()
  @IsString()
  @Length(3, 100)
  displayName?: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsEnum(CommunityType)
  communityType?: CommunityType;
}

---


### FILE: backend/src/communities/dto/community-response.dto.ts ###
import { Exclude, Expose, plainToInstance } from 'class-transformer';
import { Community } from '../entities/community.entity';
import { CommunityType } from '../types'; // Import CommunityType

@Exclude()
export class CommunityResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly name: string;
  @Expose() readonly displayName: string;
  @Expose() readonly description: string;
  @Expose() readonly communityType: CommunityType;

  @Expose() readonly membersCount: number;
  @Expose() readonly createdAt: Date;
  @Expose() userMembershipStatus?: 'member' | 'pending' | 'none';

  static fromEntity(entity: Community): CommunityResponseDto {
    const dto = plainToInstance(CommunityResponseDto, entity, {
      excludeExtraneousValues: true,
    });
    dto.userMembershipStatus = entity.userMembershipStatus;
    return dto;
  }
}
---


### FILE: backend/src/communities/dto/community-query.dto.ts ###
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { PaginationDto } from '../../common/dto/pagination.dto';
import { CommunityType } from '../types';

export class CommunityQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  displayName?: string;

  @IsOptional()
  @IsEnum(CommunityType)
  communityType?: CommunityType;

  @IsOptional()
  @IsString()
  sort?: string;
}

---


### FILE: backend/src/communities/dto/update-community.dto.ts ###
import { PartialType } from '@nestjs/mapped-types';
import { CreateCommunityDto } from './create-community.dto';

export class UpdateCommunityDto extends PartialType(CreateCommunityDto) {}

---


### FILE: backend/src/mail/interfaces/mail-service.interface.ts ###
export interface IMailService {
  sendEmail(
    to: string,
    subject: string,
    templateName: string,
    context: any,
  ): Promise<void>;
}

---


### FILE: backend/src/mail/services/nodemailer-mail.service.ts ###
import { Injectable } from '@nestjs/common';
import { MailerService } from '@nestjs-modules/mailer';
import { IMailService } from '../interfaces/mail-service.interface';

@Injectable()
export class NodemailerMailService implements IMailService {
  constructor(private readonly mailerService: MailerService) {}

  async sendEmail(
    to: string,
    subject: string,
    templateName: string,
    context: any,
  ): Promise<void> {
    await this.mailerService.sendMail({
      to,
      subject,
      template: templateName,
      context,
    });
  }
}

---


### FILE: backend/src/mail/mail.module.ts ###
import { Module } from '@nestjs/common';
import { MailerModule } from '@nestjs-modules/mailer';
import { NodemailerMailService } from './services/nodemailer-mail.service';
import { IMailService } from './interfaces/mail-service.interface';
import { ConfigService } from '@nestjs/config';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
@Module({
  imports: [
    MailerModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        transport: {
          host: config.getOrThrow<string>('SMTP_HOST'),
          port: config.getOrThrow<number>('SMTP_PORT'),
          secure: false,
          /* auth: {
            user: config.getOrThrow<string>('SMTP_USER'),
            pass: config.getOrThrow<string>('SMTP_PASS'),
          },*/
        },
        defaults: {
          from: config.getOrThrow<string>('SMTP_FROM'),
        },
        template: {
          dir: process.cwd() + '/src/mail/templates',
          adapter: new HandlebarsAdapter(),
          options: { strict: true },
        },
      }),
    }),
  ],
  providers: [
    {
      provide: 'IMailService',
      useClass: NodemailerMailService,
    },
  ],
  exports: ['IMailService'],
})
export class MailModule {}

---


### FILE: backend/src/app.service.ts ###
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return '<h1>Hello World!';
  }
}

---


### FILE: backend/src/profile/profile.service.ts ###
import { ConflictException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Not, Repository } from 'typeorm';
import { Profile } from './entities/profile.entity';
import { User } from 'src/users/entities/user.entity';

interface CreateProfileParams {
  user: User;
  username: string;
  bio?: string | null;
  picture?: string | null;
}

interface UpdateProfileParams {
  profile: Profile;
  username?: string | null;
  bio?: string | null;
  picture?: string | null; // This will now be the file path
}

@Injectable()
export class ProfileService {
  constructor(
    @InjectRepository(Profile)
    private readonly profileRepo: Repository<Profile>,
  ) { }

  async createProfile(params: CreateProfileParams): Promise<Profile> {

    const existingProfile = await this
      .findOneByUserId(params.user.id)
      .catch(() => null);
    if (existingProfile) {
      throw new ConflictException('Profile already exists for this user.');
    }

    const existingUsername = await this.profileRepo.findOne({
      where: { username: params.username }, // exclude current profile
    });
    if (existingUsername) {
      throw new ConflictException('Username is already taken.');
    }

    const profile = this.profileRepo.create({
      user: params.user,
      username: params.username ?? null,
      bio: params.bio ?? null,
      picture: params.picture ?? null,
    });
    return this.profileRepo.save(profile);
  }

  async updateProfile(params: UpdateProfileParams): Promise<Profile> {
    const { profile, username, bio, picture } = params;

    if (username) {
      const existingUsername = await this.profileRepo.findOne({
        where: { username, id: Not(profile.id) }, // exclude current profile
      });
      if (existingUsername) {
        throw new ConflictException('Username is already taken.');
      }
    }

    Object.assign(profile, {
      ...(username !== undefined && { username }),
      ...(bio !== undefined && { bio }),
      ...(picture !== undefined && { picture }), // Directly assign the path
    });
    return this.profileRepo.save(profile);
  }

  async findOneByUserId(userId: number): Promise<Profile> {
    const profile = await this.profileRepo.findOne({ where: { user: { id: userId } } });
    if (!profile) {
      throw new NotFoundException(`Profile for user with ID ${userId} not found.`);
    }
    return profile;
  }
}
---


### FILE: backend/src/profile/dtos/create-profile.dto.ts ###
import { IsNotEmpty, IsString, IsOptional, IsAlphanumeric, MinLength, MaxLength } from 'class-validator';

export class CreateProfileDto {
  @IsNotEmpty()
  @IsString()
  @IsAlphanumeric()
  @MinLength(3)
  @MaxLength(20)
  username: string;

  @IsOptional()
  @IsString()
  @MaxLength(255)
  bio?: string;
}
---


### FILE: backend/src/profile/dtos/update-profile.dto.ts ###
import { IsOptional, IsString, IsUrl, IsAlphanumeric, MinLength, MaxLength } from 'class-validator';

export class UpdateProfileDto {
  @IsOptional()
  @IsString()
  @IsAlphanumeric()
  @MinLength(3)
  @MaxLength(20)
  username?: string;

  @IsOptional()
  @IsString()
  @MaxLength(255)
  bio?: string;
}

---


### FILE: backend/src/profile/dtos/profile-response.dto.ts ###
import { Expose } from 'class-transformer';
import { Profile } from '../entities/profile.entity';

export class ProfileResponseDto {
  @Expose()
  id: number;

  @Expose()
  username: string;

  @Expose()
  bio: string | null;

  @Expose()
  picture: string | null;

  /**
   * Factory method: converts a Profile entity into this DTO.
   * Purely copies values; no business or environment logic.
   */
  static fromEntity(entity: Profile): ProfileResponseDto {
    const dto = new ProfileResponseDto();
    dto.id = entity.id;
    dto.username = entity.username;
    dto.bio = entity.bio ?? null;
    dto.picture = entity.picture ?? null;
    return dto;
  }
}

---


### FILE: backend/src/profile/interceptors/picture.interceptor.ts ###
import { FileInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname } from 'path';

/**
 * Reusable interceptor for profile picture uploads.
 * @param field The name of the file field (default: 'picture')
 */
export function PictureInterceptor(field = 'picture') {
  return FileInterceptor(field, {
    storage: diskStorage({
      destination: './uploads',
      filename: (_req, file, cb) => {
        const randomName = Array(32)
          .fill(null)
          .map(() => Math.floor(Math.random() * 16).toString(16))
          .join('');
        cb(null, `${randomName}${extname(file.originalname)}`);
      },
    }),
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
    fileFilter: (_req, file, callback) => {
      const allowedTypes = /jpeg|jpg|png|gif/;
      callback(null, allowedTypes.test(file.mimetype));
    },
  });
}

---


### FILE: backend/src/profile/profile.controller.ts ###
import {
  Controller,
  Get,
  UseGuards,
  Patch,
  Body,
  UseInterceptors,
  UploadedFile,
  Post,
  ConflictException,
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ProfileService } from './profile.service';
import { UpdateProfileDto } from './dtos/update-profile.dto';
import { CreateProfileDto } from './dtos/create-profile.dto';
import { User } from 'src/users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { FileInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname } from 'path';
import { ProfileResponseDto } from './dtos/profile-response.dto';
import { ConfigService } from '@nestjs/config';
import { PictureInterceptor } from './interceptors/picture.interceptor';

@Controller('profile')
export class ProfileController {
  constructor(private readonly profileService: ProfileService

  ) { }
  @UseGuards(JwtAuthGuard)
  @Get()
  async getMyProfile(@GetUser() user: User): Promise<ProfileResponseDto> {
    const profile = await this.profileService.findOneByUserId(user.id);
    return ProfileResponseDto.fromEntity(profile);
  }

  @UseGuards(JwtAuthGuard)
  @Post()
  @UseInterceptors(PictureInterceptor
  )
  async createMyProfile(
    @GetUser() user: User,
    @Body() createProfileDto: CreateProfileDto,
    @UploadedFile() file: Express.Multer.File,
  ): Promise<ProfileResponseDto> {

    const profile = await this.profileService.createProfile({
      user,
      username: createProfileDto.username,
      bio: createProfileDto.bio,
      picture: file ? file.path : undefined,
    });

    return ProfileResponseDto.fromEntity(profile);
  }

  @UseGuards(JwtAuthGuard)
  @Patch()
  @UseInterceptors(PictureInterceptor)
  async updateMyProfile(
    @GetUser() user: User,
    @Body() updateProfileDto: UpdateProfileDto,
    @UploadedFile() file: Express.Multer.File,
  ): Promise<ProfileResponseDto> {
    const profile = await this.profileService.findOneByUserId(user.id);

    const updatedProfile = await this.profileService.updateProfile({
      profile,
      username: updateProfileDto.username,
      bio: updateProfileDto.bio,
      picture: file ? file.path : undefined,
    });

    return ProfileResponseDto.fromEntity(updatedProfile);
  }
}
---


### FILE: backend/src/profile/entities/profile.entity.ts ###
// src/profile/entities/profile.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, OneToOne, JoinColumn } from 'typeorm';
import { User } from '../../users/entities/user.entity'; // Updated path

@Entity('profiles') // Updated entity name
export class Profile { // Updated class name
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', unique: true })
  username: string;

  @Column({ type: 'text', nullable: true })
  bio: string | null;

  @Column({ type: 'varchar', nullable: true })
  picture: string | null;

  @OneToOne(() => User, user => user.profile)
  @JoinColumn()
  user: User;
}

---


### FILE: backend/src/profile/profile.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Profile } from './entities/profile.entity';
import { ProfileService } from './profile.service';
import { ProfileController } from './profile.controller';

@Module({
  imports: [TypeOrmModule.forFeature([Profile])],
  providers: [ProfileService],
  controllers: [ProfileController],
  exports: [ProfileService], // Export ProfileService so other modules can use it
})
export class ProfileModule {}

---


### FILE: backend/src/community-restrictions/community-restrictions.module.ts ###
import { Module } from '@nestjs/common';
import { CommunityRestrictionsService } from './community-restrictions.service';
import { CommunityRestrictionsController } from './community-restrictions.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';
import { User } from 'src/users/entities/user.entity';
import { CommunityRestriction } from './entities/community-restriction.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      CommunityRestriction,
      Community,
      User,
      CommunityMembership,
    ]),
  ],
  controllers: [CommunityRestrictionsController],
  providers: [CommunityRestrictionsService],
  exports: [CommunityRestrictionsService],
})
export class CommunityRestrictionsModule {}

---


### FILE: backend/src/community-restrictions/community-restrictions.controller.ts ###
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  ParseIntPipe,
  UseGuards,
} from '@nestjs/common';
import { CommunityRestrictionsService } from './community-restrictions.service';
import { CreateCommunityRestrictionDto } from './dto/create-community-restriction.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { User } from '../users/entities/user.entity';
import { GetUser } from 'src/decorators/user.decorator';
import { UpdateCommunityRestrictionDto } from './dto/update-community-restriction.dto';
import { CaslService } from 'src/casl/casl.service';
import { Action } from 'src/casl/casl.types';
import { CommunityRestriction } from './entities/community-restriction.entity';
import { CommunityRestrictionResponseDto } from './dto/community-restriction-response.dto';
import { ResponseDto } from 'src/common/dto/response.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { CommunityRestrictionQueryDto } from './dto/community-restriction-query.dto';

@Controller('community-restrictions')
export class CommunityRestrictionsController {
  constructor(
    private readonly communityRestrictionsService: CommunityRestrictionsService,
    private readonly caslService: CaslService,
  ) {}

  @Post()
  @UseGuards(JwtAuthGuard)
  async create(
    @Body() createCommunityRestrictionDto: CreateCommunityRestrictionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommunityRestrictionResponseDto>> {
    // TODO: Add CASL check
    const restriction = await this.communityRestrictionsService.create(
      {
        restrictionType: createCommunityRestrictionDto.restrictionType,
        communityId: createCommunityRestrictionDto.communityId,
        userId: createCommunityRestrictionDto.userId,
      },
      user,
    );
    return new ResponseDto(CommunityRestrictionResponseDto.fromEntity(restriction));
  }

  @Get()
  @UseGuards(JwtAuthGuard)
  async findAll(
    @Query() query: CommunityRestrictionQueryDto,
    @GetUser() user: User,
  ): Promise<PaginatedResponseDto<CommunityRestrictionResponseDto>> {
    const { data, count } = await this.communityRestrictionsService.findAll(query, user);

    const paginationMeta = new PaginationMetaDto(query.page, query.limit, count, data.length);

    return new PaginatedResponseDto(
      data.map(CommunityRestrictionResponseDto.fromEntity),
      paginationMeta,
    );
  }

  @Get(':id')
  @UseGuards(JwtAuthGuard)
  async findOne(
    @Param('id', ParseIntPipe) id: number,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommunityRestrictionResponseDto>> {
    const restriction = await this.communityRestrictionsService.findOne(id, user);
    return new ResponseDto(CommunityRestrictionResponseDto.fromEntity(restriction));
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateCommunityRestrictionDto: UpdateCommunityRestrictionDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommunityRestrictionResponseDto>> {
    // TODO: Add CASL check
    const restriction = await this.communityRestrictionsService.update(
      id,
      { restrictionType: updateCommunityRestrictionDto.restrictionType },
      user,
    );
    return new ResponseDto(CommunityRestrictionResponseDto.fromEntity(restriction));
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  async remove(
    @Param('id', ParseIntPipe) id: number,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    // TODO: Add CASL check
    await this.communityRestrictionsService.remove(id, user);
    return new ResponseDto(true);
  }
}

---


### FILE: backend/src/community-restrictions/entities/community-restriction.entity.ts ###
import {
  Column,
  CreateDateColumn,
  Entity,
  ManyToOne,
  PrimaryGeneratedColumn,
} from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { Community } from '../../communities/entities/community.entity';
import { CommunityRestrictionType } from '../community-restrictions.types';

@Entity('community_restrictions')
export class CommunityRestriction {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'simple-enum', enum: CommunityRestrictionType })
  restrictionType: CommunityRestrictionType;

  @ManyToOne(() => Community, (community) => community.restrictions)
  community: Community;

  @ManyToOne(() => User, (user) => user.communityRestrictions)
  user: User;

  @CreateDateColumn()
  createdAt: Date;
}

---


### FILE: backend/src/community-restrictions/community-restrictions.service.ts ###
import {
  ConflictException,
  ForbiddenException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CommunityRestriction } from './entities/community-restriction.entity';
import { User } from '../users/entities/user.entity';
import { DataSource } from 'typeorm';
import { Community } from 'src/communities/entities/community.entity';
import { CommunityMembership } from 'src/community-memberships/entities/community-memberships.entity';
import { CommunityMembershipRole } from 'src/community-memberships/types';
import { CommunityRestrictionType } from './community-restrictions.types';

@Injectable()
export class CommunityRestrictionsService {
  constructor(
    private dataSource: DataSource,
    @InjectRepository(CommunityRestriction)
    private readonly communityRestrictionsRepository: Repository<CommunityRestriction>,
    @InjectRepository(Community)
    private readonly communityRepository: Repository<Community>,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(CommunityMembership)
    private readonly communityMembershipRepository: Repository<CommunityMembership>,
  ) {}

  async create(
    data: {
      restrictionType: CommunityRestrictionType;
      communityId: number;
      userId: number;
    },
    user: User,
  ) {
    const community = await this.communityRepository.findOne({
      where: { id: data.communityId },
    });
    if (!community) {
      throw new NotFoundException('Community not found');
    }

    const targetUser = await this.userRepository.findOne({
      where: { id: data.userId },
    });
    if (!targetUser) {
      throw new NotFoundException('User to restrict not found');
    }

    const membership = await this.communityMembershipRepository.findOne({
      where: { communityId: community.id, userId: user.id },
    });

    if (
      !membership ||
      (membership.role !== CommunityMembershipRole.OWNER &&
        membership.role !== CommunityMembershipRole.MODERATOR)
    ) {
      throw new ForbiddenException(
        'You do not have permission to restrict users in this community.',
      );
    }

    const existingRestriction = await this.communityRestrictionsRepository.findOne({
      where: {
        community: { id: community.id },
        user: { id: targetUser.id },
      },
    });

    if (existingRestriction) {
      throw new ConflictException('This user is already restricted in this community.');
    }

    const restriction = this.communityRestrictionsRepository.create({
      restrictionType: data.restrictionType,
      community,
      user: targetUser,
    });

    return this.communityRestrictionsRepository.save(restriction);
  }

  async findAll(
    query: { communityId?: number; limit?: number; page?: number },
    user: User,
  ) {
    const { communityId, limit = 10, page = 1 } = query;

    const queryBuilder = this.communityRestrictionsRepository
      .createQueryBuilder('restriction')
      .leftJoinAndSelect('restriction.community', 'community')
      .leftJoinAndSelect('restriction.user', 'user')
      .take(limit)
      .skip((page - 1) * limit);

    if (communityId) {
      const community = await this.communityRepository.findOne({
        where: { id: communityId },
      });
      if (!community) {
        throw new NotFoundException('Community not found');
      }

      const membership = await this.communityMembershipRepository.findOne({
        where: { communityId: community.id, userId: user.id },
      });

      if (
        !membership ||
        (membership.role !== CommunityMembershipRole.OWNER &&
          membership.role !== CommunityMembershipRole.MODERATOR)
      ) {
        throw new ForbiddenException(
          'You do not have permission to view restrictions in this community.',
        );
      }
      queryBuilder.andWhere('restriction.communityId = :communityId', { communityId });
    }

    const [data, count] = await queryBuilder.getManyAndCount();
    return { data, count };
  }

  async findOne(id: number, user: User) {
    const restriction = await this.communityRestrictionsRepository.findOne({
      where: { id },
      relations: ['community'],
    });

    if (!restriction) {
      throw new NotFoundException('Restriction not found');
    }

    const membership = await this.communityMembershipRepository.findOne({
      where: { communityId: restriction.community.id, userId: user.id },
    });

    if (
      !membership ||
      (membership.role !== CommunityMembershipRole.OWNER &&
        membership.role !== CommunityMembershipRole.MODERATOR)
    ) {
      throw new ForbiddenException(
        'You do not have permission to view this restriction.',
      );
    }

    return restriction;
  }

  async update(
    id: number,
    data: { restrictionType?: CommunityRestrictionType },
    user: User,
  ) {
    const restriction = await this.communityRestrictionsRepository.findOne({
      where: { id },
      relations: ['community'],
    });

    if (!restriction) {
      throw new NotFoundException('Restriction not found');
    }

    const membership = await this.communityMembershipRepository.findOne({
      where: { communityId: restriction.community.id, userId: user.id },
    });

    if (
      !membership ||
      (membership.role !== CommunityMembershipRole.OWNER &&
        membership.role !== CommunityMembershipRole.MODERATOR)
    ) {
      throw new ForbiddenException(
        'You do not have permission to update restrictions in this community.',
      );
    }

    if (data.restrictionType) {
      restriction.restrictionType = data.restrictionType;
    }

    return this.communityRestrictionsRepository.save(restriction);
  }

  async findOneById(id: number) {
    return this.communityRestrictionsRepository.findOne({
      where: { id },
      relations: ['community', 'user'],
    });
  }

  async remove(id: number, user: User): Promise<boolean> {
    const restriction = await this.communityRestrictionsRepository.findOne({
      where: { id },
      relations: ['community'],
    });

    if (!restriction) {
      throw new NotFoundException('Restriction not found');
    }

    const membership = await this.communityMembershipRepository.findOne({
      where: { communityId: restriction.community.id, userId: user.id },
    });

    if (
      !membership ||
      (membership.role !== CommunityMembershipRole.OWNER &&
        membership.role !== CommunityMembershipRole.MODERATOR)
    ) {
      throw new ForbiddenException(
        'You do not have permission to remove restrictions in this community.',
      );
    }

    await this.communityRestrictionsRepository.remove(restriction);
    return true;
  }
}

---


### FILE: backend/src/community-restrictions/dto/community-restriction-response.dto.ts ###
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { CommunityRestriction } from '../entities/community-restriction.entity';
import { CommunityResponseDto } from 'src/communities/dto/community-response.dto';
import { CommunityRestrictionType } from '../community-restrictions.types';

@Exclude()
export class CommunityRestrictionResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly restrictionType: CommunityRestrictionType;
  @Expose() readonly createdAt: Date;

  @Expose() @Type(() => UserResponseDto) readonly user: UserResponseDto;
  @Expose() @Type(() => CommunityResponseDto) readonly community: CommunityResponseDto;

  static fromEntity(entity: CommunityRestriction): CommunityRestrictionResponseDto {
    return plainToInstance(
      CommunityRestrictionResponseDto,
      {
        ...entity,
        user: entity.user ? UserResponseDto.fromEntity(entity.user) : null,
        community: entity.community ? CommunityResponseDto.fromEntity(entity.community) : null,
      },
      { excludeExtraneousValues: true },
    );
  }
}

---


### FILE: backend/src/community-restrictions/dto/community-restriction-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsInt } from 'class-validator';
import { Type } from 'class-transformer';

export class CommunityRestrictionQueryDto extends PaginationDto {
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  communityId?: number;
}

---


### FILE: backend/src/community-restrictions/dto/create-community-restriction.dto.ts ###
import { IsEnum, IsNumber } from 'class-validator';
import { CommunityRestrictionType } from '../community-restrictions.types';

export class CreateCommunityRestrictionDto {
  @IsEnum(CommunityRestrictionType)
  restrictionType: CommunityRestrictionType;

  @IsNumber()
  communityId: number;

  @IsNumber()
  userId: number;
}

---


### FILE: backend/src/community-restrictions/dto/update-community-restriction.dto.ts ###
import { IsEnum, IsOptional } from 'class-validator';
import { CommunityRestrictionType } from '../community-restrictions.types';

export class UpdateCommunityRestrictionDto {
  @IsOptional()
  @IsEnum(CommunityRestrictionType)
  restrictionType?: CommunityRestrictionType;
}

---


### FILE: backend/src/community-restrictions/community-restrictions.types.ts ###
export enum CommunityRestrictionType {
  BAN = 'ban',
  MUTE = 'mute',
}

---


### FILE: backend/src/app.module.ts ###
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';

import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UsersModule } from './users/users.module';
import { PostsModule } from './posts/posts.module';
import { CommentsModule } from './comments/comments.module';
import { ReactionsModule } from './reactions/reactions.module';
import { CommunitiesModule } from './communities/communities.module';
import { CommunityMembershipsModule } from './community-memberships/community-memberships.module';

import { User } from './users/entities/user.entity';
import { Post } from './posts/entities/post.entity';
import { Comment } from './comments/entities/comment.entity';
import { AuthModule } from './auth/auth.module';
import { CaslModule } from './casl/casl.module';
import { EmailVerificationToken } from './email-verification/entities/email-verification-token.entity';

import { ResetPasswordModule } from './reset-password/reset-password.module';
import { PasswordResetToken } from './reset-password/entities/password-reset-token.entity';
import { CommentReaction } from './reactions/entities/comment-reaction.entity';
import { PostReaction } from './reactions/entities/post-reaction.entity';
import { Profile } from './profile/entities/profile.entity';
import { ProfileModule } from './profile/profile.module';
import { Community } from './communities/entities/community.entity';
import { CommunityMembership } from './community-memberships/entities/community-memberships.entity';
import { ReportsModule } from './reports/reports.module';
import { CommentReport } from './reports/entities/comment-report.entity';
import { PostReport } from './reports/entities/post-report.entity';
import { UserReport } from './reports/entities/user-report.entity';
import { CommunityMembershipRequest } from './community-membership-requests/entities/community-membership-request.entity';
import { CommunityMembershipRequestsModule } from './community-membership-requests/community-membership-requests.module';
import { CommunityRestriction } from './community-restrictions/entities/community-restriction.entity';
import { CommunityRestrictionsModule } from './community-restrictions/community-restrictions.module';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }), // loads .env globally

    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        type: config.getOrThrow<'sqlite' | 'mysql'>('DB_TYPE'),
        database: config.getOrThrow<string>('DB_NAME'),
        entities: [
          User,
          Post,
          Comment,
          CommentReaction,
          PostReaction,
          EmailVerificationToken,
          PasswordResetToken,
          Profile,
          Community,
          CommunityMembership,
          CommunityMembershipRequest, // NEW ENTITY
          CommentReport,
          PostReport,
          UserReport,
          CommunityRestriction,
        ],
        migrations: ['./src/migrations/*.ts'],
        synchronize: false,
      }),
    }),

    UsersModule,
    PostsModule,
    CommentsModule,
    ReactionsModule,
    AuthModule,
    CaslModule,
    ResetPasswordModule,
    ProfileModule,
    CommunitiesModule,
    CommunityMembershipsModule,
    CommunityMembershipRequestsModule, // NEW MODULE
    ReportsModule,
    CommunityRestrictionsModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

---


### FILE: backend/src/data-source.ts ###
import { DataSource } from 'typeorm';
import { config } from 'dotenv';
import { Post } from './posts/entities/post.entity';
import { User } from './users/entities/user.entity';
import { Comment } from './comments/entities/comment.entity';
import { PostReaction } from './reactions/entities/post-reaction.entity';
import { CommentReaction } from './reactions/entities/comment-reaction.entity';
import { EmailVerificationToken } from './email-verification/entities/email-verification-token.entity';
import { PasswordResetToken } from './reset-password/entities/password-reset-token.entity';
import { Profile } from './profile/entities/profile.entity';
import { Community } from './communities/entities/community.entity'; // Import Community
import { CommunityMembership } from './community-memberships/entities/community-memberships.entity'; // Import CommunityMembership
import { PostReport } from './reports/entities/post-report.entity';
import { CommentReport } from './reports/entities/comment-report.entity';
import { CommunityRestriction } from './community-restrictions/entities/community-restriction.entity';
import { UserReport } from './reports/entities/user-report.entity';

import { CommunityMembershipRequest } from './community-membership-requests/entities/community-membership-request.entity';

config(); // load .env manually

const dbName = process.env.DB_NAME;
if (!dbName) {
  throw new Error('DB_NAME environment variable is not defined.');
}

export const AppDataSource = new DataSource({
  type: 'sqlite',
  database: dbName,
  entities: [
    User,
    Post,
    Comment,
    PostReaction,
    CommentReaction,
    PasswordResetToken,
    EmailVerificationToken,
    Profile,
    Community, // Add Community
    CommunityMembership, // Add CommunityMembership
    CommunityMembershipRequest, // Add CommunityMembershipRequest
    PostReport,
    CommentReport,
    UserReport,
    CommunityRestriction,
  ],
  synchronize: false,
  migrations: ['src/database/migrations/*.ts'],
  logging: true,
});

---


### FILE: backend/src/comments/pipes/comment.pipe.ts ###
import { Injectable, PipeTransform, NotFoundException } from '@nestjs/common';
import { CommentsService } from '../comments.service';
import { Comment } from '../entities/comment.entity';

@Injectable()
export class CommentPipe implements PipeTransform<string, Promise<Comment>> {
  constructor(private readonly commentsService: CommentsService) {}

  async transform(value: string): Promise<Comment> {
    const comment = await this.commentsService.findOne(+value);

    if (!comment) {
      throw new NotFoundException('Comment not found');
    }

    return comment;
  }
}

---


### FILE: backend/src/comments/comments.service.ts ###
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm'; // Added DataSource
import { Comment } from './entities/comment.entity';
import { Post } from 'src/posts/entities/post.entity'; // Added Post entity

// import { PostsService } from 'src/posts/posts.service'; // Removed PostsService

@Injectable()
export class CommentsService {
  constructor(
    @InjectRepository(Comment)
    private readonly commentRepo: Repository<Comment>,
    // private readonly postsService: PostsService, // Removed PostsService
    @InjectRepository(Post) // Injected Post repository
    private readonly postRepo: Repository<Post>,
    private dataSource: DataSource, // Injected DataSource
  ) { }

  async findAll(options: {
    postId?: number;
    authorId?: number;
    search?: string;
    page?: number;
    limit?: number;
    currentUserId?: number;
    parentId?: number;
  }): Promise<{ data: Comment[]; count: number }> {
    const { postId, authorId, search, page = 1, limit = 10, currentUserId, parentId } = options;

    const query = this.commentRepo
      .createQueryBuilder('comment')
      .leftJoinAndSelect('comment.author', 'author')
      .leftJoinAndSelect('comment.post', 'post')
      .leftJoinAndSelect('comment.parent', 'parent');

    if (parentId) {
      query.andWhere('comment.parentId = :parentId', { parentId });
    } else if (postId) {
      query.andWhere('comment.parentId IS NULL');
    }

    if (currentUserId) {
      query.leftJoinAndMapOne(
        'comment.userReaction',
        'comment.reactions',
        'userReaction',
        'userReaction.userId = :currentUserId',
      );
      query.setParameter('currentUserId', currentUserId);
    }

    if (search) {
      query.andWhere('comment.content LIKE :search', { search: `%${search}%` });
    }
    if (authorId) {
      query.andWhere('comment.author.id = :authorId', { authorId });
    }
    if (postId) {
      query.andWhere('comment.post.id = :postId', { postId });
    }

    query.orderBy('comment.createdAt', 'DESC');

    const [data, count] = await query.take(limit).skip((page - 1) * limit).getManyAndCount();

    const commentsWithLimitedReplies = await Promise.all(
      data.map(async (comment) => {
        const repliesQuery = this.commentRepo
          .createQueryBuilder('reply')
          .leftJoinAndSelect('reply.author', 'author')
          .where('reply.parentId = :commentId', { commentId: comment.id })
          .orderBy('reply.createdAt', 'ASC')
          .take(2);

        if (currentUserId) {
          repliesQuery.leftJoinAndMapOne(
            'reply.userReaction',
            'reply.reactions',
            'userReaction',
            'userReaction.userId = :currentUserId',
          );
          repliesQuery.setParameter('currentUserId', currentUserId);
        }

        comment.replies = await repliesQuery.getMany();
        return comment;
      }),
    );

    return { data: commentsWithLimitedReplies, count };
  }

  async findOne(id: number, currentUserId?: number) {

    const mainCommentQuery = this.commentRepo.createQueryBuilder('comment')

      .leftJoinAndSelect('comment.author', 'author')

      .leftJoinAndSelect('comment.post', 'post')

      .leftJoinAndSelect('comment.parent', 'parent');

    if (currentUserId) {

      mainCommentQuery.leftJoinAndMapOne(

        'comment.userReaction',

        'comment.reactions',

        'userReaction',

        'userReaction.userId = :currentUserId',

      );

      mainCommentQuery.setParameter('currentUserId', currentUserId);

    }

    mainCommentQuery.where('comment.id = :id', { id });

    const comment = await mainCommentQuery.getOne();

    if (comment) {

      const repliesQuery = this.commentRepo

        .createQueryBuilder('reply')

        .leftJoinAndSelect('reply.author', 'author')

        .where('reply.parentId = :commentId', { commentId: comment.id })

        .orderBy('reply.createdAt', 'ASC')

        .take(2); // Limit to 2 replies

      if (currentUserId) {

        repliesQuery.leftJoinAndMapOne(

          'reply.userReaction',

          'reply.reactions',

          'userReaction',

          'userReaction.userId = :currentUserId',

        );

        repliesQuery.setParameter('currentUserId', currentUserId);

      }

      comment.replies = await repliesQuery.getMany();

    }

    return comment;

  }

  async createComment(
    postId: number,
    content: string,
    userId: number,
    parentId?: number,
  ) {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // Get the post directly
      const post = await queryRunner.manager.findOne(Post, { where: { id: postId } });
      if (!post) {
        throw new NotFoundException('Post not found');
      }

      if (post.commentsLocked) {
        throw new BadRequestException('Comments are locked for this post.');
      }

      
      const comment = queryRunner.manager.create(Comment, {
        content,
        authorId: userId,
        post: post,
      });

      if (parentId) {
        const parent = await queryRunner.manager.findOne(Comment, {
          where: { id: parentId },
          relations: ['post'],
        });
        if (!parent)
          throw new NotFoundException('Parent comment not found');
        if (parent.post.id !== postId) {
          throw new BadRequestException(
            'Parent comment does not belong to this post',
          );
        }
        comment.parent = parent;
        await queryRunner.manager.increment(Comment, { id: parentId }, 'repliesCount', 1); // Increment repliesCount directly
      }

      const savedComment = await queryRunner.manager.save(comment);

      // Increment commentsCount on the post directly
      await queryRunner.manager.increment(Post, { id: postId }, 'commentsCount', 1);

      await queryRunner.commitTransaction();
      return savedComment;
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }

  async update(
    updateCommentData: {
      id: number;
      content?: string;
    },
  ): Promise<Comment> {
    const comment = await this.commentRepo.findOneBy({
      id: updateCommentData.id,
    });
    if (!comment) {
      throw new NotFoundException('Comment not found');
    }

    if (updateCommentData.content !== undefined)
      comment.content = updateCommentData.content;

    return this.commentRepo.save(comment);
  }

  async remove(id: number): Promise<boolean> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const comment = await queryRunner.manager.findOne(Comment, {
        where: { id },
        relations: ['post', 'parent'], // Load post and parent relation to update counts
      });
      if (!comment) {
        throw new NotFoundException('Comment not found');
      }

      // Decrement commentsCount on the post directly
      if (comment.post) {
        await queryRunner.manager.decrement(Post, { id: comment.post.id }, 'commentsCount', 1);
      }

      // Decrement repliesCount on the parent comment directly
      if (comment.parent) {
        await queryRunner.manager.decrement(Comment, { id: comment.parent.id }, 'repliesCount', 1);
      }

      await queryRunner.manager.remove(comment);
      await queryRunner.commitTransaction();
      return true;
    } catch (err) {
      await queryRunner.rollbackTransaction();
      throw err;
    } finally {
      await queryRunner.release();
    }
  }



}

---


### FILE: backend/src/comments/comments.controller.ts ###
import {
  Controller,
  Get,
  Post as HttpPost,
  Patch,
  Delete,
  Param,
  Body,
  UseGuards,
  Query,
  NotFoundException, // Added
} from '@nestjs/common';
import { CommentsService } from './comments.service';
import { CreateCommentDto } from './dto/create-comment.dto';
import { UpdateCommentDto } from './dto/update-comment.dto';
import { GetUser } from 'src/decorators/user.decorator';
import { User } from 'src/users/entities/user.entity';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { OptionalJwtAuthGuard } from 'src/auth/guards/optional-jwt-auth.guard'; // Added
import { Action } from 'src/casl/casl.types';
import { Comment } from './entities/comment.entity';
// Removed CommentPipe
import { Post as PostEntity } from 'src/posts/entities/post.entity';
import { PostPipe } from 'src/posts/pipes/post.pipe';
import { CaslService } from 'src/casl/casl.service';
import { CommentResponseDto } from './dto/comment-response.dto';
import { CommentQueryDto } from './dto/comment-query.dto';
import { PaginatedResponseDto } from 'src/common/dto/paginated-response.dto';
import { PaginationMetaDto } from 'src/common/dto/pagination-meta.dto';
import { ResponseDto } from 'src/common/dto/response.dto';
import { CommentPipe } from './pipes/comment.pipe';

@Controller()
export class CommentsController {
  constructor(
    private readonly commentsService: CommentsService,
    private readonly caslService: CaslService,
  ) { }

  @Get('comments')
  @UseGuards(OptionalJwtAuthGuard) // Add guard to get user
  async findAll(@Query() query: CommentQueryDto, @GetUser() user: User): Promise<PaginatedResponseDto<CommentResponseDto>> {
    const { data, count } = await this.commentsService.findAll(
    { page: query.page,
      limit :query.limit,
      search :query.search,
      authorId :query.authorId,
      currentUserId: user?.id, // Pass currentUserId
    }
    );

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );

    return new PaginatedResponseDto(data.map(CommentResponseDto.fromEntity), paginationMeta);
  }

  @Get('posts/:postId/comments')
  @UseGuards(OptionalJwtAuthGuard) // Add guard to get user
  async findByPost(
    @Param('postId', PostPipe) post: PostEntity,
    @Query() query: CommentQueryDto,
    @GetUser() user: User, // Get current user
  ): Promise<PaginatedResponseDto<CommentResponseDto>> {
    const { data, count } = await this.commentsService.findAll(
      {
        postId: post.id,
        page: query.page,
        limit: query.limit,
        currentUserId: user?.id, // Pass currentUserId
        parentId: query.parentId,
      }
    );

    const paginationMeta = new PaginationMetaDto(
      query.page,
      query.limit,
      count,
      data.length,
    );
    
    return new PaginatedResponseDto(data.map(CommentResponseDto.fromEntity), paginationMeta);
  }

  @HttpPost('posts/:postId/comments')
  @UseGuards(JwtAuthGuard)
  async createForPost(
    @Param('postId', PostPipe) post: PostEntity,
    @Body() dto: CreateCommentDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommentResponseDto>> {
    this.caslService.enforce(user, Action.Create, Comment);
    const comment = await this.commentsService.createComment(
      post.id,
      dto.content,
      user.id,
      dto.parentId,
    );
    return new ResponseDto(CommentResponseDto.fromEntity(comment));
  }

  @Get('comments/:id')
  @UseGuards(OptionalJwtAuthGuard) // Add guard to get user
  async findOne(
    @Param('id') id: number, // Get id directly
    @GetUser() user: User, // Get current user
  ): Promise<ResponseDto<CommentResponseDto>> {
    const comment = await this.commentsService.findOne(id, user?.id); // Call service method
    if (!comment) {
      throw new NotFoundException('Comment not found');
    }
    return new ResponseDto(CommentResponseDto.fromEntity(comment));
  }

  @Patch('comments/:id')
  @UseGuards(JwtAuthGuard)
  async update(
    @Param('id', CommentPipe) comment: Comment,
    @Body() dto: UpdateCommentDto,
    @GetUser() user: User,
  ): Promise<ResponseDto<CommentResponseDto>> {
    this.caslService.enforce(user, Action.Update, comment);
    const updatedComment = await this.commentsService.update(
      {
        id: comment.id,
        content: dto.content,
      }
    );
    return new ResponseDto(CommentResponseDto.fromEntity(updatedComment));
  }

  @Delete('comments/:id')
  @UseGuards(JwtAuthGuard)
  async remove(
    @Param('id', CommentPipe) comment: Comment,
    @GetUser() user: User,
  ): Promise<ResponseDto<boolean>> {
    this.caslService.enforce(user, Action.Delete, comment);
    const success = await this.commentsService.remove(comment.id);
    return new ResponseDto(success);
  }
}


---


### FILE: backend/src/comments/entities/comment.entity.ts ###
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  OneToMany,
} from 'typeorm';
import { Post } from '../../posts/entities/post.entity';
import { User } from '../../users/entities/user.entity';
import { CommentReaction } from '../../reactions/entities/comment-reaction.entity';
import { ReactionType } from 'src/reactions/reactions.types';
import { CommentReport } from '../../reports/entities/comment-report.entity';

@Entity('comments')
export class Comment {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  content: string;

  @ManyToOne(() => Post, (post) => post.comments, { onDelete: 'CASCADE' })
  post: Post;

  @ManyToOne(() => User, (user) => user.comments, {
    nullable: false,
    onDelete: 'CASCADE',
  })
  author: User;
  // FK explicite
  @Column()
  authorId: number;

  @ManyToOne(() => Comment, (comment) => comment.replies, {
    nullable: true,
    onDelete: 'CASCADE',
  })
  parent: Comment;

 @Column({nullable :true})
  parentId: number;

  @OneToMany(() => Comment, (comment) => comment.parent)
  replies: Comment[];

  @OneToMany(() => CommentReaction, (reaction) => reaction.comment)
  reactions: CommentReaction[];

  @Column({ default: 0 })
  likesCount: number;

  @Column({ default: 0 })
  dislikesCount: number;

  @Column({ default: 0 })
  repliesCount: number;

  @OneToMany(() => CommentReport, (commentReport) => commentReport.comment)
  reports: CommentReport[];

  userReaction?: { id: number; type: ReactionType };

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @DeleteDateColumn()
  deletedAt: Date;
}

---


### FILE: backend/src/comments/comments.module.ts ###
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Comment } from './entities/comment.entity';
import { CommentsService } from './comments.service';
import { CommentsController } from './comments.controller';
import { PostsModule } from 'src/posts/posts.module';
import { CaslModule } from 'src/casl/casl.module';
import { CommunitiesModule } from 'src/communities/communities.module';
import { Post } from 'src/posts/entities/post.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([Comment, Post]),
    PostsModule,
    CaslModule,
    CommunitiesModule,
  ],
  providers: [CommentsService],
  controllers: [CommentsController],
  exports: [CommentsService],
})
export class CommentsModule {}

---


### FILE: backend/src/comments/dto/comment-response.dto.ts ###
import { Exclude, Expose, Type, plainToInstance } from 'class-transformer';
import { UserResponseDto } from '../../users/dtos/user-response.dto';
import { Comment } from '../entities/comment.entity';
import { CommentReaction } from 'src/reactions/entities/comment-reaction.entity';
import { ReactionResponseDto } from 'src/reactions/dto/reaction-response.dto';

@Exclude()
export class CommentResponseDto {
  @Expose() readonly id: number;
  @Expose() readonly content: string;
  @Expose() readonly createdAt: Date;
  @Expose() readonly updatedAt: Date;

  @Expose() @Type(() => UserResponseDto) readonly author: UserResponseDto;
  @Expose() readonly postId: number;
  @Expose() readonly parentId?: number;
  @Expose() readonly likesCount: number;
  @Expose() readonly dislikesCount: number;
  @Expose() readonly repliesCount: number;
  @Expose() @Type(() => ReactionResponseDto)
  readonly userReaction?: ReactionResponseDto | null;
  @Expose()
  @Type(() => CommentResponseDto)
  readonly replies?: CommentResponseDto[];

  static fromEntity(entity: Comment & { userReaction?: any }): CommentResponseDto {
    return plainToInstance(
      CommentResponseDto,
      {
        ...entity,
        author: entity.author
          ? UserResponseDto.fromEntity(entity.author)
          : null,
        replies:
          entity.replies?.map((r) => CommentResponseDto.fromEntity(r)) ?? [],
        userReaction: entity.userReaction
          ? ReactionResponseDto.fromEntity(entity.userReaction)
          : null,
      },
      { excludeExtraneousValues: true },
    );
  }
}

---


### FILE: backend/src/comments/dto/comment-query.dto.ts ###
import { PaginationDto } from '../../common/dto/pagination.dto';
import { IsOptional, IsString, IsInt } from 'class-validator';
import { Type } from 'class-transformer';

export class CommentQueryDto extends PaginationDto {
  @IsOptional()
  @IsString()
  search?: string; // Filter by content

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  authorId?: number;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  parentId?: number;
  }

---


### FILE: backend/src/comments/dto/create-comment.dto.ts ###
import { IsNotEmpty, IsInt, IsOptional } from 'class-validator';

export class CreateCommentDto {
  @IsNotEmpty()
  content: string;

  // Add the optional parent ID
  @IsOptional()
  @IsInt()
  parentId?: number;
}

---


### FILE: backend/src/comments/dto/update-comment.dto.ts ###
import { PartialType } from '@nestjs/mapped-types';
import { CreateCommentDto } from './create-comment.dto';

export class UpdateCommentDto extends PartialType(CreateCommentDto) {}

---


--- FRONTEND SOURCE ---


### FILE: frontend/src/pages/Home.tsx ###
import { useAppSelector } from '../shared/stores/hooks';

const Home = () => {
  const { user } = useAppSelector((state) => state.auth);
  return (
    <div>
      <h1>Welcome to the forum, {user?.name}!</h1>
    </div>
  );
};

export default Home;
---


### FILE: frontend/src/layout/Header.tsx ###
import { Link } from 'react-router-dom';
import { useState } from 'react';
import { useAuth } from '../features/auth/hooks/useAuth';
import LogoutButton from '../features/auth/components/LogoutButton';
import { FaHome, FaSignInAlt, FaUserPlus, FaSignOutAlt, FaBell, FaPlus, FaCaretDown, FaUserCircle } from 'react-icons/fa'; // Import icons

const Header = () => {
  const { isAuthenticated, user } = useAuth();
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);

  const toggleDropdown = () => {
    setIsDropdownOpen(!isDropdownOpen);
  };

  return (
    <header className=" p-4 border-b border-gray-300">
      <nav className="container mx-auto flex justify-between items-center">
        <Link to="/" className="text-2xl font-bold flex items-center space-x-2">
          <FaHome className="inline-block" /> <span>Forum</span>
        </Link>
        <div className="flex items-center space-x-4">
          {isAuthenticated ? (
            <>
              {/* Create Post Button */}
              <Link to="/submit" className="flex items-center space-x-1 hover:text-gray-300">
                <FaPlus /> <span>Create Post</span>
              </Link>

              {/* Notification Bell */}
              <button className="relative hover:text-gray-300">
                <FaBell className="text-xl" />
                {/* Optional: Notification Badge */}
                {/* <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-4 w-4 flex items-center justify-center">3</span> */}
              </button>

              {/* User Profile Dropdown */}
              <div className="relative">
                <button onClick={toggleDropdown} className="flex items-center space-x-2 hover:text-gray-300 focus:outline-none">
                  {user?.profilePictureUrl ? (
                    <img
                      src={user.profilePictureUrl}
                      alt="Profile"
                      className="w-8 h-8 rounded-full object-cover"
                    />
                  ) : (
                    <FaUserCircle className="text-3xl" />
                  )}
                  <FaCaretDown />
                </button>
                {isDropdownOpen && (
                  <div className="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-700 rounded-md shadow-lg py-1 text-gray-800 dark:text-gray-200 z-10">
                    <Link to="/profile" className="block px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-600">
                      Profile ({user?.name})
                    </Link>
                    <Link to="/settings" className="block px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-600">
                      Settings
                    </Link>
                    <div className="border-t border-gray-200 dark:border-gray-600 my-1"></div>
                    <LogoutButton className="block w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-gray-100 dark:hover:bg-gray-600" />
                  </div>
                )}
              </div>
            </>
          ) : (
            <>
              <li>
                <Link to="/login" className="flex items-center space-x-1 hover:text-gray-300">
                  <FaSignInAlt /> <span>Login</span>
                </Link>
              </li>
              <li>
                <Link to="/register" className="flex items-center space-x-1 hover:text-gray-300">
                  <FaUserPlus /> <span>Register</span>
                </Link>
              </li>
            </>
          )}
        </div>
      </nav>
    </header>
  );
};

export default Header;

---


### FILE: frontend/src/layout/ModSidebar.tsx ###
// frontend/src/features/communities/components/ModSidebar.tsx
import { NavLink, useParams } from 'react-router-dom';
import { FaShieldAlt, FaUsers, FaTasks, FaUserShield } from 'react-icons/fa';

export const ModSidebar = () => {
  const { communityId } = useParams<{ communityId: string }>();
  const basePath = `/mod/community/${communityId}`;

  const navItems = [
    { label: 'Queues', path: `${basePath}/queues`, icon: <FaTasks /> },
    { label: 'Members', path: `${basePath}/members`, icon: <FaUsers /> },
    { label: 'Moderators', path: `${basePath}/moderators`, icon: <FaUserShield /> },
  ];

  return (
    <aside className="w-64 bg-gray-50 h-screen border-r border-gray-200 p-4">
      <div className="flex items-center gap-2 mb-6 px-2 text-gray-700 font-bold">
        <FaShieldAlt className="text-orange-600" />
        <span>Mod Tools</span>
      </div>
      <nav className="space-y-1">
        {navItems.map((item) => (
          <NavLink
            key={item.path}
            to={item.path}
            className={({ isActive }) =>
              `flex items-center gap-3 px-3 py-2 rounded-md transition-colors ${
                isActive ? 'bg-orange-100 text-orange-700' : 'hover:bg-gray-100 text-gray-600'
              }`
            }
          >
            {item.icon}
            {item.label}
          </NavLink>
        ))}
      </nav>
    </aside>
  );
};
---


### FILE: frontend/src/layout/LeftSidebar.tsx ###
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { FaHome, FaCompass, FaUsers, FaPlusSquare, FaRocket } from 'react-icons/fa'; // Example icons
import {Modal} from '../shared/components/ui/Modal'; // Assuming this path
import CreateCommunityForm from '../features/communities/components/CreateCommunityForm';

const LeftSidebar: React.FC = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleOpenModal = (event: React.MouseEvent) => {
    event.preventDefault(); // Prevent navigation
    setIsModalOpen(true);
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
  };

  return (
    <aside className="w-64 bg-white p-4 border-r border-gray-300 h-screen sticky top-0 hidden md:block">
      <nav className="space-y-4">
        <div>
          <h2 className="text-lg font-semibold text-gray-800 mb-2">Navigation</h2>
          <ul className="space-y-1">
            <li>
              <Link to="/" className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaHome /> <span>Home</span>
              </Link>
            </li>
            <li>
              <Link to="/discover" className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaCompass /> <span>Discover</span>
              </Link>
            </li>
            <li>
              <Link to="/explore-communities" className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaUsers /> <span>Explore Communities</span>
              </Link>
            </li>
            <li>
              <Link to="/my-communities" className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaUsers /> <span>My Communities</span>
              </Link>
            </li>
          </ul>
        </div>
        <div>
          <h2 className="text-lg font-semibold text-gray-800 mb-2">Actions</h2>
          <ul className="space-y-1">
            <li>
              <Link to="/submit" className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaPlusSquare /> <span>Create Post</span>
              </Link>
            </li>
            <li>
              <a href="#" onClick={handleOpenModal} className="flex items-center space-x-2 p-2 rounded-md hover:bg-gray-100 text-gray-700">
                <FaRocket /> <span>Start Community</span>
              </a>
            </li>
          </ul>
        </div>
      </nav>

      <Modal open={isModalOpen} size='lg' onClose={handleCloseModal} >
        <CreateCommunityForm onClose={handleCloseModal} />
      </Modal>
    </aside>
  
);
};

export default LeftSidebar;

---


### FILE: frontend/src/layout/ModLayout.tsx ###
// frontend/src/features/communities/layouts/ModLayout.tsx
import { Outlet } from 'react-router-dom';
import { ModSidebar } from './ModSidebar';
import Header from './Header';

const ModLayout = () => (
  <>
    <Header />
    <div className="flex min-h-screen bg-white">
      <ModSidebar />
      <main className="flex-1 p-8">
        <Outlet />
      </main>
    </div>
  </>
);
export default ModLayout;
---


### FILE: frontend/src/layout/MainLayout.tsx ###
// frontend/src/layout/MainLayout.tsx
import { Outlet } from 'react-router-dom';
import Header from './Header';
import LeftSidebar from './LeftSidebar';

const MainLayout = () => (
  <>
    <Header />
    <div className="flex">
      <LeftSidebar />
      <main className="flex-grow p-4">
        <Outlet /> 
      </main>
    </div>
  </>
);
export default MainLayout;
---


### FILE: frontend/src/features/community-memberships/types.ts ###
export interface CommunityMembership {
    userId: number;
    communityId: number;
    role: CommunityRole; // Add this
    // user: UserResponseDto; // Assuming UserResponseDto exists
    // community: CommunityResponseDto; // Assuming CommunityResponseDto exists
    createdAt: string;
  }
  
  export interface CommunityMembershipQueryDto {
    userId?: number;
    communityId?: number;
    page?: number;
    limit?: number;
  }export type CommunityRole = 'admin' | 'moderator' | 'member'| 'owner';
---


### FILE: frontend/src/features/community-memberships/services/communityMembershipsApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { CommunityMembership, CommunityMembershipQueryDto } from '../types';
import type { PaginatedResponse, ResponseDto } from '../../../shared/types';

export const communityMembershipsApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    getCommunityMemberships: builder.query<
      PaginatedResponse<CommunityMembership>,
      CommunityMembershipQueryDto
    >({
      query: (params) => ({
        url: '/community-memberships',
        params,
      }),
      providesTags: ['CommunityMemberships'],
    }),
    deleteMembership: builder.mutation<
      ResponseDto<boolean>,
      number // communityId
    >({
      query: (communityId) => ({
        url: `/users/me/communities/${communityId}/memberships`,
        method: 'DELETE',
      }),
      invalidatesTags: ['CommunityMemberships', 'Communities'], // Invalidate communities to update subscriber count
    }),
  }),
});

export const {
  useGetCommunityMembershipsQuery,
  useDeleteMembershipMutation,
} = communityMembershipsApi;

---


### FILE: frontend/src/features/feed/pages/FeedPage.tsx ###
// features/feed/pages/FeedPage.tsx
import React, { useEffect, useRef, useCallback, useState } from 'react';
import { useGetPostsInfiniteQuery } from '../../posts/services/postsApi';
import PostList from '../../posts/components/PostList';
import { useToastContext } from '../../../shared/providers/ToastProvider';
import type { PostQueryDto } from '../../posts/types';
import FeedFilters from '../components/FeedFilters';
import SuggestedCommunities from '../../communities/components/SuggestedCommunities';

const FeedPage = () => {
  const [queryParams, setQueryParams] = useState<Omit<PostQueryDto, 'page'>>({
    limit: 10,
  });

  const {
    data,
    error,
    isLoading,
    isFetching,
    fetchNextPage,
    hasNextPage,
  } = useGetPostsInfiniteQuery(queryParams);

  
  const posts = data?.pages.flatMap((page) => page.data) ?? [];
  console.log(posts);

  const { showToast } = useToastContext();
  const observer = useRef<IntersectionObserver | null>(null);

  // Show error toast
  useEffect(() => {
    if (error) {
      showToast('Failed to load posts', 'error');
    }
  }, [error, showToast]);

  // Infinite scroll observer
  const lastPostElementRef = useCallback(
    (node: HTMLDivElement) => {
      if (isLoading || isFetching || !hasNextPage) return;

      if (observer.current) observer.current.disconnect();

      observer.current = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting && hasNextPage) {
          fetchNextPage();
        }
      });

      if (node) observer.current.observe(node);
    },
    [isLoading, isFetching, hasNextPage, fetchNextPage]
  );

  return (
    <div className="container mx-auto p-4 flex flex-col md:flex-row gap-6">
      {/* Main Content Area */}
      <div className="md:w-3/4">
        <h1 className="text-3xl font-bold mb-6">Feed</h1>

        <FeedFilters
          queryParams={queryParams}
          setQueryParams={setQueryParams}
          isLoading={isLoading}
        />

        <PostList posts={posts} isLoading={isLoading} error={undefined} />

        {/* Loading indicator */}
        {isFetching && (
          <div className="text-center mt-4">
            <div className="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
            <p className="mt-2 text-gray-600">Loading more posts...</p>
          </div>
        )}

        {/* End of feed */}
        {!hasNextPage && posts.length > 0 && (
          <div className="text-center mt-8 p-4 border-t">
            <p className="text-gray-600">üéâ You've reached the end!</p>
            <p className="text-sm text-gray-500 mt-1">No more posts to load</p>
          </div>
        )}

        {/* Empty state */}
        {!isLoading && posts.length === 0 && (
          <div className="text-center p-8">
            <div className="text-4xl mb-4">üì≠</div>
            <h3 className="text-xl font-semibold mb-2">No posts yet</h3>
            <p className="text-gray-600">Be the first to create a post!</p>
          </div>
        )}

        {/* Invisible element for intersection observer */}
        {hasNextPage && <div ref={lastPostElementRef} className="h-1" />}
      </div>

      {/* Sidebar */}
      <div className="md:w-1/4">
        <SuggestedCommunities />
      </div>
    </div>
  );
};

export default FeedPage;

---


### FILE: frontend/src/features/feed/components/FeedFilters.tsx ###
import React from 'react';
import { Button } from '../../../shared/components/ui/Button';
import { Input } from '../../../shared/components/ui/Input';
import type { PostQueryDto } from '../../posts/types';
import { FaSearch, FaSortAmountDownAlt, FaFire } from 'react-icons/fa';

interface FeedFiltersProps {
  queryParams: PostQueryDto;
  setQueryParams: React.Dispatch<React.SetStateAction<PostQueryDto>>;
  isLoading: boolean;
}


const FeedFilters: React.FC<FeedFiltersProps> = ({ queryParams, setQueryParams, isLoading }) => {
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setQueryParams((prev) => ({ ...prev, search: e.target.value, page: 1 }));
  };
console.log(queryParams);

  const handleSortChange = (sortOption: string) => {
    setQueryParams((prev) => ({ ...prev, sort: sortOption, page: 1 }));
  };

  return (
    <div className="flex flex-col sm:flex-row justify-between items-center bg-white p-4 rounded-lg border border-gray-300 mb-6">
      <div className="relative flex-grow mb-3 sm:mb-0 sm:mr-4">
        <FaSearch className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" />
        <Input
          placeholder="Search posts..."
          className="pl-10 w-full"
          onChange={handleSearchChange}
          value={queryParams.search || ''}
        />
      </div>
      <div className="flex space-x-2">
        <Button
          variant={queryParams.sort === 'newest' ? 'default' : 'outline'}
          onClick={() => handleSortChange('newest')}
          disabled={isLoading}
          className="flex items-center space-x-1"
        >
          <FaSortAmountDownAlt /> <span>Newest</span>
        </Button>
        <Button
          variant={queryParams.sort === 'popular' ? 'default' : 'outline'}
          onClick={() => handleSortChange('popular')}
          disabled={isLoading}
          className="flex items-center space-x-1"
        >
          <FaFire /> <span>Popular</span>
        </Button>
      </div>
    </div>
  );
};

export default FeedFilters;

---


### FILE: frontend/src/features/community-membership-requests/types.ts ###
export interface CommunityMembershipRequest {
    id: number;
    userId: number;
    communityId: number;
    status: 'pending' | 'accepted' | 'rejected';
    createdAt: string;
    updatedAt: string;
  }
  
---


### FILE: frontend/src/features/community-membership-requests/services/communityMembershipRequestsApi.ts ###
import { apiSlice } from "../../../shared/services/apiSlice";
import type { ResponseDto } from "../../auth/types";
import type { CommunityMembershipRequest } from "../types";

export const communityMembershipRequestsApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    // Create a join request (or auto-join if public)
    createMembershipRequest: builder.mutation<
      ResponseDto<CommunityMembershipRequest>,
      number // communityId
    >({
      query: (communityId) => ({
        url: `/communities/${communityId}/membership-requests`,
        method: 'POST',
      }),
      invalidatesTags: ['CommunityMembershipRequests', 'Communities', 'CommunityMemberships'],
    }),

    // Accept a pending request (admin/mod action, keep requestId for now)
    acceptMembershipRequest: builder.mutation<
      ResponseDto<CommunityMembershipRequest>,
      number // requestId
    >({
      query: (requestId) => ({
        url: `/communities/membership-requests/${requestId}/accept`,
        method: 'POST',
      }),
      invalidatesTags: ['CommunityMembershipRequests', 'Communities', 'CommunityMemberships'],
    }),

    // Cancel (reject) your own pending request ‚Äî user-centric, no requestId
    cancelMembershipRequest: builder.mutation<
      ResponseDto<boolean>,
      number // communityId
    >({
      query: (communityId) => ({
        url: `/communities/${communityId}/membership-requests/own`,
        method: 'DELETE',
      }),
      invalidatesTags: ['CommunityMembershipRequests', 'Communities', 'CommunityMemberships'],
    }),

    // 2Ô∏è‚É£ Reject any pending membership request (admin/mod)
    rejectMembershipRequest: builder.mutation<
      ResponseDto<boolean>,
      { communityId: number; userId: number } // target user
    >({
      query: ({ communityId, userId }) => ({
        url: `/communities/${communityId}/membership-requests`,
        method: 'DELETE',
        body: { userId }, // pass target userId in body
      }),
      invalidatesTags: ['CommunityMembershipRequests', 'Communities', 'CommunityMemberships'],
    }),

    // Get all pending requests for a community (admin/mod)
    getCommunityMembershipRequests: builder.query<
      ResponseDto<CommunityMembershipRequest[]>,
      number // communityId
    >({
      query: (communityId) => `/communities/${communityId}/membership-requests`,
      providesTags: ['CommunityMembershipRequests'],
    }),
  }),
});

export const {
  useCreateMembershipRequestMutation,
  useAcceptMembershipRequestMutation,
  useRejectMembershipRequestMutation,
  useCancelMembershipRequestMutation ,
  useGetCommunityMembershipRequestsQuery,
} = communityMembershipRequestsApi;

---


### FILE: frontend/src/features/reactions/components/ReactionButton.tsx ###
import React from 'react';
import { Button } from '../../../shared/components/ui/Button';
import { FaRegThumbsDown, FaRegThumbsUp, FaThumbsDown, FaThumbsUp } from 'react-icons/fa';

interface ReactionButtonProps {

    onClick: () => void;
    count?: number; // optional count
    disabled?: boolean;
    type: 'like' | 'dislike';
    userReaction?: 'like' | 'dislike' | null;
}

export const ReactionButton: React.FC<ReactionButtonProps> = ({
    onClick,
    count = 0,
    disabled = false,
    type,
    userReaction,
}) => {
  const isActive = userReaction === type;
    const ariaLabel = userReaction === 'like' ? 'Remove like' : 'Like'

    return (
        <Button
            onClick={onClick}
            disabled={disabled}
            size='sm'
            variant='secondary'

            aria-label={ariaLabel ?? type}
        >
                 {type === 'like' ? (
        isActive ? <FaThumbsUp /> : <FaRegThumbsUp />
      ) : isActive ? (
        <FaThumbsDown />
      ) : (
        <FaRegThumbsDown />
      )}
            
            {count > 0 && <span className="text-sm ms-2 font-medium">{count}</span>}
        </Button>
    );
};

---


### FILE: frontend/src/features/reactions/components/CommentReactionButtons.tsx ###
import { ReactionButtons } from './ReactionButtons';
import { useCreateCommentReactionMutation, useDeleteCommentReactionMutation, useUpdateCommentReactionMutation } from '../services/reactionApi';
import type { Comment } from '../../comments/types'; // Import Comment type
import { ReactionType } from '../types/types';

interface CommentReactionButtonsProps {
    comment: Comment; // contains id, userReaction, likesCount, dislikesCount
}

export const CommentReactionButtons: React.FC<CommentReactionButtonsProps> = ({ comment }) => {
    const [createReaction] = useCreateCommentReactionMutation();
    const [deleteReaction] = useDeleteCommentReactionMutation();
    const [updateReaction] = useUpdateCommentReactionMutation();

    const handleLike = async () => {
        if (comment.userReaction?.type === ReactionType.LIKE) {
            await deleteReaction({ commentId: comment.id, reactionId: comment.userReaction.id! });
        } else if (comment.userReaction?.type === ReactionType.DISLIKE) {
            await updateReaction({ commentId: comment.id, reactionId: comment.userReaction.id!, data: { type: ReactionType.LIKE } });
        }
        else {
            await createReaction({ commentId: comment.id, data: { type: ReactionType.LIKE } });
        }
    };

    const handleDislike = async () => {
        if (comment.userReaction?.type === ReactionType.DISLIKE) {
            await deleteReaction({ commentId: comment.id, reactionId: comment.userReaction.id! });
        } else if (comment.userReaction?.type === ReactionType.LIKE) {
            await updateReaction({ commentId: comment.id, reactionId: comment.userReaction.id!, data: { type: ReactionType.DISLIKE } });
        }
        else {
            await createReaction({ commentId: comment.id, data: { type: ReactionType.DISLIKE } });
        }
    };

    return (
        <ReactionButtons
            likesCount={comment.likesCount}
            dislikesCount={comment.dislikesCount}
            userReaction={comment.userReaction?.type}
            onLike={handleLike}
            onDislike={handleDislike}
            disabled={false} // you can set loading state if needed
        />
    );
};

---


### FILE: frontend/src/features/reactions/components/ReactionButtons.tsx ###
import React from 'react';
import { FaThumbsUp, FaThumbsDown } from 'react-icons/fa';
import { ReactionButton } from './ReactionButton';
import type { ReactionType } from '../types/types';

interface ReactionButtonsProps {
    likesCount: number;
    dislikesCount: number;
    userReaction: ReactionType | null | undefined;
    onLike: () => void;
    onDislike: () => void;
    disabled?: boolean;
    className?: string;
}

export const ReactionButtons: React.FC<ReactionButtonsProps> = ({
    likesCount,
    dislikesCount,
    userReaction,
    onLike,
    onDislike,
    disabled = false,
    className = '',
}) => (
    <div className={`flex items-center space-x-3 ${className}`}>
        <ReactionButton
            count={likesCount}
            onClick={onLike}
            disabled={disabled}
            type="like"
            userReaction={userReaction}
        />

        <ReactionButton
            count={dislikesCount}
            onClick={onDislike}
            disabled={disabled}
            type="dislike"
            userReaction={userReaction}
        />
    </div>
);

---


### FILE: frontend/src/features/reactions/components/PostReactionButtons.tsx ###
import { ReactionButtons } from './ReactionButtons';
import { useCreatePostReactionMutation, useDeletePostReactionMutation, useUpdatePostReactionMutation } from '../services/reactionApi';
import type { Post } from '../../posts/types';
import { ReactionType } from '../types/types';

interface PostReactionButtonsProps {
    post: Post; // contains id, userReaction, likesCount, dislikesCount
}

export const PostReactionButtons: React.FC<PostReactionButtonsProps> = ({ post }) => {
    const [createReaction] = useCreatePostReactionMutation();
    const [deleteReaction] = useDeletePostReactionMutation();
    const [updateReaction] = useUpdatePostReactionMutation();

    const handleLike = async () => {
        if (post.userReaction?.type === ReactionType.LIKE) {
            await deleteReaction({ postId: post.id, reactionId: post.userReaction.id! });
        } else if (post.userReaction?.type === ReactionType.DISLIKE) {
            await updateReaction({ postId: post.id, reactionId: post.userReaction.id!, data: { type: ReactionType.LIKE } });
        }
        else {
            await createReaction({ postId: post.id, data: { type: ReactionType.LIKE } });
        }
    };

    const handleDislike = async () => {
        if (post.userReaction?.type === ReactionType.DISLIKE) {
            await deleteReaction({ postId: post.id, reactionId: post.userReaction.id! });
        } else if (post.userReaction?.type === ReactionType.LIKE) {
            await updateReaction({ postId: post.id, reactionId: post.userReaction.id!, data: { type: ReactionType.DISLIKE } });
        }
        else {
            await createReaction({ postId: post.id, data: { type: ReactionType.DISLIKE } });
        }
    };

    return (
        <ReactionButtons
            likesCount={post.likesCount}
            dislikesCount={post.dislikesCount}
            userReaction={post.userReaction?.type}
            onLike={handleLike}
            onDislike={handleDislike}
            disabled={false} // you can set loading state if needed
        />
    );
};

---


### FILE: frontend/src/features/reactions/services/reactionApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type {
  PostReaction,
  CommentReaction,
  CreateReactionDto,
  UpdateReactionDto,
  ReactionQueryDto,
  PaginatedResponse,
  ResponseDto
} from '../types/types';

export const reactionApi = apiSlice.injectEndpoints({
  overrideExisting: false, // Ensure this is not overriding existing endpoints
  endpoints: (builder) => ({
    getPostReactions: builder.query<PaginatedResponse<PostReaction>, { postId: number } & ReactionQueryDto>({
      query: ({ postId, ...params }) => ({ url: `/posts/${postId}/reactions`, params }),
      providesTags: (_result, _error, { postId }) => [{ type: 'PostReaction', id: postId }],
    }),

    getCommentReactions: builder.query<PaginatedResponse<CommentReaction>, { commentId: number } & ReactionQueryDto>({
      query: ({ commentId, ...params }) => ({ url: `/comments/${commentId}/reactions`, params }),
      providesTags: (_result, _error, { commentId }) => [{ type: 'CommentReaction', id: commentId }],
    }),

    createPostReaction: builder.mutation<ResponseDto<PostReaction>, { postId: number; data: CreateReactionDto }>({
      query: ({ postId, data }) => ({ url: `/posts/${postId}/reactions`, method: 'POST', body: data }),
      invalidatesTags: ['Posts']
    }),

    updatePostReaction: builder.mutation<ResponseDto<PostReaction>, { postId: number; reactionId: number; data: UpdateReactionDto }>({
      query: ({ postId, reactionId, data }) => ({ url: `/posts/${postId}/reactions/${reactionId}`, method: 'PATCH', body: data }),
            invalidatesTags: ['Posts']

    }),

    deletePostReaction: builder.mutation<ResponseDto<boolean>, { postId: number; reactionId: number }>({
      query: ({ postId, reactionId }) => ({ url: `/posts/${postId}/reactions/${reactionId}`, method: 'DELETE' }),
          invalidatesTags: ['Posts']

    }),

    createCommentReaction: builder.mutation<ResponseDto<CommentReaction>, { commentId: number; data: CreateReactionDto }>({
      query: ({ commentId, data }) => ({ url: `/comments/${commentId}/reactions`, method: 'POST', body: data }),
      invalidatesTags: ['Comments'],
    }),

    updateCommentReaction: builder.mutation<ResponseDto<CommentReaction>, { commentId: number; reactionId: number; data: UpdateReactionDto }>({
      query: ({ commentId, reactionId, data }) => ({ url: `/comments/${commentId}/reactions/${reactionId}`, method: 'PATCH', body: data }),
      invalidatesTags: ['Comments'],
    }),

    deleteCommentReaction: builder.mutation<ResponseDto<boolean>, { commentId: number; reactionId: number }>({
      query: ({ commentId, reactionId }) => ({ url: `/comments/${commentId}/reactions/${reactionId}`, method: 'DELETE' }),
      invalidatesTags: ['Comments'],
    }),
  }),
});

export const {
  useGetPostReactionsQuery,
  useGetCommentReactionsQuery,
  useCreatePostReactionMutation,
  useUpdatePostReactionMutation,
  useCreateCommentReactionMutation,
  useUpdateCommentReactionMutation,
  useDeletePostReactionMutation,
  useDeleteCommentReactionMutation,
} = reactionApi;

---


### FILE: frontend/src/features/reactions/types/types.ts ###
export const ReactionType = {
  LIKE: 'like',
  DISLIKE: 'dislike',
} as const;

export type ReactionType = typeof ReactionType[keyof typeof ReactionType];

export interface Reaction {
    id: number;
    type: ReactionType;
    userId: number;
    createdAt: string;
    updatedAt: string;
}

export interface PostReaction extends Reaction {
    postId: number;
    user: {
        id: number;
        name: string;
    };
}

export interface CommentReaction extends Reaction {
    commentId: number;
    user: {
        id: number;
        name: string;
    };
}

export interface CreateReactionDto {
    type: ReactionType;
}

export interface UpdateReactionDto {
    type: ReactionType;
}


export interface ReactionQueryDto {
    page?: number;
    limit?: number;
    type?: ReactionType;
    userId?: number;
}

export interface PaginatedResponse<T> {
    data: T[];
    meta: {
        page: number;
        limit: number;
        totalItems: number;
        totalPages: number;
        itemCount: number;
    };
}

export interface ResponseDto<T> {
    data: T;
    message: string;
}

---


### FILE: frontend/src/features/posts/types.ts ###
import type { ReactionType } from "../reactions/types/types";

export interface Post {
  id: number;
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
  };
  community?: {
    id: number;
    name: string;
  };
  views: number;
  likesCount: number;
  dislikesCount: number;
  commentsCount: number; // Added commentsCount
  userReaction?: { id: number; type: ReactionType };
    userSaved?: any;

  createdAt: string;
  updatedAt: string;
}

export interface CreatePostDto {
  title: string;
  content: string;
  communityId?: number;
}

export interface UpdatePostDto {
  title?: string;
  content?: string;
}

export interface PostQueryDto {
  page?: number;
  limit?: number;
  search?: string;
  authorId?: number;
  sort?: string;
  startDate?: string;
  endDate?: string;
  communityId?: number;
}

---


### FILE: frontend/src/features/posts/pages/CreatePostPage.tsx ###
import React from 'react';
import CreatePostForm from '../components/CreatePostForm';

const CreatePostPage: React.FC = () => {
  return (
    <div>
      <h1 className="text-2xl font-bold mb-4">Create Post</h1>
      <CreatePostForm />
    </div>
  );
};

export default CreatePostPage;

---


### FILE: frontend/src/features/posts/pages/PostDetailPage.tsx ###
import { useParams, Link } from 'react-router-dom';
import { useGetPostByIdQuery } from '../services/postsApi';
import { useToastContext } from '../../../shared/providers/ToastProvider';
import {
  FaArrowUp,
  FaArrowDown,
  FaCommentAlt,
  FaShareAlt,
  FaBookmark,
  FaUser,
  FaUsers,
  FaEye,
} from 'react-icons/fa';
import CommentList from '../../comments/components/CommentList'; // Import CommentList
import { AboutCommunity } from '../../communities/components/AboutCommunity';
import { PostReactionButtons } from '../../reactions/components/PostReactionButtons';
import { PostSuggestionsList } from '../components/PostSuggestionsList';
import PostDetailCard from '../components/PostDetailCard'; // Import PostDetailCard

const PostDetailPage = () => {
  const { id } = useParams<{ id: string }>();
  const postId = Number(id);
  const { data, error, isLoading } = useGetPostByIdQuery(postId);
  const { showToast } = useToastContext();

 
  if (isLoading) {
    return <div className="text-center mt-8">Loading post...</div>;
  }

  if (error) {
    const errorMessage =
      (error as any).data?.message || (error as any).message || 'Failed to load post';
    showToast(errorMessage, 'error');
    return <div className="text-center mt-8 text-red-500">{errorMessage}</div>;
  }

  if (!data?.data) {
    return <div className="text-center mt-8">Post not found.</div>;
  }

  const post = data.data;

  console.log(post);
  
  return (
    <div className="container mx-auto p-4 flex flex-col md:flex-row gap-6">
            {/* Main Content Area */}
            <div className="md:w-[70%]">
              <PostDetailCard post={post} />
              {/* Comments Section */}
              <CommentList postId={postId} />
            </div>

      {/* Sidebar Area (Right) */}
      <div className="md:w-[30%]">
        <PostSuggestionsList currentPostId={postId} communityId={post.community?.id} />
        {post.community && (
          <div className="mt-4">
            <AboutCommunity communityId={post.community.id} />
          </div>
        )}
      </div>
    </div>
  );
};

export default PostDetailPage;

---


### FILE: frontend/src/features/posts/components/PostDetailCard.tsx ###
import React from 'react';
import type { Post } from '../types';
import { Link } from 'react-router-dom';
import { FaUser, FaUsers, FaEye } from 'react-icons/fa';
import { PostReactionButtons } from '../../reactions/components/PostReactionButtons';
import PostActionButtons from './PostCardFooter'; // Assuming it's in the same directory
import { timeAgo } from '../../../shared/utils/date'; // Import timeAgo from shared utils

const PostDetailCard: React.FC<PostDetailCardProps> = ({ post }) => {
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg  p-6 mb-6 border border-gray-300">
      {/* Post Metadata */}
      <div className="flex items-center text-sm text-gray-500 dark:text-gray-400 mb-3 space-x-1">
        {post.community && (
          <>
            <FaUsers className="mr-1" />
            <Link
              to={`/communities/${post.community.id}`}
              className="font-semibold hover:underline mr-1"
            >
              c/{post.community.name}
            </Link>
            <span className="mx-1">‚Ä¢</span>
          </>
        )}
        <FaUser className="mr-1" />
        <span>u/{post.author.name}</span>
        <span className="mx-1">‚Ä¢</span>
        <span className='text-xs'>{timeAgo(post.createdAt)}</span>
      </div>

      {/* Post Title */}
      <h1 className="text-2xl font-bold text-gray-900 dark:text-gray-100 leading-tight mb-4">
        {post.title}
      </h1>

      {/* Post Content */}
      <p className="text-gray-700 dark:text-gray-300 text-base mb-6">
        {post.content}
      </p>

      {/* Actions */}
      <div className="flex items-center justify-between border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
        <div className="flex items-center space-x-4">
          <PostReactionButtons post={post} />
          <PostActionButtons post={post} />
        </div>

        {/* Views */}
        <div className="flex items-center space-x-1 text-sm text-gray-500 dark:text-gray-400">
          <FaEye />
          <span>{post.views} Views</span>
        </div>
      </div>
    </div>
  );
};

export default PostDetailCard;

---


### FILE: frontend/src/features/posts/components/PostSuggestionCard.tsx ###
import React from 'react';
import { Link } from 'react-router-dom';
import type { Post } from '../types';

interface PostSuggestionCardProps {
  post: Post;
}

export const PostSuggestionCard: React.FC<PostSuggestionCardProps> = ({ post }) => {
  return (
    <div className="bg-gray-50 rounded-lg p-3 hover:bg-gray-100 transition-colors duration-200">
      <Link to={`/posts/${post.id}`} className="text-md font-semibold text-gray-800 hover:text-primary-600">
        {post.title}
      </Link>
      {post.community && (
        <p className="text-sm text-gray-500 mt-1">
          in <Link to={`/communities/${post.community.name}`} className="hover:underline">r/{post.community.name}</Link>
        </p>
      )}
      <p className="text-xs text-gray-400 mt-1">
        {post.views} views ‚Ä¢ {post.commentsCount} comments
      </p>
    </div>
  );
};

---


### FILE: frontend/src/features/posts/components/CreatePostForm.tsx ###
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useNavigate } from 'react-router-dom';

import SearchableSelect from '../../../shared/components/ui/SearchableSelect';
import { useGetCommunitiesQuery } from '../../communities/services/communitiesApi';
import { useCreatePostMutation } from '../services/postsApi';
import type { Community } from '../../communities/types';
import { Textarea } from '../../../shared/components/ui/TextArea';
import { Input } from '../../../shared/components/ui/Input';
import { Label } from '../../../shared/components/ui/Label';
import { InputError } from '../../../shared/components/ui/InputError';
import { Button } from '../../../shared/components/ui/Button';

/* -------------------------------------------------------------------------- */
/*                                   Schema                                   */
/* -------------------------------------------------------------------------- */

const createPostSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  content: z.string().min(1, 'Content is required'),
  communityId: z.number().min(1, 'Community is required'),
});

type CreatePostFormValues = z.infer<typeof createPostSchema>;

/* -------------------------------------------------------------------------- */
/*                               Component                                    */
/* -------------------------------------------------------------------------- */

const CreatePostForm: React.FC = () => {
  const navigate = useNavigate();
  const [createPost, { isLoading }] = useCreatePostMutation();

  const {
    register,
    handleSubmit,
    setValue,
    formState: { errors },
  } = useForm<CreatePostFormValues>({
    resolver: zodResolver(createPostSchema),
  });

  /* --------------------------- Search State -------------------------------- */

  const [search, setSearch] = useState('');

  const { data, isFetching } = useGetCommunitiesQuery(
    { name: search },
    { skip: search.trim().length === 0 }
  );

  const communities = data?.data ?? [];

  /* ---------------------------- Submit ------------------------------------- */

  const onSubmit = async (values: CreatePostFormValues) => {
    try {
      await createPost(values).unwrap();
      navigate('/');
    } catch (err) {
      console.error('Create post failed', err);
    }
  };

  /* -------------------------------------------------------------------------- */

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      {/* Title */}
      <div>
        <Label className="block text-sm font-medium">Title</Label>
        <Input
          {...register('title')}
        />
        <InputError message={errors.title?.message} />
      </div>

      {/* Content */}
      <div>
        <Label className="block text-sm font-medium">Content</Label>
        <Textarea
          {...register('content')}
          rows={5}
        />
        <InputError message={errors.content?.message} />
      </div>

      {/* Community */}
      <div>
        <Label className="block text-sm font-medium">Community</Label>

        <SearchableSelect
          value={search}
          onSearch={setSearch}
          options={communities}
          loading={isFetching}
          getLabel={(c) => c.displayName}
          renderOption={(c) => <span>{c.displayName}</span>}
          onSelect={(c) => setValue('communityId', c.id)}
          placeholder="Search community..."
        />

        <InputError message={errors.communityId?.message} />
      </div>

      {/* Submit */}
      <Button
        type="submit"
        disabled={isLoading}
      >
        {isLoading ? 'Creating‚Ä¶' : 'Create Post'}
      </Button>
    </form>
  );
};

export default CreatePostForm;

---


### FILE: frontend/src/features/posts/components/PostList.tsx ###
import React from 'react';
import PostCard from './PostCard';
import type { Post } from '../types';

interface PostListProps {
  posts: Post[];
  isLoading: boolean;
  error: any; // Ideally, a more specific error type
}

const PostList: React.FC<PostListProps> = ({ posts, isLoading, error }) => {
  if (isLoading) {
    return <div className="text-center mt-8">Loading posts...</div>;
  }

  if (error) {
    // Error handling will be done in the parent FeedPage
    return <div className="text-center mt-8 text-red-500">Error loading posts.</div>;
  }

  return (
    <div className="p-0"> {/* Adjusted padding as FeedPage provides container padding */}
      {posts.length === 0 ? (
        <p className="text-center text-gray-600 mt-8">No posts found.</p>
      ) : (
        <div className="grid gap-6 grid-cols-1"> {/* Changed to single column */}
          {posts.map((post) => (
            <PostCard key={post.id} post={post} />
          ))}
        </div>
      )}
    </div>
  );
};

export default PostList;

---


### FILE: frontend/src/features/posts/components/PostCardDropdown.tsx ###
import React from 'react';
import type { Post } from '../types';
import {
  FaEdit,
  FaTrashAlt,
  FaRegBookmark,
  FaBookmark,
} from 'react-icons/fa';
import { BsThreeDots } from 'react-icons/bs';
import Dropdown from '../../../shared/components/ui/Dropdown';
import { Button } from '../../../shared/components/ui/Button';
import { useAuth } from '../../auth/hooks/useAuth';
import { useDeletePostMutation } from '../services/postsApi';

interface PostDropdownProps {
  post: Post;
}

const PostDropdown: React.FC<PostDropdownProps> = ({ post }) => {
 
 const {user}=useAuth()
const [deletePost, { isLoading }] = useDeletePostMutation();

  const handleEditPost = () => {
    console.log('Edit post:', post.id);
    // TODO: Implement edit functionality
  };

  const  handleDeletePost = async () => {
    console.log('Delete post:', post.id);
    try {
    await deletePost(post.id).unwrap();
    console.log('Post deleted:', post.id);
  } catch (error) {
    console.error('Failed to delete post', error);
  }
  };

  const handleToggleSave = () => {
    console.log(post.userSaved ? 'Unsave post:' : 'Save post:', post.id);
    // TODO: Implement save/unsave functionality
  };

  return (
    <div className="absolute top-2 right-2">
      <Dropdown
        trigger={
          <Button variant="ghost" size="sm" className="p-2">
            <BsThreeDots className="text-lg text-gray-500 dark:text-gray-400" />
          </Button>
        }
        align="right"
      >
        <div className="py-1">
         {user?.id === post.author.id && (
  <>
    <button
      onClick={handleEditPost}
      className="flex items-center w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600"
    >
      <FaEdit className="mr-2" />
      Edit
    </button>

    <button
      onClick={handleDeletePost}
      className="flex items-center w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-gray-100 dark:hover:bg-gray-600"
    >
      <FaTrashAlt className="mr-2" />
      Delete
    </button>
  </>
)}

          <button
            onClick={handleToggleSave}
            className="flex items-center w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600"
          >
            {post.userSaved ? (
              <>
                <FaBookmark className="mr-2" /> Unsave
              </>
            ) : (
              <>
                <FaRegBookmark className="mr-2" /> Save
              </>
            )}
          </button>
        </div>
      </Dropdown>
    </div>
  );
};

export default PostDropdown;

---


### FILE: frontend/src/features/posts/components/PostCardFooter.tsx ###
import React from 'react';
import type { Post } from '../types';
import { Button } from '../../../shared/components/ui/Button';
import {
  FaRegCommentAlt,
  FaCommentAlt,
  FaRegBookmark,
  FaBookmark,
  FaEye,
} from 'react-icons/fa';
import { FiShare2 } from 'react-icons/fi';
import { PostReactionButtons } from '../../reactions/components/PostReactionButtons';

interface PostCardFooterProps {
  post: Post;
}

 const PostCardFooter: React.FC<PostCardFooterProps> = ({ post }) => {
  // Placeholder for actual action handlers
  const handleCommentClick = () => {
    console.log('Comment clicked for post:', post.id);
    // TODO: Implement navigation to post detail page comments or open comment modal
  };

  const handleShareClick = () => {
    console.log('Share clicked for post:', post.id);
    // TODO: Implement share functionality
  };



  return (
    <div className="flex items-center justify-between mt-3  dark:text-gray-400 text-sm md:text-base">

      <div className="flex items-center space-x-3 md:space-x-4">

        {/* Vote Buttons */}
        <PostReactionButtons post={post} />


        {/* Comment Button */}
        <Button variant="secondary" size="sm" className="space-x-2" onClick={handleCommentClick}>
          <FaRegCommentAlt />
          <span>{post.commentsCount || 0}</span>
        </Button>

        {/* Share Button */}
        <Button variant="secondary" size="sm" className="space-x-2" onClick={handleShareClick}>
          <FiShare2 />
          <span>Share</span>
        </Button>
       

      </div>
       {/* Views */}
        <div className="flex items-center space-x-1">
          <FaEye />
          <span>{post.views}</span>
        </div>
    </div>
  );
};

export default PostCardFooter;

---


### FILE: frontend/src/features/posts/components/PostSuggestionsList.tsx ###
import React from 'react';
import { useGetPostsInfiniteQuery } from '../services/postsApi';
import { PostSuggestionCard } from './PostSuggestionCard';

interface PostSuggestionsListProps {
  currentPostId: number;
  communityId?: number; // Optional: to suggest posts from the same community
}

export const PostSuggestionsList: React.FC<PostSuggestionsListProps> = ({ currentPostId, communityId }) => {
  const { data, error, isLoading } = useGetPostsInfiniteQuery({
    communityId: communityId,
    limit: 5, // Fetch 5 suggestions
  });

  // Flatten the pages array to get all posts
  const allPosts = data?.pages.flatMap((page) => page.data) || [];

  // Filter out the current post from suggestions
  const suggestions = allPosts.filter(post => post.id !== currentPostId);

  if (isLoading) {
    return <p>Loading suggestions...</p>;
  }

  if (error) {
    return <p>Error loading suggestions.</p>;
  }

  if (suggestions.length === 0) {
    return <p>No suggestions found.</p>;
  }

  return (
    <div className="bg-white p-4 rounded-lg border border-gray-300">
      <h2 className="text-xl font-bold mb-4">More Posts Like This</h2>
      <div className="flex flex-col gap-3">
        {suggestions.map((post) => (
          <PostSuggestionCard key={post.id} post={post} />
        ))}
      </div>
    </div>
  );
};


---


### FILE: frontend/src/features/posts/components/PostCard.tsx ###
import React from 'react';
import type { Post } from '../types';
import { Link } from 'react-router-dom';
import {
  FaEye,
  FaUser,
  FaUsers,
  FaRegCommentAlt,
} from 'react-icons/fa';
import { timeAgo } from '../../../shared/utils/date'; // Import timeAgo from shared utils
import PostDropdown from './PostCardDropdown'; // Import PostDropdown component
import PostCardFooter from './PostCardFooter';

interface PostCardProps {
  post: Post;
}

const PostCard: React.FC<PostCardProps> = ({ post }) => {
 

  return (
    <div className="relative bg-white dark:bg-gray-800 rounded-lg s border border-gray-300 hover:shadow-lg transition-shadow duration-200 mb-6 p-5">
      {/* Three dots dropdown */}
      <PostDropdown post={post} />

      {/* Post Metadata */}
      <div className="flex items-center text-xs md:text-sm text-gray-500 dark:text-gray-400 mb-2 space-x-1">
        {post.community && (
          <>
            <FaUsers className="mr-1" />
            <Link
              to={`/communities/${post.community.id}`}
              className="font-semibold hover:underline mr-1"
            >
              c/{post.community.name}
            </Link>
            <span className="mx-1">‚Ä¢</span>
          </>
        )}
        <FaUser className="mr-1" />
        <span>u/{post.author.name}</span>
        <span className="mx-1">‚Ä¢</span>
        <span className="text-xs">{timeAgo(post.createdAt)}</span>
      </div>

      {/* Post Title */}
      <Link to={`/posts/${post.id}`}>
        <h2 className="text-lg  font-bold text-gray-900 dark:text-gray-100 hover:text-primary-600 leading-tight mb-2 line-clamp-2">
          {post.title}
        </h2>
      </Link>

      {/* Post Content */}
      <p className="text-gray-700 dark:text-gray-300 text-sm  line-clamp-3 mb-4">
        {post.content}
      </p>

      {/* Actions */}
   <PostCardFooter post={post}/>
    </div>
  );
};

export default PostCard;

---


### FILE: frontend/src/features/posts/services/postsApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { Post, CreatePostDto, UpdatePostDto, PostQueryDto } from '../types';
import type { PaginatedResponse, ResponseDto } from '../../../shared/types';

export const postsApi = apiSlice.injectEndpoints({
    endpoints: (builder) => ({
        
      getPosts: builder.infiniteQuery<
  PaginatedResponse<Post>,
  PostQueryDto,
  number
>({
  infiniteQueryOptions: {
    initialPageParam: 1,
    getNextPageParam: (lastPage) => {
      const { page, totalPages } = lastPage.meta;
      return page < totalPages ? page + 1 : undefined;
    },
  },

  query: ({ queryArg, pageParam }) => ({
    url: '/posts',
    params: {
      ...(queryArg ?? {}),
      page: pageParam,
      limit: queryArg?.limit ?? 10,
    },
  }),

  keepUnusedDataFor: 60,
  providesTags: ['Posts'],
}),
        getPostById: builder.query<ResponseDto<Post>, number>({
            query: (id) => `/posts/${id}`,
            providesTags: (result, error, id) => [{ type: 'Posts', id }],
        }),
        createPost: builder.mutation<ResponseDto<Post>, CreatePostDto>({
            query: (newPost) => ({
                url: '/posts',
                method: 'POST',
                body: newPost,
            }),
            invalidatesTags: ['Posts'],
        }),
        updatePost: builder.mutation<ResponseDto<Post>, { id: number; data: UpdatePostDto }>({
            query: ({ id, data }) => ({
                url: `/posts/${id}`,
                method: 'PATCH',
                body: data,
            }),
            invalidatesTags: (result, error, { id }) => [{ type: 'Posts', id }],
        }),
        deletePost: builder.mutation<ResponseDto<boolean>, number>({
            query: (id) => ({
                url: `/posts/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: ['Posts'],
        }),
    }),
});

export const {
    
      useGetPostsInfiniteQuery,
    useGetPostByIdQuery,
    useCreatePostMutation,
    useUpdatePostMutation,
    useDeletePostMutation,
} = postsApi;

---


### FILE: frontend/src/features/auth/types.ts ###
export interface RegisterDto {
    name: string;
    email: string;
    password: string;
  }
  
  export interface LoginDto {
    email: string;
    password: string;
  }

  export interface UserResponseDto {
    id: string;
    name: string;
    email: string;
  }

  export interface ResponseDto<T> {
    data: T;
    message: string;
  }
  
---


### FILE: frontend/src/features/auth/pages/Register.tsx ###
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useRegisterMutation } from '../services/authApi';
import type { RegisterDto } from '../types';
import { Button } from '../../../shared/components/ui/Button';
import { Input } from '../../../shared/components/ui/Input';
import { Label } from '../../../shared/components/ui/Label';
import { InputError } from '../../../shared/components/ui/InputError';
import { useNavigate } from 'react-router-dom';

const registerSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters long'),
});

const Register = () => {
  const [register, { isLoading, error }] = useRegisterMutation();
  const navigate = useNavigate();
  const {
    register: formRegister,
    handleSubmit,
    formState: { errors },
  } = useForm<RegisterDto>({
    resolver: zodResolver(registerSchema),
  });

  const onSubmit = async (data: RegisterDto) => {
    try {
      await register(data).unwrap();
      navigate('/email-verification', { state: { email: data.email } });
    } catch (err: any) {
      console.error('Failed to register: ', err);
    }
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-md">
        <h1 className="text-2xl font-bold text-center">Register</h1>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
          <div>
            <Label htmlFor="name">Name</Label>
            <Input id="name" {...formRegister('name')} />
            <InputError message={errors.name?.message} />
          </div>
          <div>
            <Label htmlFor="email">Email</Label>
            <Input id="email" {...formRegister('email')} />
            <InputError message={errors.email?.message} />
          </div>
          <div>
            <Label htmlFor="password">Password</Label>
            <Input id="password" type="password" {...formRegister('password')} />
            <InputError message={errors.password?.message} />
          </div>
          <Button type="submit" disabled={isLoading} className="w-full">
            {isLoading ? 'Registering...' : 'Register'}
          </Button>
          {error && (
            <InputError
              message={
                (error as any).data?.message || (error as any).message || 'Unknown error'
              }
            />
          )}
        </form>
      </div>
    </div>
  );
};

export default Register;

---


### FILE: frontend/src/features/auth/pages/Login.tsx ###
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useLoginMutation } from '../services/authApi';
import type { LoginDto } from '../types';
import { useNavigate } from 'react-router-dom';
import GoogleLogin from '../components/GoogleLogin';
import { Button } from '../../../shared/components/ui/Button';
import { Input } from '../../../shared/components/ui/Input';
import { Label } from '../../../shared/components/ui/Label';
import { InputError } from '../../../shared/components/ui/InputError';

const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
});

const Login = () => {
  const [login, { isLoading, error }] = useLoginMutation();
  const navigate = useNavigate();
  const {
    register: formRegister,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginDto>({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = async (data: LoginDto) => {
    try {
      await login(data).unwrap();
      navigate('/');
    } catch (err: any) {
      console.error('Failed to login: ', err);
    }
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-lg border border-gray-300">
        <h1 className="text-2xl font-bold text-center">Login</h1>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
          <div>
            <Label htmlFor="email">Email</Label>
            <Input id="email" {...formRegister('email')} />
            <InputError message={errors.email?.message} />
          </div>
          <div>
            <Label htmlFor="password">Password</Label>
            <Input id="password" type="password" {...formRegister('password')} />
            <InputError message={errors.password?.message} />
          </div>
          <Button type="submit" disabled={isLoading} className="w-full">
            {isLoading ? 'Logging in...' : 'Login'}
          </Button>
          {error && (
            <InputError
              message={
                (error as any).data?.message || (error as any).message || 'Unknown error'
              }
            />
          )}
        </form>
        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300"></div>
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">Or</span>
          </div>
        </div>
        <GoogleLogin />
      </div>
    </div>
  );
};

export default Login;

---


### FILE: frontend/src/features/auth/pages/VerificationResult.tsx ###
import React, { useEffect } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { useToastContext } from '../../../shared/providers/ToastProvider';

const VerificationResult = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { showToast } = useToastContext();

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const success = params.get('success');
    const error = params.get('error');
    const message =params.get('message') ?? ''
    if (success) {
      showToast(message, 'success');
    } else if (error) {
      showToast(message, 'error');
    }

    navigate('/login');
  }, [location, navigate, showToast]);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-md">
        <h1 className="text-2xl font-bold text-center">Verifying your email...</h1>
      </div>
    </div>
  );
};

export default VerificationResult;

---


### FILE: frontend/src/features/auth/pages/EmailVerification.tsx ###
import React, { useState } from 'react';
import { useLocation } from 'react-router-dom';
import { useResendEmailVerificationMutation } from '../services/authApi';
import { Button } from '../../../shared/components/ui/Button';
import { useToastContext } from '../../../shared/providers/ToastProvider';

const EmailVerification = () => {
  const location = useLocation();
  const email = location.state?.email;
  const [resendEmail, { isLoading }] = useResendEmailVerificationMutation();
  const { showToast } = useToastContext();

  const handleResendEmail = async () => {
    try {
      await resendEmail({ email }).unwrap();
      showToast('Verification email sent successfully!', 'success');
    } catch (err: any) {
      const errorMessage = err.data?.message || err.message || 'Unknown error';
      showToast(errorMessage, 'error');
      console.error('Failed to resend verification email: ', err);
    }
  };

  if (!email) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen">
        <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-md">
          <h1 className="text-2xl font-bold text-center">Invalid Page</h1>
          <p className="text-center">
            No email address was provided. Please register first.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-md">
        <h1 className="text-2xl font-bold text-center">Email Sent Successfully</h1>
        <p className="text-center">
          A verification email has been sent to <strong>{email}</strong>.
          Please check your inbox and click the verification link to activate your account.
        </p>
        <div className="text-center">
          <p>Didn't receive the email?</p>
          <Button
            variant="link"
            onClick={handleResendEmail}
            disabled={isLoading}
          >
            {isLoading ? 'Sending...' : 'Resend email'}
          </Button>
        </div>
      </div>
    </div>
  );
};

export default EmailVerification;

---


### FILE: frontend/src/features/auth/components/GoogleLogin.tsx ###
import { Button } from '../../../shared/components/ui/Button';

const GoogleLogin = () => {
  const googleLogin = () => {
    window.location.href = 'http://localhost:3000/api/auth/google';
  };

  return (
    <Button onClick={googleLogin} className="w-full">
      Login with Google
    </Button>
  );
};

export default GoogleLogin;

---


### FILE: frontend/src/features/auth/components/LogoutButton.tsx ###
import { useAppDispatch } from '../../../shared/stores/hooks';
import { logout } from '../stores/authSlice';
import { FaSignOutAlt } from 'react-icons/fa';
import { Button } from '../../../shared/components/ui/Button'; // Assuming you have a Button component

interface LogoutButtonProps {
  className?: string; // Add className prop
}

const LogoutButton: React.FC<LogoutButtonProps> = ({ className }) => {
  const dispatch = useAppDispatch();

  const handleLogout = () => {
    dispatch(logout());
  };

  return (
    <Button onClick={handleLogout} variant="ghost" className={`flex items-center space-x-1 ${className}`}>
      <FaSignOutAlt /> <span>Logout</span>
    </Button>
  );
};

export default LogoutButton;

---


### FILE: frontend/src/features/auth/components/AuthGard.tsx ###
import { useSelector } from 'react-redux';
import { Navigate, useLocation } from 'react-router-dom';
import type { RootState } from '../../../shared/stores/store';
import type { JSX } from 'react';

const AuthGuard = ({ children }: { children: JSX.Element }) => {
  const { accessToken } = useSelector((state: RootState) => state.auth);
  const location = useLocation();

  if (!accessToken) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
};

export default AuthGuard;

---


### FILE: frontend/src/features/auth/stores/authSlice.ts ###
import { createSlice } from '@reduxjs/toolkit';
import type { UserResponseDto } from '../types';
import { authApi } from '../services/authApi';

interface AuthState {
  user: UserResponseDto | null;
  accessToken: string | null;
  refreshToken: string | null;
}

const initialState: AuthState = {
  user: null,
  accessToken: null,
  refreshToken: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null;
      state.accessToken = null;
      state.refreshToken = null;
    },
  },
  extraReducers: (builder) => {
    builder.addMatcher(
      authApi.endpoints.login.matchFulfilled,
      (state, action) => {
        state.user = action.payload.data.user;
        state.accessToken = action.payload.data.accessToken;
        state.refreshToken = action.payload.data.refreshToken;
      }
    );
  },
});

export const { logout } = authSlice.actions;

export default authSlice.reducer;

---


### FILE: frontend/src/features/auth/services/authApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { LoginDto, RegisterDto, UserResponseDto, ResponseDto } from '../types';

export const authApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    register: builder.mutation<ResponseDto<UserResponseDto>, RegisterDto>({
      query: (credentials) => ({
        url: 'auth/register',
        method: 'POST',
        body: credentials,
      }),
    }),
    login: builder.mutation<ResponseDto<{ user: UserResponseDto, accessToken: string, refreshToken: string }>, LoginDto>({
      query: (credentials) => ({
        url: 'auth/login',
        method: 'POST',
        body: credentials,
      }),
    }),
    refresh: builder.mutation<ResponseDto<{ user: UserResponseDto, accessToken: string, refreshToken: string }>, { refreshToken: string }>({
        query: ({refreshToken}) => ({
            url: 'auth/refresh',
            method: 'POST',
            body: {refreshToken}
        })
    }),
    resendEmailVerification: builder.mutation<ResponseDto<null>, { email: string }>({
      query: ({ email }) => ({
        url: 'email-verification/resend',
        method: 'POST',
        body: { email },
      }),
    }),
  }),
});
export const { useRegisterMutation, useLoginMutation, useRefreshMutation, useResendEmailVerificationMutation } = authApi;

---


### FILE: frontend/src/features/auth/hooks/useAuth.ts ###
import { useSelector } from 'react-redux';
import type { RootState } from '../../../store'; // Adjust path to your root reducer if necessary

export const useAuth = () => {
  const user = useSelector((state: RootState) => state.auth.user);
  const accessToken = useSelector((state: RootState) => state.auth.accessToken);
  const refreshToken = useSelector((state: RootState) => state.auth.refreshToken);

  return {
    user,
    accessToken,
    refreshToken,
    isAuthenticated: !!user && !!accessToken,
  };
};

---


### FILE: frontend/src/features/communities/types.ts ###
export interface Community {
  communityType: CommunityType;
  id: number;
  name: string;
  displayName: string;
  description: string;
  membersCount: number;
  createdAt: string;
  userMembershipStatus?: 'member' | 'pending' | 'none';
}

export interface CreateCommunityDto {
  name: string;
  displayName?: string;
  description?: string;
}

export interface UpdateCommunityDto extends Partial<CreateCommunityDto> {}

export interface CommunityQueryDto {
  name?: string;
  displayName?: string;
  page?: number;
  limit?: number;
}

export type CommunityType = 'public' | 'restricted' | 'private';

---


### FILE: frontend/src/features/communities/pages/MembersPage.tsx ###
// frontend/src/features/communities/pages/mod/ModMembersPage.tsx
import { useParams } from 'react-router-dom';
import { useGetCommunityMembershipsQuery } from '../../community-memberships/services/communityMembershipsApi';

export const ModMembersPage = () => {
  const { communityId } = useParams();
  const { data: response, isLoading } = useGetCommunityMembershipsQuery({ communityId: Number(communityId) });

  if (isLoading) return <div className="p-4 text-center">Loading members...</div>;

  return (
    <div className="max-w-4xl mx-auto">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-2xl font-bold text-gray-800">Community Members</h2>
        <span className="bg-gray-100 px-3 py-1 rounded-full text-sm text-gray-600 font-medium font-bold">
          Total: {response?.data.length || 0}
        </span>
      </div>
      <div className="bg-white border border-gray-200 rounded-xl overflow-hidden shadow-sm">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">User</th>
              <th className="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Role</th>
              <th className="px-6 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Joined At</th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {response?.data.map((membership) => (
              <tr key={membership.userId}>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">User #{membership.userId}</td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                    membership.role === 'admin' ? 'bg-red-100 text-red-800' : 
                    membership.role === 'moderator' ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'
                  }`}>
                    {membership.role}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 font-mono">
                  {new Date(membership.createdAt).toLocaleDateString()}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};
---


### FILE: frontend/src/features/communities/pages/ModeratorsPage.tsx ###
// frontend/src/features/communities/pages/mod/ModModeratorsPage.tsx
import { useParams } from 'react-router-dom';
import { useGetCommunityMembershipsQuery } from '../../community-memberships/services/communityMembershipsApi';
import { FaUserShield } from 'react-icons/fa';

export const ModModeratorsPage = () => {
  const { communityId } = useParams();
  const { data: response, isLoading } = useGetCommunityMembershipsQuery({ communityId: Number(communityId) });

  const moderators = response?.data.filter(m => m.role === 'admin' || m.role === 'moderator');

  if (isLoading) return <div className="p-4">Loading moderation team...</div>;

  return (
    <div className="max-w-4xl mx-auto">
      <h2 className="text-2xl font-bold mb-6 flex items-center gap-2 text-gray-800 border-b pb-2">
        <FaUserShield className="text-orange-600" />
        Moderation Team
      </h2>
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
        {moderators?.map((mod) => (
          <div key={mod.userId} className="flex items-center p-4 bg-white border border-gray-200 rounded-lg shadow-sm hover:shadow-md transition-shadow">
            <div className={`w-14 h-14 rounded-full flex items-center justify-center mr-4 font-black ${
              mod.role === 'admin' ? 'bg-red-100 text-red-600' : 'bg-orange-100 text-orange-600'
            }`}>
              {mod.role[0].toUpperCase()}
            </div>
            <div>
              <p className="font-bold text-gray-900 text-lg">User #{mod.userId}</p>
              <p className="text-xs font-black text-gray-500 uppercase tracking-widest">{mod.role}</p>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};
---


### FILE: frontend/src/features/communities/pages/MyCommunitiesPage.tsx ###
import React from 'react';
import { useGetCommunityMembershipsQuery } from '../../community-memberships/services/communityMembershipsApi';
import CommunityCard from '../components/CommunityCard'; // Assuming a CommunityCard component exists
import type { CommunityMembership } from '../../community-memberships/types';
import type { Community } from '../types';
import { useAuth } from '../../auth/hooks/useAuth';

const MyCommunitiesPage: React.FC = () => {
  const { user } = useAuth(); // Get current user from auth context/hook

  const { data, isLoading, isError, error } = useGetCommunityMembershipsQuery(
    {
      userId: user?.id,
      limit: 100, // Fetch a reasonable number of memberships
    },
    { skip: !user?.id } // Skip query if user ID is not available
  );

  if (isLoading) {
    return <div className="text-center mt-8">Loading your communities...</div>;
  }

  if (isError) {
    console.error("Error loading my communities:", error);
    return <div className="text-center mt-8 text-red-500">Error loading your communities.</div>;
  }

  const memberships: CommunityMembership[] = data?.data || [];
  const myCommunities: Community[] = memberships.map(sub => sub.community).filter(Boolean) as Community[];

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-3xl font-bold mb-6">My Communities</h1>

      {myCommunities.length === 0 ? (
        <div className="text-center p-8 bg-white rounded-lg shadow-md">
          <p className="text-gray-600 text-lg mb-4">You haven't joined any communities yet.</p>
          <p className="text-gray-500">Explore communities to find ones that interest you!</p>
          {/* TODO: Add a link to the Explore Communities page here */}
        </div>
      ) : (
        <div className="grid gap-6 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
          {myCommunities.map((community) => (
            <CommunityCard key={community.id} community={community} />
          ))}
        </div>
      )}
    </div>
  );
};

export default MyCommunitiesPage;

---


### FILE: frontend/src/features/communities/pages/CommunityPage.tsx ###
import React from 'react';
import { useParams } from 'react-router-dom';
import { CommunityHeader } from '../components/CommunityHeader';
import PostList from '../../posts/components/PostList';
import { useGetPostsInfiniteQuery } from '../../posts/services/postsApi';

export const CommunityPage = () => {
  const { communityId } = useParams<{ communityId: string }>();
  const communityIdNumber = +(communityId || 0);

  const {
    data: postsData,
    error: postsError,
    isLoading: postsLoading,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useGetPostsInfiniteQuery({ communityId: communityIdNumber });

  const posts = postsData?.pages.flatMap((page) => page.data) || [];

  return (
    <>
    <div className="mb-8">
            <CommunityHeader communityId={communityIdNumber}  />

    </div>

      <PostList posts={posts} isLoading={postsLoading} error={postsError} />
    </>
  );
};


---


### FILE: frontend/src/features/communities/pages/QueuesPage.tsx ###
// frontend/src/features/communities/pages/mod/ModQueuesPage.tsx
import { useParams } from 'react-router-dom';
import { 
  
  
  useAcceptMembershipRequestMutation,
  useGetCommunityMembershipRequestsQuery,
  useRejectMembershipRequestMutation
} from '../../community-membership-requests/services/communityMembershipRequestsApi';
import { Button } from '../../../shared/components/ui/Button';

export const ModQueuesPage = () => {
  const { communityId } = useParams();
  const { data: requests, isLoading } = useGetCommunityMembershipRequestsQuery(Number(communityId));
  const [approve] = useAcceptMembershipRequestMutation();
  const [reject] = useRejectMembershipRequestMutation();

  if (isLoading) return <div className="p-4">Loading queue...</div>;

  return (
    <div className="max-w-4xl mx-auto">
      <h2 className="text-2xl font-bold mb-6">Moderation Queue: Join Requests</h2>
      {requests?.data.length === 0 ? (
        <div className="text-center py-10 bg-gray-50 rounded-lg border">
          <p className="text-gray-500 italic">No pending requests to review.</p>
        </div>
      ) : (
        <div className="space-y-3">
          {requests?.data.map((req) => (
            <div key={req.id} className="flex justify-between items-center p-4 bg-white rounded-lg border border-gray-200">
              <div>
                <span className="font-medium text-gray-900 text-lg">User #{req.userId}</span>
                <p className="text-xs text-gray-500 italic">Requested on {new Date(req.createdAt).toLocaleDateString()}</p>
              </div>
              <div className="flex gap-2">
                <Button size="sm" onClick={() => approve(req.userId)} className="bg-green-600 hover:bg-green-700">Approve</Button>
                <Button size="sm" variant="outline" onClick={() => reject({userId:req.userId ,communityId:req.communityId})} className="text-red-600 border-red-600 hover:bg-red-50">Reject</Button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
---


### FILE: frontend/src/features/communities/pages/ExploreCommunitiesPage.tsx ###
import React, { useState } from 'react';
import { useGetCommunitiesQuery } from '../services/communitiesApi';
import CommunityCard from '../components/CommunityCard';
import type { CommunityQueryDto } from '../types';

const ExploreCommunitiesPage: React.FC = () => {
  const [queryParams, setQueryParams] = useState<CommunityQueryDto>({
    limit: 10,
    page: 1,
  });
  const [searchTerm, setSearchTerm] = useState('');

  const { data, isLoading, isError, error } = useGetCommunitiesQuery(queryParams);

  const communities = data?.data || [];
  const meta = data?.meta;

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchTerm(e.target.value);
  };

  const handleSearchSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setQueryParams((prev) => ({ ...prev, name: searchTerm, page: 1 }));
  };

  const handleLoadMore = () => {
    if (meta?.hasNextPage) {
      setQueryParams((prev) => ({ ...prev, page: (prev.page || 1) + 1 }));
    }
  };

  if (isLoading && queryParams.page === 1) {
    return <div className="text-center mt-8">Loading communities...</div>;
  }

  if (isError) {
    console.error("Error loading communities:", error);
    return <div className="text-center mt-8 text-red-500">Error loading communities.</div>;
  }

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-3xl font-bold mb-6">Explore Communities</h1>

      <form onSubmit={handleSearchSubmit} className="mb-6 flex space-x-2">
        <input
          type="text"
          placeholder="Search communities by name..."
          value={searchTerm}
          onChange={handleSearchChange}
          className="flex-grow p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500"
        />
        <button
          type="submit"
          className="bg-primary-600 text-white px-4 py-2 rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500"
        >
          Search
        </button>
      </form>

      {communities.length === 0 ? (
        <div className="text-center p-8 bg-white rounded-lg shadow-md">
          <p className="text-gray-600 text-lg mb-4">No communities found matching your criteria.</p>
        </div>
      ) : (
        <div className="grid gap-6 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
          {communities.map((community) => (
            <CommunityCard key={community.id} community={community} />
          ))}
        </div>
      )}

      {meta?.hasNextPage && (
        <div className="text-center mt-6">
          <button
            onClick={handleLoadMore}
            disabled={isLoading}
            className="bg-gray-200 text-gray-800 px-4 py-2 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400"
          >
            {isLoading ? 'Loading more...' : 'Load More'}
          </button>
        </div>
      )}
    </div>
  );
};

export default ExploreCommunitiesPage;

---


### FILE: frontend/src/features/communities/components/SuggestedCommunities.tsx ###
import React from 'react';
import { useGetCommunitiesQuery } from '../services/communitiesApi';
import { Link } from 'react-router-dom';

const SuggestedCommunities = () => {
  const { data, isLoading, isError } = useGetCommunitiesQuery({ sort: 'popular', limit: 5 });

  if (isLoading) {
    return (
      <div className="bg-white rounded-lg shadow-md p-4">
        <h2 className="text-xl font-semibold mb-4">Suggested Communities</h2>
        <div className="animate-pulse space-y-3">
          <div className="h-4 bg-gray-200 rounded w-3/4"></div>
          <div className="h-4 bg-gray-200 rounded"></div>
          <div className="h-4 bg-gray-200 rounded w-5/6"></div>
        </div>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="bg-white rounded-lg shadow-md p-4 text-red-600">
        <h2 className="text-xl font-semibold mb-4">Suggested Communities</h2>
        <p>Error loading suggested communities.</p>
      </div>
    );
  }

  const communities = data?.data || [];

  if (communities.length === 0) {
    return null; // Or a message like "No suggestions"
  }

  return (
    <div className="bg-white rounded-lg border border-gray-300 p-4">
      <h2 className="text-xl font-semibold mb-4">Suggested Communities</h2>
      <ul>
        {communities.map((community) => (
          <li key={community.id} className="mb-2 last:mb-0">
            <Link to={`/communities/${community.id}`} className="text-primary-600 hover:underline">
              {community.displayName || community.name}
            </Link>
            <p className="text-sm text-gray-500">{community.membersCount} subscribers</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default SuggestedCommunities;

---


### FILE: frontend/src/features/communities/components/CommunityCard.tsx ###
import React from 'react';
import type { Community } from '../types';
import { Link } from 'react-router-dom';
import { FaUsers } from 'react-icons/fa';

interface CommunityCardProps {
  community: Community;
}

const CommunityCard: React.FC<CommunityCardProps> = ({ community }) => {
  return (
    <div className="bg-white dark:bg-gray-800 rounded-xl border border-gray-300 p-4 flex flex-col justify-between border border-gray-300 hover:shadow-lg transition-shadow duration-200">
      <div>
        <Link to={`/communities/${community.id}`}>
          <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100 hover:text-primary-600 mb-2">
            c/{community.name}
          </h3>
        </Link>
        <p className="text-gray-600 dark:text-gray-300 text-sm line-clamp-3 mb-3">
          {community.description || 'No description provided.'}
        </p>
      </div>
      <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
        <FaUsers className="mr-1" />
        <span>{community.membersCount || 0} subscribers</span>
      </div>
    </div>
  );
};

export default CommunityCard;

---


### FILE: frontend/src/features/communities/components/AboutCommunity.tsx ###
import React from 'react';
import { useSelector } from 'react-redux';
import type { RootState } from '../../../shared/stores/store';
import { useGetCommunityByIdQuery } from '../services/communitiesApi';
import { Link } from 'react-router-dom';
import { CommunityMembershipActionButton } from './CommunityMembershipActionButton';

interface AboutCommunityProps {
  communityId: number;
}

export const AboutCommunity: React.FC<AboutCommunityProps> = ({ communityId }) => {
  const currentUser = useSelector((state: RootState) => state.auth.user);
  const { data: communityData, error: communityError, isLoading: communityLoading } = useGetCommunityByIdQuery(communityId);


  if (communityLoading) {
    return <div className="p-4 bg-white rounded-lg shadow">Loading community info...</div>;
  }

  if (communityError || !communityData?.data) {
    return <div className="p-4 bg-white rounded-lg shadow text-red-500">Community not found</div>;
  }

  const community = communityData.data;

  return (
    <div className="bg-white rounded-lg border border-gray-300 p-4">
      <h2 className="text-lg font-semibold mb-2">
        About <Link to={`/communities/${community.id}`} className="text-primary-600 hover:underline">r/{community.name}</Link></h2>
      {community.description && <p className="text-sm text-gray-700 mb-3">{community.description}</p>}
      <div className="flex justify-between items-center text-sm text-gray-600 mb-3">
        <span>Members: {community.membersCount.toLocaleString()}</span>
        <span>Created: {new Date(community.createdAt).toLocaleDateString()}</span>
      </div>
      <CommunityMembershipActionButton community={community} currentUser={currentUser} />
    </div>
  );
};

---


### FILE: frontend/src/features/communities/components/CommunityHeader.tsx ###
import React from 'react';
import { useSelector } from 'react-redux';
import type { RootState } from '../../../shared/stores/store';
import { useGetCommunityByIdQuery } from '../services/communitiesApi';
import { CommunityMembershipActionButton } from './CommunityMembershipActionButton';
import { FaShieldAlt } from 'react-icons/fa';
import  { Link } from 'react-router-dom';
import  { Button } from '../../../shared/components/ui/Button';
import { useGetCommunityMembershipsQuery } from '../../community-memberships/services/communityMembershipsApi';
import { useAuth } from '../../auth/hooks/useAuth';

interface CommunityHeaderProps {
  communityId: number;
}

export const CommunityHeader: React.FC<CommunityHeaderProps> = ({ communityId }) => {
  const currentUser = useSelector((state: RootState) => state.auth.user);
  const { data, error, isLoading } = useGetCommunityByIdQuery(communityId);
const { user } = useAuth();

const { data: membershipData } = useGetCommunityMembershipsQuery({
    communityId,
    userId: user?.id,
  }, { skip: !user?.id });

  console.log(membershipData);
  
  const membership = membershipData?.data?.[0];
  const isMod = membership?.role === 'admin' || membership?.role === 'moderator'|| membership?.role === 'owner';
  if (isLoading) {
    return <div className="h-40 animate-pulse rounded-lg bg-gray-200" />;
  }

  if (error || !data?.data) {
    return <div className="text-sm text-red-500">Community not found</div>;
  }

  const community = data.data;
  console.log(community);
  

  return (
    <div className="overflow-hidden rounded-lg border border-gray-300 bg-white">
      {/* Banner */}
      <div className="h-28 bg-gradient-to-r from-indigo-500 to-purple-600" />

      {/* Content */}
      <div className="relative px-4 pb-4">
        {/* Avatar */}
        <div className="absolute -top-10 flex h-20 w-20 items-center justify-center rounded-full border-4 border-white bg-gray-100 text-2xl font-bold text-gray-600">
          {community.displayName?.charAt(0).toUpperCase()}
        </div>

        <div className="ml-24 flex items-start justify-between pt-2">
          <div>
            <h1 className="text-xl font-semibold leading-tight">
              {community.displayName}
            </h1>
            <p className="text-sm text-gray-500">r/{community.name} ({community.communityType})</p>
          </div>
{/* Mod Tools Button: Only visible to Mods/Admins */}
        {isMod && (
          <Link to={`/mod/community/${communityId}`}>
            <Button variant="outline" className="flex items-center gap-2">
              <FaShieldAlt className="text-orange-600" />
              Mod Tools
            </Button>
          </Link>
        )}
          <CommunityMembershipActionButton community={community} currentUser={currentUser} />
        </div>

        {/* Description */}
        {community.description && (
          <p className="mt-3 text-sm text-gray-700">
            {community.description}
          </p>
        )}

        {/* Stats */}
        <div className="mt-3 flex gap-4 text-sm text-gray-600">
          <span>
            <strong className="text-gray-900">
              {community.membersCount.toLocaleString()}
            </strong>{' '}
            members
          </span>
          <span>Online</span>
        </div>
      </div>
    </div>
  );
};

---


### FILE: frontend/src/features/communities/components/CommunityMembershipActionButton.tsx ###
import React from 'react';
import { Button } from '../../../shared/components/ui/Button';
import {
  useCancelMembershipRequestMutation,
  useCreateMembershipRequestMutation,
  useRejectMembershipRequestMutation,
} from '../../community-membership-requests/services/communityMembershipRequestsApi';
import { useDeleteMembershipMutation } from '../../community-memberships/services/communityMembershipsApi';
import type { Community } from '../types';
import type { UserResponseDto } from '../../auth/types';

interface CommunityMembershipActionButtonProps {
  community: Community;
  currentUser: UserResponseDto | null;
}

export const CommunityMembershipActionButton: React.FC<
  CommunityMembershipActionButtonProps
> = ({ community, currentUser }) => {
  const [createMembershipRequest, { isLoading: isCreatingRequest }] =
    useCreateMembershipRequestMutation();
  const [deleteMembership, { isLoading: isDeletingMembership }] =
    useDeleteMembershipMutation();
  const [cancelMembershipRequest, { isLoading: isRejectingRequest }] =
    useCancelMembershipRequestMutation();

  const handleJoinOrRequest = () => {
    if (currentUser) {
      createMembershipRequest(community.id);
    } else {
      console.log('Please log in to join or request membership.');
      // TODO: Implement actual login redirection or modal
    }
  };

  const handleLeave = () => {
    if (currentUser) {
      deleteMembership(community.id);
    } else {
      console.log('Please log in to leave the community.');
    }
  };

  const handleCancelRequest = () => {
    if (currentUser && community.userMembershipStatus=="pending") {
      // Assuming communityId is used to reject the user's own request
      cancelMembershipRequest(community.id);
    } else {
      console.log('Error: Cannot cancel request.');
    }
  };

  if (!currentUser) {
    return (
      <Button onClick={() => console.log('Redirect to login')} disabled>
        Login to Join
      </Button>
    ); // Or null, depending on UX
  }

  switch (community.userMembershipStatus) {
    case 'member':
      return (
        <Button onClick={handleLeave} disabled={isDeletingMembership}>
          {isDeletingMembership ? 'Leaving...' : 'Joined'}
        </Button>
      );
    case 'pending':
      return (
        <Button onClick={handleCancelRequest} disabled={isRejectingRequest}>
          {isRejectingRequest ? 'Cancelling...' : 'Cancel Request'}
        </Button>
      );
    case 'none':
    default:
      return (
        <Button onClick={handleJoinOrRequest} disabled={isCreatingRequest}>
          {isCreatingRequest
            ? 'Sending Request...'
            : community.communityType === 'public'
            ? 'Join'
            : 'Request to Join'}
        </Button>
      );
  }
};

---


### FILE: frontend/src/features/communities/components/CreateCommunityForm.tsx ###
import React, { useState } from "react";
import { Button } from "../../../shared/components/ui/Button";
import { Input } from "../../../shared/components/ui/Input";
import { Label } from "../../../shared/components/ui/Label";
import { Select, type SelectOption } from "../../../shared/components/ui/Select";
import { Textarea } from "../../../shared/components/ui/TextArea";
import { zodResolver } from "@hookform/resolvers/zod";
import { Controller, useForm, type SubmitHandler } from "react-hook-form";
import z from "zod";
import { InputError } from "../../../shared/components/ui/InputError";
import { InputRadio } from "../../../shared/components/InputRadio";
import { useCreateCommunityMutation } from "../services/communitiesApi";
import type { ToastType } from "../../../shared/components/ui/Toast";
import Toast from "../../../shared/components/ui/Toast";

interface CreateCommunityFormProps {
  onClose: () => void;
}


const createCommunitySchema = z.object({
  communityType: z.enum(["public", "private", "restricted"]),  name: z
    .string()
    .min(3, "Community Name must be at least 3 characters"),
  description: z.string().optional(),
});

type CreateCommunityFormValues = z.infer<typeof createCommunitySchema>;

const stepFields: (keyof CreateCommunityFormValues)[][] = [
  ["communityType"], // Step 0
  ["name", "description"], // Step 1
];

const CreateCommunityForm: React.FC<CreateCommunityFormProps> = ({ onClose }) => {
  const [step, setStep] = React.useState(0);
  const [createCommunity, { isLoading }] = useCreateCommunityMutation();
   const [toast, setToast] = useState<{ message: string; type: ToastType } | null>(null);
  const {
    control,
    register,
    trigger,
    handleSubmit,
    formState: { errors },
  } = useForm<CreateCommunityFormValues>({
    resolver: zodResolver(createCommunitySchema),
    defaultValues: {
      name: "",
      description: "",
    },
  });

  const onSubmit: SubmitHandler<CreateCommunityFormValues> = async(data) => {
 try {
      const response = await createCommunity(data).unwrap(); // send data to API
      console.log("Community created:", response);
            setToast({ message: 'Community created successfully!', type: 'success' });
      onClose(); // close form or reset
    } catch (err) {
            setToast({ message: err?.data?.message || 'Failed to create community', type: 'error' });
      console.error("Failed to create community:", err);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="p-4">
      {/* Step 0: Community Type */}
{/* Step 0: Community Type */}
      {toast && <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />}
{step === 0 && (
  <div className="mb-4">

     <h2 className="text-xl font-bold mb-2">Choose your community type</h2>
    <p className="text-gray-600 mb-4">
      Each community type controls who can view and post in your community.
    </p>
    <Controller
      name="communityType"
      control={control}
      render={({ field }) => {
        const options = [
          { value: "public", title: "Public", description: "Anyone can view, post, and comment." },
          { value: "restricted", title: "Restricted", description: "Anyone can view, only approved users can post." },
          { value: "private", title: "Private", description: "Only approved users can view and post." },
        ];

        return (
          <div className="flex flex-col gap-3 mt-2">
            {options.map((option) => (
              <div
                key={option.value}
                className={`flex items-center p-4 border rounded-lg cursor-pointer transition
                  ${field.value === option.value ? "border-blue-500 bg-blue-50" : "border-gray-300 hover:bg-gray-50"}
                `}
                onClick={() => field.onChange(option.value)}
              >
                <InputRadio
                  checked={field.value === option.value}
                  onChange={() => field.onChange(option.value)}
                  size="md"
                  colorClass="bg-blue-500"
                />
                <div className="ml-3">
                  <div className="font-medium">{option.title}</div>
                  <div className="text-sm text-gray-500">{option.description}</div>
                </div>
              </div>
            ))}
          </div>
        );
      }}
    />
    <InputError message={errors.communityType?.message} />
  </div>
)}


      {/* Step 1: Community Info */}
      {step === 1 && (
        <>
                    <h2 className="text-xl font-bold mb-2">Tell us about your community</h2>
    <p className="text-gray-600 mb-4">
      Give your community a name and description so people know what it‚Äôs about.
    </p>
          <div className="mb-4">
  
            <Label htmlFor="name">Community Name:</Label>
            <Input id="name" {...register("name")} />
            <InputError message={errors.name?.message} />
          </div>
          <div className="mb-4">
            <Label htmlFor="description">Description:</Label>
            <Textarea id="description" {...register("description")} rows={4} />
            <InputError message={errors.description?.message} />
          </div>
        </>
      )}

      {/* Navigation */}
      <div className="flex gap-5 justify-end mt-4">
        {step > 0 && (
          <Button type="button" variant="secondary" onClick={() => setStep(step - 1)}>
            Back
          </Button>
        )}

        {step < 1 && (
          <Button
            type="button"
            onClick={async () => {
              const valid = await trigger(stepFields[step]);
              if (valid) setStep(step + 1);
            }}
          >
            Next
          </Button>
        )}

        {step === 1 && (
     <Button type="submit" disabled={isLoading}>
            {isLoading ? "Creating..." : "Create Community"}
          </Button>        )}
      </div>
    </form>
  );
};

export default CreateCommunityForm;

---


### FILE: frontend/src/features/communities/services/communitiesApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { Community, CreateCommunityDto, UpdateCommunityDto, CommunityQueryDto } from '../types';
import type { PaginatedResponse, ResponseDto } from '../../../shared/types';

export const communitiesApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    getCommunities: builder.query<PaginatedResponse<Community>, CommunityQueryDto>({
      query: (params) => ({
        url: '/communities',
        params,
      }),
      providesTags: ['Communities'],
    }),
    getCommunityById: builder.query<ResponseDto<Community>, number>({
      query: (id) => `/communities/${id}`,
      providesTags: (result, error, id) => [{ type: 'Communities', id }],
    }),
    createCommunity: builder.mutation<ResponseDto<Community>, CreateCommunityDto>({
      query: (newCommunity) => ({
        url: '/communities',
        method: 'POST',
        body: newCommunity,
      }),
      invalidatesTags: ['Communities'],
    }),
    updateCommunity: builder.mutation<ResponseDto<Community>, { id: number; data: UpdateCommunityDto }>({
      query: ({ id, data }) => ({
        url: `/communities/${id}`,
        method: 'PATCH',
        body: data,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Communities', id }],
    }),
    deleteCommunity: builder.mutation<ResponseDto<boolean>, number>({
      query: (id) => ({
        url: `/communities/${id}`,
        method: 'DELETE',
      }),
      invalidatesTags: ['Communities'],
    }),
  }),
});

export const {
  useGetCommunitiesQuery,
  useGetCommunityByIdQuery,
  useCreateCommunityMutation,
  useUpdateCommunityMutation,
  useDeleteCommunityMutation,
} = communitiesApi;

---


### FILE: frontend/src/features/comments/types.ts ###
import type { ReactionType } from "../reactions/types/types";

export interface Comment {
    id: number;
    content: string;
    author: {
        id: number;
        name: string;
    };
    postId: number;
    parentId?: number; // For replies
    likesCount: number;
    dislikesCount: number;
    repliesCount: number;
    userReaction?: { id: number; type: ReactionType } | null;
    replies?: Comment[]; // Added for nested replies

    createdAt: string;
    updatedAt: string;
}

export interface CreateCommentDto {
    content: string;
    parentId?: number;
}

export interface UpdateCommentDto {
    content: string;
}

export interface CommentQueryDto {
    page?: number;
    limit?: number;
    postId?: number;
    authorId?: number;
    parentId?: number;
}

export interface PaginatedResponse<T> {
    data: T[];
    meta: {
        page: number;
        limit: number;
        totalItems: number;

        totalPages: number;

        itemCount: number;
    };
}

export interface ResponseDto<T> {
    data: T;
    message: string;
}

---


### FILE: frontend/src/features/comments/components/CommentInput.tsx ###
import React, { useState } from 'react';
import { useCreateCommentMutation } from '../services/commentsApi';
import { useToastContext } from '../../../shared/providers/ToastProvider';
import { Button } from '../../../shared/components/ui/Button';
import { Textarea } from '../../../shared/components/ui/TextArea';

interface CommentInputProps {
  postId: number;
  parentId?: number;
  onCommentPosted?: () => void;
  onCancel?: () => void;
  autoFocus?: boolean;
  initialContent?: string;
}

export const CommentInput: React.FC<CommentInputProps> = ({
  postId,
  parentId,
  onCommentPosted,
  onCancel,
  autoFocus = false,
  initialContent = '',
}) => {
  const [content, setContent] = useState(initialContent);
  const [createComment, { isLoading }] = useCreateCommentMutation();
  const { showToast } = useToastContext();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!content.trim()) {
      showToast('Comment cannot be empty', 'error');
      return;
    }

    try {
      await createComment({ postId, data: { content, parentId } }).unwrap();
      setContent('');
      showToast('Comment posted successfully', 'success');
      onCommentPosted?.();
    } catch (error: any) {
      const errorMessage = error.data?.message || error.message || 'Failed to post comment';
      showToast(errorMessage, 'error');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="mt-4">
      <Textarea
        rows={parentId ? 2 : 4} // Smaller for replies
        placeholder={parentId ? 'Write a reply...' : 'Write a comment...'}
        value={content}
        onChange={(e) => setContent(e.target.value)}
        autoFocus={autoFocus}
      />
      <div className="flex justify-end space-x-2 mt-2">
        {onCancel && (
          <Button type="button" variant="ghost" onClick={onCancel}>
            Cancel
          </Button>
        )}
        <Button type="submit" >
          {parentId ? 'Reply' : 'Comment'}
        </Button>
      </div>
    </form>
  );
};
---


### FILE: frontend/src/features/comments/components/CommentCard.tsx ###
import { useState, useMemo, useEffect } from 'react';
import type { Comment } from '../types';
import { FaUser, FaReply } from 'react-icons/fa';
import { CommentReactionButtons } from '../../reactions/components/CommentReactionButtons';
import { useGetCommentsByPostIdInfiniteQuery } from '../services/commentsApi';
import { Button } from '../../../shared/components/ui/Button';
import { CommentInput } from './CommentInput'; // Import CommentInput
import { timeAgo } from '../../../shared/utils/date';

interface CommentCardProps {
  comment: Comment;
  postId: number;
  level: number; // Ensure level is passed
}

const REPLIES_LIMIT = 2;

const CommentCard: React.FC<CommentCardProps> = ({
  comment,
  postId,
  level,
}) => {
const [showReplies, setShowReplies] = useState(false);

useEffect(() => {
  if (comment.repliesCount > 0) {
    setShowReplies(true);
  }
}, [comment.repliesCount]);
  const [showReplyInput, setShowReplyInput] = useState(false); // State for reply input visibility

  const initialReplies = comment.replies ?? [];
  const initialRepliesCount = initialReplies.length;

  const hasMoreRepliesThanInitial = comment.repliesCount > initialRepliesCount;

  // Calculate the initial page parameter for the infinite query
  // If we already have initial replies, start fetching from the next page
  const initialQueryPageParam = 1

  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useGetCommentsByPostIdInfiniteQuery(
    {
      postId,
      parentId: comment.id,
      limit: REPLIES_LIMIT,
    },
    {
      skip: !showReplies || !hasMoreRepliesThanInitial,
      initialPageParam: initialQueryPageParam, // Set the initial page to start fetching from
    }
  );

  const allReplies = useMemo(() => {
    const fetchedReplies = data?.pages.flatMap(page => page.data) || [];
    const combinedReplies = [...initialReplies, ...fetchedReplies];

    const map = new Map<number, Comment>();
    combinedReplies.forEach(reply => map.set(reply.id, reply));

    return [...map.values()].sort(
      (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
    );
  }, [initialReplies, data]);
  const remainingReplies = Math.max(0, comment.repliesCount - allReplies.length);
  const handleReplyPosted = () => {
    setShowReplyInput(false);
    // Rely on RTK Query cache invalidation for UI update
  };

  return (
    <div className="mb-3">
      {/* COMMENT CARD */}
      <div className="rounded-lg border border-gray-300 bg-white p-4 ">
        <div className="mb-2 flex items-center text-sm text-gray-500">
          <FaUser className="mr-1" />
          <span>u/{comment.author.name}</span>
          <span className="mx-1">‚Ä¢</span>
          <span className='text-xs'>
            {timeAgo(comment.createdAt)}
          </span>
        </div>

        {/* DEBUG */}
        <div className="mb-1 text-xs text-gray-400">
          id: {comment.id}, parentId:{' '}
          {comment.parentId ?? 'null'}
          { showReplies? " 1" : " 0"}
        </div>

        <p className="mb-3 text-sm text-gray-800">
          {comment.content}
        </p>

        <div className="flex items-center space-x-4 text-xs text-gray-500">
          <CommentReactionButtons comment={comment} />

          <button
            onClick={() => setShowReplyInput(v => !v)} // Toggle reply input
            className="flex items-center space-x-1 hover:text-primary-600"
          >
            <FaReply />
            <span>Reply</span>
          </button>

            {comment.repliesCount > 0 && (
            <Button onClick={() => setShowReplies(v => !v)} variant="link">
              {showReplies ? (
                `Hide replies (${comment.repliesCount})`
              ) : remainingReplies > 0 ? (
                `+ Load replies (${remainingReplies} remaining)`
              ) : (
                `View replies (${comment.repliesCount})`
              )}
            </Button>
          )}
        </div>
      </div>

      {showReplyInput && (
        <div className="mt-3 ml-6 border-l border-gray-200 pl-4">
          <CommentInput
            postId={postId}
            parentId={comment.id}
            onCommentPosted={handleReplyPosted}
            onCancel={() => setShowReplyInput(false)}
            autoFocus
          />
        </div>
      )}

      {/* REPLIES */}
      {showReplies && allReplies.length > 0 && (
        <div className="mt-3 ml-6 border-l border-gray-200 pl-4">
          {allReplies.map(reply => (
            <CommentCard
              key={reply.id}
              comment={reply}
              postId={postId}
              level={level + 1}
            />
          ))}
        </div>
      )}

      {showReplies && hasNextPage && (
        <div className="flex justify-center mt-2 ml-6">
          <Button
            variant='link'
            onClick={fetchNextPage}
            disabled={isFetchingNextPage}
          >
            {isFetchingNextPage
              ? 'Loading more replies‚Ä¶'
              : '+ Load more replies'}
          </Button>
        </div>
      )}
    </div>
  );
};

export default CommentCard;

---


### FILE: frontend/src/features/comments/components/CommentList.tsx ###
import { Button } from '../../../shared/components/ui/Button';
import { useGetCommentsByPostIdInfiniteQuery } from '../services/commentsApi';
import CommentCard from './CommentCard';
import { CommentInput } from './CommentInput'; // Import CommentInput

interface CommentListProps {
    postId: number;
}

const CommentList: React.FC<CommentListProps> = ({ postId }) => {
    const {
        data,
        error,
        isLoading,
        fetchNextPage,
        hasNextPage,
        isFetchingNextPage,
    } = useGetCommentsByPostIdInfiniteQuery(
        { postId, limit: 10 }, // Pass postId and queryArg with limit
    );

    const allComments = data?.pages?.flatMap((page) => page.data) || [];

   
    
    console.log(allComments);
    
    if (isLoading) return <div>Loading comments...</div>;
    if (error) return <div>Error: {error.message}</div>;

    return (
        <div className="space-y-4">
            <CommentInput postId={postId} 
         />
            {allComments.length === 0 ? (
                <p>No comments yet. Be the first to comment!</p>
            ) : (
                allComments.map((comment) => (
                    <CommentCard key={comment.id} comment={comment} level={0} postId={postId} />
                ))
            )}
            {hasNextPage && (
                <div className="flex justify-center mt-4">
                    <Button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>
                        {isFetchingNextPage ? 'Loading more...' : 'Load More'}
                    </Button>
                </div>
            )}
        </div>
    );
};

export default CommentList;

---


### FILE: frontend/src/features/comments/services/commentsApi.ts ###
import { apiSlice } from '../../../shared/services/apiSlice';
import type { Comment, CreateCommentDto, UpdateCommentDto, CommentQueryDto, PaginatedResponse, ResponseDto } from '../types';

export const commentsApi = apiSlice.injectEndpoints({
    overrideExisting: false, // Ensure this is not overriding existing endpoints
    endpoints: (builder) => ({
        getCommentsByPostId: builder.infiniteQuery<
            PaginatedResponse<Comment>,
            CommentQueryDto, // Simplified type parameter
            number
        >({
            infiniteQueryOptions: {
                initialPageParam: 1,
                getNextPageParam: (lastPage) => {
                    const { page, totalPages } = lastPage.meta;
                    return page < totalPages ? page + 1 : undefined;
                },
            },
            query: ({ queryArg, pageParam }) => ({ // postId taken from queryArg
                url: `/posts/${queryArg.postId}/comments`, // Access postId from queryArg
                params: {
                    ...(queryArg ?? {}),
                    page: pageParam,
                    limit: queryArg?.limit ?? 10,
                },
            }),
           
            providesTags: ['Comments']
        }),
        createComment: builder.mutation<ResponseDto<Comment>, { postId: number; data: CreateCommentDto }>({
            query: ({ postId, data }) => ({
                url: `/posts/${postId}/comments`,
                method: 'POST',
                body: data,
            }),
            invalidatesTags: ['Comments',"Posts"],
        }),
        updateComment: builder.mutation<ResponseDto<Comment>, { id: number; data: UpdateCommentDto }>({
            query: ({ id, data }) => ({
                url: `/comments/${id}`,
                method: 'PATCH',
                body: data,
            }),
            invalidatesTags: ['Comments',"Posts"],
        }),
        deleteComment: builder.mutation<ResponseDto<boolean>, number>({
            query: (id) => ({
                url: `/comments/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: ['Comments',"Posts"],
        }),
    }),
});

export const {
    useGetCommentsByPostIdInfiniteQuery,
    useCreateCommentMutation,
    useUpdateCommentMutation,
    useDeleteCommentMutation,
} = commentsApi;

---


### FILE: frontend/src/App.tsx ###
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import AuthGuard from './features/auth/components/AuthGard';
import EmailVerification from './features/auth/pages/EmailVerification';
import Login from './features/auth/pages/Login';
import Register from './features/auth/pages/Register';
import VerificationResult from './features/auth/pages/VerificationResult';
import { CommunityPage } from './features/communities/pages/CommunityPage';
import ExploreCommunitiesPage from './features/communities/pages/ExploreCommunitiesPage';
import MyCommunitiesPage from './features/communities/pages/MyCommunitiesPage';
import FeedPage from './features/feed/pages/FeedPage';
import CreatePostPage from './features/posts/pages/CreatePostPage';
import PostDetailPage from './features/posts/pages/PostDetailPage';
import MainLayout from './layout/MainLayout';
import ModLayout from './layout/ModLayout';
import { ModQueuesPage } from './features/communities/pages/QueuesPage';
import { ModMembersPage } from './features/communities/pages/MembersPage';
import { ModModeratorsPage } from './features/communities/pages/ModeratorsPage';
// ... other imports

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* --- Public Auth Routes (No Sidebars) --- */}
        <Route path="/login" element={<Login />} />
        <Route path="/register" element={<Register />} />
        <Route path="/email-verification" element={<EmailVerification />} />
        <Route path="/verify-email" element={<VerificationResult />} />

        {/* --- Standard User Routes (with LeftSidebar) --- */}
        <Route element={<MainLayout />}>
          <Route path="/" element={<AuthGuard><FeedPage /></AuthGuard>} />
          <Route path="/posts/:id" element={<AuthGuard><PostDetailPage /></AuthGuard>} />
          <Route path="/submit" element={<AuthGuard><CreatePostPage /></AuthGuard>} />
          <Route path="/communities/:communityId" element={<AuthGuard><CommunityPage /></AuthGuard>} />
          <Route path="/my-communities" element={<AuthGuard><MyCommunitiesPage /></AuthGuard>} />
          <Route path="/explore-communities" element={<AuthGuard><ExploreCommunitiesPage /></AuthGuard>} />
        </Route>

        {/* --- Moderation Routes (with ModSidebar) --- */}
        <Route path="/mod/community/:communityId" element={<AuthGuard><ModLayout /></AuthGuard>}>
          <Route index element={<Navigate to="queues" replace />} />
          <Route path="queues" element={<ModQueuesPage />} />
          <Route path="members" element={<ModMembersPage />} />
          <Route path="moderators" element={<ModModeratorsPage />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
---


### FILE: frontend/src/shared/providers/ToastProvider.tsx ###
import React, { createContext, useContext } from 'react';
import { useToast, type ToastData } from '../hooks/useToast';
import  Toast from '../components/ui/Toast';

interface ToastContextType {
  showToast: (message: string, type: 'success' | 'error' | 'info') => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export const useToastContext = () => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToastContext must be used within a ToastProvider');
  }
  return context;
};

export const ToastProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {
  const { toast, showToast, hideToast } = useToast();

  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}
      {toast && (
        <Toast
          message={toast.message}
          type={toast.type}
          onClose={hideToast}
        />
      )}
    </ToastContext.Provider>
  );
};

---


### FILE: frontend/src/shared/components/ui/Label.tsx ###
import React from 'react';

export interface LabelProps
  extends React.LabelHTMLAttributes<HTMLLabelElement> {}

export const Label = React.forwardRef<
  HTMLLabelElement,
  LabelProps
>(({ className = '', ...props }, ref) => {
  return (
    <label
      ref={ref}
      className={`block text-sm font-medium text-gray-700 ${className}`}
      {...props}
    />
  );
});

Label.displayName = 'Label';

---


### FILE: frontend/src/shared/components/ui/InputError.tsx ###
import React from 'react';

export interface InputErrorProps
  extends React.HTMLAttributes<HTMLParagraphElement> {
  message?: string;
}

export const InputError = React.forwardRef<
  HTMLParagraphElement,
  InputErrorProps
>(({ message, className = '', ...props }, ref) => {
  if (!message) {
    return null;
  }
  return (
    <p
      ref={ref}
      className={`text-sm text-red-500 ${className}`}
      {...props}
    >
      {message}
    </p>
  );
});

InputError.displayName = 'InputError';

---


### FILE: frontend/src/shared/components/ui/Dropdown.tsx ###
import React, { useState, useRef, useEffect } from 'react';

interface DropdownProps {
  trigger: React.ReactNode;
  children: React.ReactNode;
  align?: 'left' | 'right';
  width?: '48';
}

const Dropdown: React.FC<DropdownProps> = ({
  trigger,
  children,
  align = 'right',
  width = '48',
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  const toggleOpen = () => {
    setIsOpen((prev) => !prev);
  };

  const close = () => {
    setIsOpen(false);
  };

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        close();
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const alignmentClasses = align === 'left' ? 'origin-top-left left-0' : 'origin-top-right right-0';
  const widthClasses = width === '48' ? 'w-48' : '';

  return (
    <div className="relative" ref={dropdownRef}>
      <div onClick={toggleOpen}>{trigger}</div>

      {isOpen && (
        <div
          className={`absolute z-50 mt-2 rounded-md shadow-lg ${alignmentClasses} ${widthClasses}`}
          onClick={close}
        >
          <div className="rounded-md ring-1 ring-gray-300  ring-opacity-5 bg-white dark:bg-gray-700">
            {children}
          </div>
        </div>
      )}
    </div>
  );
};

export default Dropdown;

---


### FILE: frontend/src/shared/components/ui/Select.tsx ###
import React, { useState, useRef, useEffect } from 'react';

export interface SelectOption {
  value: string | number;
  label: string;
  disabled?: boolean;
}

export interface SelectProps {
  options: SelectOption[];
  placeholder?: string;
  value?: string | number;
  onChange?: (value: string | number) => void;
  className?: string;
  id?: string; // if you need id
}

export const Select = React.forwardRef<HTMLDivElement, SelectProps>(
  ({ options, placeholder = 'Select...', value, onChange, className }, ref) => {
    const [open, setOpen] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);

    // Close dropdown on outside click
    useEffect(() => {
      const handleClickOutside = (e: MouseEvent) => {
        if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
          setOpen(false);
        }
      };
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const selectedLabel = options.find((o) => o.value === value)?.label;

    return (
      <div
        ref={(node) => {
          containerRef.current = node;
          if (ref && typeof ref === 'function') ref(node);
          else if (ref && 'current' in ref) ref.current = node;
        }}
        className={`relative w-full ${className}`}
      >
        {/* Button */}
        <button
          type="button"
          className="w-full text-left bg-white border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 flex justify-between items-center"
          onClick={() => setOpen((o) => !o)}
        >
          <span className={selectedLabel ? '' : 'text-gray-400'}>
            {selectedLabel || placeholder}
          </span>
          {/* Arrow */}
          <svg
            className={`w-4 h-4 transition-transform duration-150 ${open ? 'rotate-180' : ''}`}
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M6 8l4 4 4-4" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
          </svg>
        </button>

        {/* Dropdown */}
        {open && (
          <ul className="absolute z-50 mt-1 w-full bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-auto text-sm">
            {options.map((option) => (
              <li
                key={String(option.value)}
                className={`px-3 py-2 cursor-pointer hover:bg-blue-100 ${option.disabled ? 'text-gray-400 cursor-not-allowed' : ''
                  }`}
                onClick={() => {
                  if (!option.disabled && onChange) {
                    onChange(option.value); // use option.value directly
                    setOpen(false);
                  }
                }}

              >
                {option.label}
              </li>
            ))}
          </ul>
        )}
      </div>
    );
  }
);

Select.displayName = 'Select';

---


### FILE: frontend/src/shared/components/ui/Toast.tsx ###
import React, { useEffect } from 'react';

export type ToastType = 'success' | 'error' | 'info';

export interface ToastProps {
  message: string;
  type: ToastType;
  onClose: () => void;
}

const toastTypeClasses: Record<ToastType, string> = {
  success: 'bg-green-500/90',
  error: 'bg-red-500/90',
  info: 'bg-blue-500/90',
};

const Toast: React.FC<ToastProps> = ({ message, type, onClose }) => {
  useEffect(() => {
    const timer = setTimeout(onClose, 4000);
    return () => clearTimeout(timer);
  }, [onClose]);

  return (
    <div className="fixed top-6 left-1/2 -translate-x-1/2 z-50 animate-toast">
      <div
        className={`
          px-6 py-3 rounded-full text-sm font-medium text-white
          shadow-lg backdrop-blur
          ${toastTypeClasses[type]}
        `}
      >
        {message}
      </div>
    </div>
  );
};

export default Toast;

---


### FILE: frontend/src/shared/components/ui/TextArea.tsx ###
import React from 'react';

export interface TextareaClasses {
  base?: string;
}

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  classes?: TextareaClasses;
}

export const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  TextareaProps
>(
  (
    {
      classes = {},
      className = '',
      ...props
    },
    ref
  ) => {
    const classNames = [
      // ‚úÖ Tailwind default style
      'block w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm',
      'placeholder-gray-400 ',
      'focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500',
      'disabled:cursor-not-allowed disabled:opacity-50',
      'resize-y',

      // ‚úÖ overrides
      classes.base,
      className,
    ]
      .filter(Boolean)
      .join(' ');

    return (
      <textarea
        ref={ref}
        className={classNames}
        {...props}
      />
    );
  }
);

Textarea.displayName = 'Textarea';

---


### FILE: frontend/src/shared/components/ui/Button.tsx ###
import React from 'react';

export type ButtonVariant = 'default' | 'outline' | 'ghost' | 'destructive' | 'secondary' | 'link' | 'icon';
export type ButtonSize = 'sm' | 'md' | 'lg';

export interface ButtonClasses {
  base?: string;
  variant?: Partial<Record<ButtonVariant, string>>;
  size?: Partial<Record<ButtonSize, string>>;
}

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
  classes?: ButtonClasses;
}

export const Button = React.forwardRef<
  HTMLButtonElement,
  ButtonProps
>(
  (
    {
      variant = 'default',
      size = 'md',
      classes = {},
      className = '',
      ...props
    },
    ref
  ) => {
    const defaultClasses = {
      base: 'inline-flex font-medium items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background',
      variant: {
        default: 'bg-primary-600 text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary-100 text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'underline-offset-4 hover:underline text-primary-600',
        icon: 'h-10 w-10',
      },
      size: {
        sm: 'h-9 px-3 rounded-md',
        md: 'h-10 py-2 px-4',
        lg: 'h-11 px-8 rounded-md',
      },
    };

    const classNames = [
      defaultClasses.base,
      defaultClasses.variant[variant],
      defaultClasses.size[size],
      classes.base,
      classes.variant?.[variant],
      classes.size?.[size],
      className,
    ]
      .filter(Boolean)
      .join(' ');

    return (
      <button
        ref={ref}
        className={classNames}
        {...props}
      />
    );
  }
);

Button.displayName = 'Button';

---


### FILE: frontend/src/shared/components/ui/SearchableSelect.tsx ###
import React, { useEffect, useRef, useState } from 'react';

interface SearchableSelectProps<T> {
  value: string;
  onSearch: (term: string) => void;
  options: T[];
  loading?: boolean;
  onSelect: (item: T) => void;
  getLabel: (item: T) => string;
  renderOption?: (item: T) => React.ReactNode;
  placeholder?: string;
}

const SearchableSelect = <T extends { id: string | number }>({
  value,
  onSearch,
  options,
  loading = false,
  onSelect,
  getLabel,
  renderOption,
  placeholder = 'Search...',
}: SearchableSelectProps<T>) => {
  const [open, setOpen] = useState(false);
  const ref = useRef<HTMLDivElement>(null);

  /* -------------------------- Outside click ------------------------------- */

  useEffect(() => {
    const handler = (e: MouseEvent) => {
      if (ref.current && !ref.current.contains(e.target as Node)) {
        setOpen(false);
      }
    };
    document.addEventListener('mousedown', handler);
    return () => document.removeEventListener('mousedown', handler);
  }, []);

  /* ----------------------------------------------------------------------- */

  return (
    <div ref={ref} className="relative">
      <input
        value={value}
        onChange={(e) => {
          onSearch(e.target.value);
          setOpen(true);
        }}
        placeholder={placeholder}
        className="w-full rounded-md border border-gray-300 px-3 py-2"
      />

      {open && (
        <ul className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white shadow">
          {loading && (
            <li className="px-3 py-2 text-sm text-gray-500">Loading‚Ä¶</li>
          )}

          {!loading && options.length === 0 && (
            <li className="px-3 py-2 text-sm text-gray-500">No results</li>
          )}

          {!loading &&
            options.map((item) => (
              <li
                key={item.id}
                onClick={() => {
                  onSelect(item);
                  onSearch(getLabel(item));
                  setOpen(false);
                }}
                className="cursor-pointer px-3 py-2 hover:bg-primary-600 hover:text-white"
              >
                {renderOption ? renderOption(item) : getLabel(item)}
              </li>
            ))}
        </ul>
      )}
    </div>
  );
};

export default SearchableSelect;

---


### FILE: frontend/src/shared/components/ui/Input.tsx ###
import React from 'react';

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

export const Input = React.forwardRef<
  HTMLInputElement,
  InputProps
>(
  ({ className = '', ...props }, ref) => {
    const baseClasses =
      'block w-full rounded-md border border-gray-300 ' +
      'bg-white px-3 py-2 text-sm ' +
      'placeholder-gray-400 ' +
      'focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ' +
      'disabled:cursor-not-allowed disabled:opacity-50';

    return (
      <input
        ref={ref}
        className={`${baseClasses} ${className}`}
        {...props}
      />
    );
  }
);

Input.displayName = 'Input';

---


### FILE: frontend/src/shared/components/ui/Modal.tsx ###
import React from 'react';
import { createPortal } from 'react-dom';
export type ModalSize = 'sm' | 'md' | 'lg' | 'xl'; // added xl

export interface ModalClasses {
  backdrop?: string;
  container?: string;
  size?: Partial<Record<ModalSize, string>>;
}

export interface ModalProps {
  open: boolean;
  onClose?: () => void;
  size?: ModalSize;
  classes?: ModalClasses;
  children: React.ReactNode;
}

const DEFAULT_CLASSES: Required<ModalClasses> = {
  backdrop:
    'fixed inset-0 z-[999] flex items-center justify-center bg-black/40',
  container:
    'bg-white rounded-xl shadow-xl w-full mx-4',
  size: {
    sm: 'max-w-sm p-4',
    md: 'max-w-lg p-6',
    lg: 'max-w-2xl p-8',
    xl: 'max-w-4xl p-10', // added xl size
  },
};


export const Modal: React.FC<ModalProps> = ({
  open,
  onClose,
  size = 'md',
  classes = {},
  children,
}) => {
  if (!open) return null;

  const backdropClass = [
    DEFAULT_CLASSES.backdrop,
    classes.backdrop,
  ]
    .filter(Boolean)
    .join(' ');

  const containerClass = [
    DEFAULT_CLASSES.container,
    DEFAULT_CLASSES.size[size],
    classes.container,
    classes.size?.[size],
  ]
    .filter(Boolean)
    .join(' ');

  return createPortal(
    <div
      className={backdropClass}
      onClick={onClose}
    >
      <div
        className={containerClass}
        onClick={(e) => e.stopPropagation()}
      >
        {children}
      </div>
    </div>,document.body
  );
};

---


### FILE: frontend/src/shared/components/InputRadio.tsx ###
import React, { type FC } from "react";

interface InputRadioProps {
  checked: boolean;
  onChange: (checked: boolean) => void;
  disabled?: boolean;
  size?: "sm" | "md" | "lg" | "xl" | number; // variant sizes or custom px
  colorClass?: string; // Tailwind class for checked state
  className?: string; // wrapper class
}

const sizeMap: Record<string, string> = {
  sm: "w-4 h-4",   // 16px
  md: "w-6 h-6",   // 24px
  lg: "w-8 h-8",   // 32px
  xl: "w-10 h-10", // 40px
};

export const InputRadio: FC<InputRadioProps> = ({
  checked,
  onChange,
  disabled = false,
  size = "md",
  colorClass = "bg-primary-500",
  className = "",
}) => {
  // Determine dimension
  const dimension =
    typeof size === "number" ? `w-[${size}px] h-[${size}px]` : sizeMap[size] || sizeMap.md;

  return (
    <div
      className={`inline-flex items-center justify-center cursor-pointer select-none
        ${disabled ? "opacity-50 cursor-not-allowed" : ""} ${className}`}
      onClick={() => !disabled && onChange(true)}
    >
      {/* Hidden native input for accessibility */}
      <input type="radio" className="sr-only" checked={checked} disabled={disabled} readOnly />

      {/* Custom circle */}
      <div
        className={`border-2 border-gray-300 rounded-full flex items-center justify-center
          ${checked ? `${colorClass} border-transparent` : ""}
          transition-all duration-150
          ${dimension}
        `}
      >
        {checked && (
          <div
            className="bg-white rounded-full"
            style={{
              width: "50%",
              height: "50%",
            }}
          />
        )}
      </div>
    </div>
  );
};

---


### FILE: frontend/src/shared/stores/hooks.ts ###
import { useDispatch, useSelector } from 'react-redux'
import type { RootState, AppDispatch } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
export const useAppSelector = useSelector.withTypes<RootState>()

---


### FILE: frontend/src/shared/stores/store.ts ###
import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import authReducer from '../../features/auth/stores/authSlice';
import { apiSlice } from '../services/apiSlice';

export const store = configureStore({
  reducer: {
    [apiSlice.reducerPath]: apiSlice.reducer, // Use the base apiSlice reducer
    auth: authReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(apiSlice.middleware), // Use the base apiSlice middleware
});

setupListeners(store.dispatch);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

---


### FILE: frontend/src/shared/utils/date.ts ###
// frontend/src/shared/utils/date.ts

export const timeAgo = (dateString: string): string => {
  if (!dateString) return 'just now'; // Handle cases where dateString might be empty or null

  const now = new Date();
  const postDate = new Date(dateString);
  const seconds = Math.floor((now.getTime() - postDate.getTime()) / 1000);

  const intervals = [
    { label: 'year', seconds: 31536000 },
    { label: 'month', seconds: 2592000 },
    { label: 'week', seconds: 604800 },
    { label: 'day', seconds: 86400 },
    { label: 'hour', seconds: 3600 },
    { label: 'minute', seconds: 60 },
    { label: 'second', seconds: 1 },
  ];

  for (const interval of intervals) {
    const count = Math.floor(seconds / interval.seconds);
    if (count >= 1) {
      return `${count} ${interval.label}${count > 1 ? 's' : ''} ago`;
    }
  }

  return 'just now';
};

---


### FILE: frontend/src/shared/services/apiSlice.ts ###
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

// Create a base query with authentication headers
const baseQuery = fetchBaseQuery({
  baseUrl: 'http://localhost:3000/api/',
  prepareHeaders: (headers, { getState }) => {
    // Assuming your auth slice is named 'auth' and has an 'accessToken' field
    const token = (getState() as any).auth?.accessToken;
    if (token) {
      headers.set('Authorization', `Bearer ${token}`);
    }
    
    return headers;
  },
});

// Create a base API slice that other API slices can extend
export const apiSlice = createApi({
  reducerPath: 'api',
  baseQuery,
  // Define common tag types here if any, otherwise leave empty
  tagTypes: ['Posts', 'Comments', 'Users', 'Reactions',
     'Auth', 'Communities', 'CommunityMemberships',
      'EmailVerification', 'Profile', 'ResetPassword',
       'PostReaction', 'CommentReaction', 'PostStats',
        'CommentStats',"CommunityMembershipRequests"],
  endpoints: () => ({}), // Empty endpoints as this is a base slice
});

---


### FILE: frontend/src/shared/types/index.ts ###
export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    page: number;
    limit: number;
    totalItems: number;
    totalPages: number;
    itemCount: number;
  };
}

export interface ResponseDto<T> {
  data: T;
  message: string;
}

---


### FILE: frontend/src/shared/hooks/useToast.ts ###
import { useState, useCallback } from 'react';
import type { ToastType } from '../components/ui/Toast';

export interface ToastData {
  message: string;
  type: ToastType;
}

export const useToast = () => {
  const [toast, setToast] = useState<ToastData | null>(null);

  const showToast = useCallback((message: string, type: ToastType) => {
    setToast({ message, type });
  }, []);

  const hideToast = useCallback(() => {
    setToast(null);
  }, []);

  return {
    toast,
    showToast,
    hideToast,
  };
};

---


### FILE: frontend/src/main.tsx ###
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './index.css';
import App from './App';
import { Provider } from 'react-redux';
import { store } from './shared/stores/store';
import { ToastProvider } from './shared/providers/ToastProvider';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <Provider store={store}>
      <ToastProvider>
        <App />
      </ToastProvider>
    </Provider>
  </StrictMode>
);

---

